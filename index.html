<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ARNOMA - Student Management [v2.12.0 - Cancel Sync Fixed]</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0" />
    <parameter name="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="-1" />

    <!-- CACHE BUSTER: Force reload by changing title and meta tags -->
    <meta name="version" content="2.14.0" />
    <meta name="build-timestamp" content="20251121-130000" />
    <!-- Mobile Device Detection and Redirect -->
    <script>
      (function () {
        // Check if already on mobile version or explicitly requested desktop
        if (window.location.pathname.includes('index.mobile.html')) return;
        if (window.location.search.includes('desktop=1')) return;

        // Check if user is on mobile device
        const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|Windows Phone/i.test(navigator.userAgent);
        const isSmallScreen = window.innerWidth <= 768;

        // Redirect to mobile version
        if (isMobile || isSmallScreen) {
          console.log('üì± Mobile detected - redirecting to index.mobile.html');
          const baseUrl = window.location.origin + window.location.pathname.replace(/index\.html$/, '');
          window.location.replace(baseUrl + 'index.mobile.html' + window.location.search + window.location.hash);
        }
      })();
    </script>

    <!-- Supabase Configuration -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.1"></script>
    <script>
      // ‚ö° EXTREME PERFORMANCE CONFIG
      const DEBUG_MODE = false;
      const VERBOSE_LOGGING = false;

      const debugLog = (...args) => {
        if (DEBUG_MODE) console.log(...args);
      };

      const verboseLog = (...args) => {
        if (VERBOSE_LOGGING) console.log(...args);
      };

      // ‚ö° FIX #5: DISABLE CONSOLE PATCHING (causes delays)
      // Only patch in debug mode
      if (DEBUG_MODE) {
        (function patchConsoleLog() {
          const originalLog = console.log.bind(console);
          const allowedPrefixes = ['üî• ARNOMA', '‚ö°', '‚ùå', '‚úÖ', 'üîê', 'üö™'];

          console.log = (...args) => {
            const firstArg = args[0];
            const isAllowed =
              typeof firstArg === 'string' && allowedPrefixes.some(prefix => firstArg.startsWith(prefix));

            if (isAllowed || VERBOSE_LOGGING) {
              originalLog(...args);
            }
          };
        })();
      }

      // DEBOUNCE HELPER - Prevents excessive function calls during rapid events
      const debounce = (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      // Create debounced wrapper for inline oninput handlers
      const debouncedFilterStudentSearch = debounce(() => {
        if (typeof filterStudentSearch === 'function') {
          filterStudentSearch();
        }
      }, 300);

      // PERFORMANCE: Debounced filter for Student Manager
      const debouncedFilterStudents = debounce(() => {
        if (typeof filterStudents === 'function') {
          filterStudents();
        }
      }, 300);

      // VERSION CHECK - This should appear FIRST in console
      console.log('‚úÖ ARNOMA v2.14.0 - Canceled Class Calendar Fix ‚úÖ');

      // Supabase Client Initialization
      const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
      const SUPABASE_ANON_KEY =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      // ============================================================================
      // AUTHENTICATION SYSTEM
      // ============================================================================
      let isAuthenticated = false;
      let currentUser = null;

      async function checkAuthentication() {
        try {
          console.log('üîê Checking authentication...');
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error('‚ùå Auth error:', error);
            showLoginForm();
            return false;
          }

          if (session && session.user) {
            debugLog('‚úÖ User authenticated:', session.user.email);
            isAuthenticated = true;
            currentUser = session.user;
            hideLoginForm();
            return true;
          } else {
            debugLog('‚ö†Ô∏è No active session, showing login');
            showLoginForm();
            return false;
          }
        } catch (error) {
          console.error('‚ùå Authentication check failed:', error);
          showLoginForm();
          return false;
        }
      }

      async function handleLogin(email, password) {
        try {
          console.log('üîê Attempting login...');
          const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
          });

          if (error) {
            console.error('‚ùå Login error:', error);
            return { success: false, error: error.message };
          }

          if (data.session) {
            debugLog('‚úÖ Login successful:', data.user.email);
            isAuthenticated = true;
            currentUser = data.user;
            hideLoginForm();

            // Reset automation sync guard so we can push fresh data post-login exactly once
            window.__automationDataSent = false;
            window.__automationDataSendReason = null;
            window.__automationDataSentAt = null;
            const shouldForceAutomationSync =
              typeof initializationState !== 'undefined' && initializationState.emailSystem === true;

            // Reload data after successful login
            await initializeApp();

            if (shouldForceAutomationSync && typeof queueEmailDataSend === 'function') {
              queueEmailDataSend('post-login');
            }

            return { success: true };
          }
        } catch (error) {
          console.error('‚ùå Login failed:', error);
          return { success: false, error: error.message };
        }
      }

      async function handleLogout() {
        try {
          console.log('üö™ Logging out...');
          const { error } = await supabase.auth.signOut();

          if (error) {
            console.error('‚ùå Logout error:', error);
            return;
          }

          debugLog('‚úÖ Logged out successfully');
          isAuthenticated = false;
          currentUser = null;

          // Clear all caches
          window.paymentsCache = [];
          window.studentsCache = [];
          window.groupsCache = [];

          // Allow the next authenticated session to trigger a fresh automation sync
          window.__automationDataSent = false;
          window.__automationDataSendReason = null;
          window.__automationDataSentAt = null;

          showLoginForm();
        } catch (error) {
          console.error('‚ùå Logout failed:', error);
        }
      }

      function showLoginForm() {
        // Create login overlay if it doesn't exist
        let loginOverlay = document.getElementById('authLoginOverlay');

        if (!loginOverlay) {
          loginOverlay = document.createElement('div');
          loginOverlay.id = 'authLoginOverlay';
          loginOverlay.innerHTML = `
            <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); display: flex; align-items: center; justify-content: center; z-index: 999999;">
              <div style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px; padding: 40px; max-width: 400px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);">
                <div style="text-align: center; margin-bottom: 30px;">
                  <h1 style="color: white; font-size: 28px; margin: 0 0 8px 0; font-weight: 700;">ARNOMA</h1>
                  <p style="color: rgba(255, 255, 255, 0.6); font-size: 14px; margin: 0;">Student Management System</p>
                </div>

                <div id="authErrorMessage" style="display: none; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 10px; padding: 12px; margin-bottom: 20px; color: #ef4444; font-size: 13px; text-align: center;"></div>

                <form id="authLoginForm" onsubmit="event.preventDefault(); performLogin();" style="display: flex; flex-direction: column; gap: 16px;">
                  <div>
                    <label style="display: block; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Email</label>
                    <input type="email" id="authEmailInput" required autocomplete="email" style="width: 100%; padding: 12px 16px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 10px; color: white; font-size: 14px; outline: none; transition: all 0.2s;" onfocus="this.style.background='rgba(255,255,255,0.12)'; this.style.borderColor='rgba(138,180,255,0.5)'" onblur="this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='rgba(255,255,255,0.15)'">
                  </div>
                  <div>
                    <label style="display: block; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Password</label>
                    <input type="password" id="authPasswordInput" required autocomplete="current-password" style="width: 100%; padding: 12px 16px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 10px; color: white; font-size: 14px; outline: none; transition: all 0.2s;" onfocus="this.style.background='rgba(255,255,255,0.12)'; this.style.borderColor='rgba(138,180,255,0.5)'" onblur="this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='rgba(255,255,255,0.15)'">
                  </div>
                  <button type="submit" id="authLoginButton" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #8ab4ff, #a78bfa); border: none; border-radius: 10px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; margin-top: 8px; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 4px 15px rgba(138, 180, 255, 0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(138,180,255,0.4)'" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 15px rgba(138,180,255,0.3)'">
                    <span id="authLoginButtonText">Sign In</span>
                  </button>
                </form>

                <div style="text-align: center; margin-top: 24px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                  <p style="color: rgba(255, 255, 255, 0.4); font-size: 12px; margin: 0;">
                    üîí Secure authentication required
                  </p>
                </div>
              </div>
            </div>
          `;
          document.body.appendChild(loginOverlay);
        }

        loginOverlay.style.display = 'block';

        // Hide main content
        const mainContent = document.getElementById('mainApp');
        if (mainContent) mainContent.style.display = 'none';

        // Focus email input
        setTimeout(() => {
          const emailInput = document.getElementById('authEmailInput');
          if (emailInput) emailInput.focus();
        }, 100);
      }

      function hideLoginForm() {
        const loginOverlay = document.getElementById('authLoginOverlay');
        if (loginOverlay) {
          loginOverlay.style.display = 'none';
        }

        // Show main content
        const mainContent = document.getElementById('mainApp');
        if (mainContent) mainContent.style.display = 'block';
      }

      async function performLogin() {
        const emailInput = document.getElementById('authEmailInput');
        const passwordInput = document.getElementById('authPasswordInput');
        const loginButton = document.getElementById('authLoginButton');
        const loginButtonText = document.getElementById('authLoginButtonText');
        const errorMessage = document.getElementById('authErrorMessage');

        if (!emailInput || !passwordInput) return;

        const email = emailInput.value.trim();
        const password = passwordInput.value;

        // Show loading state
        loginButton.disabled = true;
        loginButtonText.textContent = 'Signing in...';
        errorMessage.style.display = 'none';

        const result = await handleLogin(email, password);

        if (result.success) {
          // Login successful - form will be hidden by handleLogin
          emailInput.value = '';
          passwordInput.value = '';
        } else {
          // Show error
          errorMessage.textContent = result.error || 'Login failed. Please check your credentials.';
          errorMessage.style.display = 'block';

          // Reset button
          loginButton.disabled = false;
          loginButtonText.textContent = 'Sign In';

          // Focus email input
          emailInput.focus();
          emailInput.select();
        }
      }

      // Make functions globally available
      window.performLogin = performLogin;
      window.handleLogout = handleLogout;

      // ============================================================================
      // END AUTHENTICATION SYSTEM
      // ============================================================================

      // Global data caches for performance
      window.paymentsCache = [];
      window.studentsCache = [];
      window.groupsCache = [];

      // ============================================================================
      // LOS ANGELES TIMEZONE UTILITIES
      // ============================================================================
      const LA_TIMEZONE = 'America/Los_Angeles';

      // Get current date/time in LA timezone
      function getNowLA() {
        return new Date(new Date().toLocaleString('en-US', { timeZone: LA_TIMEZONE }));
      }

      // Get today's date string in LA timezone (YYYY-MM-DD)
      function getTodayLA() {
        const now = getNowLA();
        return now.toISOString().slice(0, 10);
      }

      // Convert any date to LA timezone
      function toLA(date) {
        return new Date(date.toLocaleString('en-US', { timeZone: LA_TIMEZONE }));
      }

      // Format date in LA timezone
      function formatDateLA(date, options = {}) {
        return new Date(date).toLocaleString('en-US', {
          timeZone: LA_TIMEZONE,
          ...options,
        });
      }
    </script>

    <!-- BEGIN POPUP BACK & EXIT FIX -->
    <script>
      // Global Popup Management System
      // Ensures all popups have Back button, click-outside-to-close, and instant responsiveness
      window.PopupManager = {
        activePopups: new Set(),
        listenerRegistry: new WeakMap(),

        // Register a popup for management
        register(popupId, options = {}) {
          const popup = document.getElementById(popupId);
          if (!popup || popup.dataset.popupInitialized === 'true') return;

          popup.dataset.popupInitialized = 'true';
          const config = {
            hasBackButton: options.hasBackButton !== false,
            hasCloseButton: options.hasCloseButton !== false,
            closeOnOutsideClick: options.closeOnOutsideClick !== false,
            onClose: options.onClose || null,
            onBack: options.onBack || null,
            parent: options.parent || null,
          };

          // Store config
          popup._popupConfig = config;

          // Add back button if enabled
          if (config.hasBackButton) {
            this.addBackButton(popup, config.onBack);
          }

          // Setup click-outside-to-close
          if (config.closeOnOutsideClick) {
            this.setupOutsideClick(popup);
          }

          // Ensure all buttons are immediately responsive
          this.optimizeButtons(popup);
        },

        // Add back button to popup header
        addBackButton(popup, onBackCallback) {
          const header =
            popup.querySelector('[style*="justify-content: space-between"]') ||
            popup.querySelector('h3')?.parentElement;
          if (!header || header.querySelector('.popup-back-btn')) return;

          const backBtn = document.createElement('button');
          backBtn.className = 'popup-back-btn';
          backBtn.innerHTML = '‚Üê Back';
          backBtn.style.cssText = `
          background: none;
          border: none;
          color: var(--secondary, #94a3b8);
          opacity: 0.8;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          padding: 8px 12px;
          margin-right: auto;
          transition: all 0.2s ease;
          pointer-events: auto;
          position: absolute;
          left: 16px;
          top: 20px;
          z-index: 1;
        `;

          backBtn.onmouseover = () => {
            backBtn.style.opacity = '1';
            backBtn.style.textShadow = '0 0 8px rgba(148,163,184,0.6)';
          };
          backBtn.onmouseout = () => {
            backBtn.style.opacity = '0.8';
            backBtn.style.textShadow = 'none';
          };

          backBtn.onclick = e => {
            e.stopPropagation();
            if (onBackCallback) {
              onBackCallback();
            } else {
              this.close(popup.id);
            }
          };

          header.style.position = 'relative';
          header.insertBefore(backBtn, header.firstChild);
        },

        // Setup click-outside-to-close
        setupOutsideClick(popup) {
          // Find backdrop by ID (reliable method)
          let backdrop = document.getElementById(popup.id + 'Backdrop');

          if (backdrop) {
            // Remove old listener if exists
            const oldListener = this.listenerRegistry.get(backdrop);
            if (oldListener) {
              backdrop.removeEventListener('click', oldListener);
            }

            // Add new debounced listener
            const closeHandler = this.debounce(e => {
              e.stopPropagation();
              this.close(popup.id);
            }, 150);

            backdrop.addEventListener('click', closeHandler, { once: false });
            this.listenerRegistry.set(backdrop, closeHandler);

            // Ensure backdrop is clickable
            backdrop.style.cursor = 'pointer';
            backdrop.style.pointerEvents = 'auto';
          }
        },

        // Optimize all buttons in popup for instant response
        optimizeButtons(popup) {
          const buttons = popup.querySelectorAll('button, [onclick]');
          buttons.forEach(btn => {
            // Ensure immediate pointer events
            btn.style.pointerEvents = 'auto';
            btn.style.transition = btn.style.transition || 'all 0.2s ease';

            // Remove any existing duplicate listeners
            const clone = btn.cloneNode(true);
            btn.parentNode?.replaceChild(clone, btn);
          });
        },

        // Debounce helper (prevents double-clicks)
        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },

        // Open popup with fade-in
        open(popupId) {
          const popup = document.getElementById(popupId);
          if (!popup) return;

          this.activePopups.add(popupId);
          popup.style.display = 'block';
          popup.style.opacity = '0';
          popup.style.transition = 'opacity 0.25s ease';

          // Trigger fade-in
          requestAnimationFrame(() => {
            popup.style.opacity = '1';
          });

          // Show backdrop if exists
          const backdrop = document.getElementById(popupId + 'Backdrop');
          if (backdrop) {
            backdrop.style.display = 'block';
            backdrop.style.opacity = '0';
            backdrop.style.transition = 'opacity 0.25s ease';
            requestAnimationFrame(() => {
              backdrop.style.opacity = '1';
            });
          }
        },

        // Close popup with fade-out
        close(popupId) {
          const popup = document.getElementById(popupId);
          if (!popup) return;

          const config = popup._popupConfig;

          // Fade out
          popup.style.opacity = '0';
          const backdrop = document.getElementById(popupId + 'Backdrop');
          if (backdrop) {
            backdrop.style.opacity = '0';
          }

          // Hide after transition
          setTimeout(() => {
            popup.style.display = 'none';
            if (backdrop) backdrop.style.display = 'none';
            this.activePopups.delete(popupId);

            // Call onClose callback
            if (config?.onClose) {
              config.onClose();
            }
          }, 250);
        },

        // Close all popups
        closeAll() {
          this.activePopups.forEach(id => this.close(id));
        },
      };
    </script>
    <!-- END POPUP BACK & EXIT FIX -->

    <style>
      :root {
        --primary: #3b82f6;
        --secondary: #94a3b8;
        --ink: #0f172a;
        --ink-dim: #64748b;
        --stroke: rgba(148, 163, 184, 0.2);
        --text: #f8fafc;
        --background: #0f1419;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Calendar dot tooltip */
      .calendar-dot {
        position: relative;
        z-index: 1;
      }

      .calendar-dot:hover {
        z-index: 9998;
      }

      .calendar-dot::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 120%;
        left: 50%;
        transform: translateX(-50%) scale(0.9);
        opacity: 0;
        pointer-events: none;
        white-space: nowrap;
        background: rgba(0, 0, 0, 0.95);
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        z-index: 9999;
        transition: all 0.2s ease;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .calendar-dot:hover::after {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(100px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      body {
        font-family:
          Inter,
          -apple-system,
          BlinkMacSystemFont,
          'Segoe UI',
          Roboto,
          Oxygen,
          Ubuntu,
          Cantarell,
          sans-serif;
        background: #0b0b10;
        color: #e5e7eb;
        min-height: 100vh;
        padding: 20px;
        margin: 0;
      }

      .container {
        max-width: 1540px;
        margin: 0 auto;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
        overflow: hidden;
        transition: 0.25s ease-in-out;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 24px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .header h1 {
        font-size: 24px;
        font-weight: 700;
        color: white;
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }

      .header-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-btn {
        width: 36px;
        height: 36px;
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        padding: 0;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: scale(1.1);
      }

      .control-btn.spinning {
        animation: spin 1s linear infinite;
      }

      /* Settings button active state - green glow when timezone offset is ON */
      .control-btn.settings-active {
        box-shadow:
          0 0 8px rgba(34, 197, 94, 0.7),
          0 0 16px rgba(34, 197, 94, 0.5),
          0 0 24px rgba(34, 197, 94, 0.35) !important;
        border-color: #22c55e !important;
        background: rgba(34, 197, 94, 0.15) !important;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .gmail-btn {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
      }

      .gmail-btn:hover {
        background: rgba(255, 255, 255, 0.25);
      }

      .gmail-btn.connected {
        background: rgba(34, 197, 94, 0.2);
        border-color: rgba(34, 197, 94, 0.4);
        color: #22c55e;
      }

      #autoRefreshToggle.auto-refresh-active {
        background: rgba(34, 197, 94, 0.2);
        border-color: rgba(34, 197, 94, 0.4);
        color: #22c55e;
      }

      .stats {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
        margin-left: 8px;
      }

      .filter-dropdown {
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        margin-left: 8px;
      }

      .content {
        padding: 20px;
        max-height: calc(90vh - 100px);
        overflow-y: auto;
      }

      .date-section {
        margin-bottom: 24px;
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(51, 65, 85, 0.5);
        border-radius: 12px;
        overflow: hidden;
      }

      .date-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 20px;
        background: rgba(15, 23, 42, 0.8);
        border-bottom: 1px solid rgba(51, 65, 85, 0.5);
      }

      .date-title {
        font-size: 15px;
        font-weight: 600;
        color: #e2e8f0;
        letter-spacing: 0.3px;
      }

      .date-total {
        font-size: 14px;
        font-weight: 600;
        color: #94a3b8;
      }

      .payments-table {
        background: transparent;
        border: none;
        overflow: hidden;
      }

      .table-header {
        display: grid;
        grid-template-columns: 100px 1fr 1fr 100px 1fr 180px 1fr 40px;
        gap: 16px;
        padding: 14px 20px;
        background: rgba(30, 41, 59, 0.4);
        border-bottom: 1px solid rgba(51, 65, 85, 0.5);
        font-size: 11px;
        font-weight: 700;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .table-row {
        display: grid;
        grid-template-columns: 100px 1fr 1fr 100px 1fr 180px 1fr 40px;
        gap: 16px;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        font-size: 13px;
        color: #e2e8f0;
        transition: background 0.15s ease;
      }

      .table-row:hover {
        background: rgba(51, 65, 85, 0.25);
      }

      .table-row:last-child {
        border-bottom: none;
      }

      .unmatched-badge {
        padding: 4px 10px;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.4);
        border-radius: 4px;
        color: #ef4444;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        margin-left: 8px;
        white-space: nowrap;
      }

      .amount-usd {
        color: #22c55e;
        font-weight: 700;
      }

      .amount-amd {
        color: #94a3b8;
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--secondary);
      }

      .empty-icon {
        font-size: 48px;
        margin-bottom: 10px;
        opacity: 0.5;
      }

      /* BEGIN PAYMENT RECORDS ORDER & HIGHLIGHT FIX */
      .payment-row-new {
        animation: blinkGreenTint 1.5s ease-in-out infinite;
        box-shadow: 0 0 8px rgba(0, 255, 160, 0.3);
      }

      @keyframes blinkGreenTint {
        0%,
        100% {
          background: rgba(0, 255, 140, 0.12);
          border-color: rgba(0, 255, 160, 0.3);
        }
        50% {
          background: rgba(0, 255, 140, 0.25);
          border-color: rgba(0, 255, 160, 0.5);
        }
      }
      /* END PAYMENT RECORDS ORDER & HIGHLIGHT FIX */

      /* BEGIN BULK ADD STUDENTS FEATURE */
      #bulkAddStudentsModal {
        transition: opacity 0.25s ease;
      }

      #bulkAddStudentsModal textarea {
        transition: border-color 0.2s ease;
      }

      #bulkAddStudentsModal textarea:focus {
        outline: none;
        border-color: rgba(59, 130, 246, 0.5);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      /* END BULK ADD STUDENTS FEATURE */

      /* BEGIN DROPDOWN VISIBILITY FIX */
      select,
      option {
        color: #e8e8f0 !important;
        background-color: rgba(30, 30, 40, 0.9) !important;
      }

      select option:hover,
      select option:focus,
      select:focus {
        background-color: rgba(90, 90, 120, 0.95) !important;
        color: #ffffff !important;
      }

      select option:checked {
        background-color: rgba(100, 100, 160, 0.9) !important;
        color: #ffffff !important;
      }
      /* END DROPDOWN VISIBILITY FIX */

      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }

      #paymentActionsPopup.active {
        display: block !important;
      }

      /* Overlay for popup */
      #paymentActionsPopup::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: -1;
      }

      /* Month Total Stats */
      .month-total-section {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.1));
        border: 1px solid rgba(34, 197, 94, 0.3);
        border-radius: 8px;
        padding: 0;
        margin: 20px;
        overflow: hidden;
      }

      .month-total-header-row {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px 20px;
      }

      .month-total-header-left {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .month-total-values {
        padding: 0 20px 16px 20px;
        transition:
          max-height 0.3s ease,
          opacity 0.3s ease,
          padding 0.3s ease;
        max-height: 200px;
        opacity: 1;
        overflow: hidden;
      }

      .month-total-values.collapsed {
        max-height: 0;
        opacity: 0;
        padding: 0 20px;
      }

      .month-total-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        width: 100%;
      }

      .month-total-stats {
        display: flex;
        align-items: center;
        gap: 32px;
        margin-left: auto;
      }

      .month-total-item {
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }

      .month-total-toggle {
        background: transparent;
        border: none;
        color: var(--text);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        transition:
          transform 0.2s ease,
          opacity 0.2s ease;
        width: auto;
        height: auto;
      }

      .month-total-toggle:hover {
        opacity: 0.7;
        transform: scale(1.1);
      }

      .month-total-toggle span {
        font-size: 18px;
        font-weight: 700;
      }

      .month-total-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--secondary);
        font-weight: 600;
      }

      .month-total-value {
        font-size: 18px;
        font-weight: 700;
        color: #22c55e;
      }

      .month-selector {
        padding: 8px 16px;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.15));
        border: 1px solid rgba(138, 180, 255, 0.4);
        border-radius: 10px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        outline: none;
        appearance: none;
        padding-right: 32px;
        background-image:
          linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.15)),
          url('data:image/svg+xml;charset=UTF-8,<svg width="12" height="8" viewBox="0 0 12 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1.5L6 6.5L11 1.5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
        background-repeat: no-repeat, no-repeat;
        background-position:
          center,
          right 10px center;
      }

      .month-selector:hover {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.25), rgba(139, 92, 246, 0.25));
        border-color: rgba(138, 180, 255, 0.6);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        transform: translateY(-1px);
      }

      .month-selector:focus {
        border-color: rgba(138, 180, 255, 0.8);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
      }

      .month-selector option {
        background: #1a1f2e;
        color: white;
        padding: 10px;
      }

      /* Student Manager Styles */
      .group-btn:hover {
        box-shadow:
          0 0 0 0.1em hsla(223, 90%, 60%, 0.3),
          0 0 0.2em #94a3b8 inset,
          0 0.1em 0.1em #f1f5f9;
      }

      /* Elite Amount Buttons - Purple Theme */
      .group-buttons:nth-child(2) .group-btn {
        background: linear-gradient(135deg, rgba(88, 28, 135, 0.5), rgba(67, 20, 103, 0.7));
        border: 1px solid rgba(168, 85, 247, 0.3);
        box-shadow:
          0 2px 8px rgba(168, 85, 247, 0.25),
          inset 0 1px 0 rgba(255, 255, 255, 0.05),
          inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        color: rgba(216, 180, 254, 0.9);
      }

      .group-buttons:nth-child(2) .group-btn:hover {
        background: linear-gradient(135deg, rgba(126, 34, 206, 0.5), rgba(107, 33, 168, 0.6));
        border-color: rgba(168, 85, 247, 0.5);
        box-shadow:
          0 4px 12px rgba(168, 85, 247, 0.35),
          0 0 20px rgba(168, 85, 247, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        color: #ffffff;
      }

      .group-buttons:nth-child(2) .group-btn.active {
        background: linear-gradient(135deg, #a855f7, #9333ea);
        border-color: rgba(168, 85, 247, 0.8);
        box-shadow:
          0 4px 16px rgba(168, 85, 247, 0.5),
          0 0 24px rgba(168, 85, 247, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2),
          inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .group-buttons:nth-child(2) .group-btn.active:hover {
        box-shadow:
          0 6px 20px rgba(168, 85, 247, 0.6),
          0 0 30px rgba(168, 85, 247, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.25);
      }

      /* Group Manager Styles */
      .group-day-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
      }

      .group-day-btn.active {
        background: linear-gradient(135deg, #a78bfa, #c084fc) !important;
        border-color: rgba(167, 139, 250, 0.8) !important;
        color: white !important;
        box-shadow: 0 4px 20px rgba(167, 139, 250, 0.6) !important;
        font-weight: 700 !important;
        transform: scale(1.05) !important;
      }

      /* Group Manager Styles */
      .group-card {
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(30px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 14px;
        padding: 20px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        transition: all 0.2s;
      }

      .group-card:hover {
        border-color: rgba(138, 180, 255, 0.4);
        box-shadow: 0 8px 24px rgba(138, 180, 255, 0.2);
      }

      .group-title {
        font-size: 22px;
        font-weight: 700;
        background: linear-gradient(135deg, #8ab4ff, #a855f7);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 12px;
      }

      .schedule-display {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 12px 0;
      }

      .schedule-item {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        padding: 6px 10px;
        background: rgba(255, 255, 255, 0.04);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        font-size: 13px;
        transition: all 0.2s;
      }

      .schedule-item:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(138, 180, 255, 0.3);
      }

      .schedule-item.upcoming-green {
        background: rgba(34, 197, 94, 0.15) !important;
        border-color: rgba(34, 197, 94, 0.4) !important;
        color: #4ade80 !important;
        box-shadow: 0 4px 14px rgba(34, 197, 94, 0.25);
      }

      .schedule-item.upcoming-orange {
        background: rgba(251, 191, 36, 0.15) !important;
        border-color: rgba(251, 191, 36, 0.4) !important;
        color: #fbbf24 !important;
        box-shadow: 0 4px 14px rgba(251, 191, 36, 0.3);
      }

      .schedule-item.upcoming-red {
        background: rgba(239, 68, 68, 0.18) !important;
        border-color: rgba(239, 68, 68, 0.45) !important;
        color: #f87171 !important;
        box-shadow: 0 4px 18px rgba(239, 68, 68, 0.35);
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.85;
        }
      }

      .group-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .group-actions button {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        background: rgba(138, 180, 255, 0.15);
        color: #8ab4ff;
        border: 1px solid rgba(138, 180, 255, 0.3);
      }

      .group-actions button:hover {
        background: rgba(138, 180, 255, 0.25);
        transform: translateY(-1px);
      }

      .schedule-editor {
        margin-top: 16px;
        padding: 16px;
        background: linear-gradient(135deg, rgba(138, 180, 255, 0.08), rgba(168, 85, 247, 0.08));
        border: 2px solid rgba(138, 180, 255, 0.3);
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(138, 180, 255, 0.15);
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slot-row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      .slot-row select,
      .slot-row input[type='time'] {
        flex: 1;
        padding: 8px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        color: white;
        font-size: 13px;
      }

      .slot-row button {
        padding: 8px 10px;
        background: rgba(244, 67, 54, 0.15);
        color: #f44336;
        border: 1px solid #f44336;
        border-radius: 6px;
        font-weight: 700;
        cursor: pointer;
        font-size: 14px;
      }

      #toast {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 30000;
        transition: opacity 0.3s;
      }

      #toast.show {
        opacity: 1 !important;
        pointer-events: auto !important;
      }

      /* Student Manager Styles */
      .student-card,
      .student-item {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        padding: 0;
        overflow: hidden;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow:
          0 8px 32px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
        position: relative;
        z-index: 1;
      }

      .student-card:hover,
      .student-item:hover {
        transform: translateY(-8px);
        box-shadow:
          0 20px 60px rgba(138, 180, 255, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.15);
        border-color: rgba(138, 180, 255, 0.3);
      }

      .student-item.editing {
        border-color: rgba(74, 222, 128, 0.4);
        background: linear-gradient(145deg, rgba(20, 35, 28, 0.95), rgba(15, 28, 22, 0.95));
        box-shadow:
          0 8px 32px rgba(74, 222, 128, 0.25),
          0 0 40px rgba(74, 222, 128, 0.15);
      }

      .student-view {
        cursor: pointer;
        overflow: visible !important;
      }

      .student-edit {
        display: none;
        overflow: visible !important;
      }

      .student-item.editing .student-view {
        display: none;
      }

      .student-item.editing .student-edit {
        display: block;
      }

      .student-name {
        font-weight: 800;
        font-size: 20px;
        color: #ffffff;
        margin: 0;
        padding: 20px 20px 16px 20px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        letter-spacing: -0.3px;
        background: linear-gradient(135deg, rgba(138, 180, 255, 0.08), rgba(99, 102, 241, 0.08));
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .student-name:hover {
        color: #8ab4ff;
        text-shadow:
          0 2px 8px rgba(0, 0, 0, 0.5),
          0 0 20px rgba(138, 180, 255, 0.4);
      }

      .student-group {
        font-size: 13px;
        color: rgba(138, 180, 255, 0.7);
        margin-bottom: 20px;
        font-weight: 600;
        letter-spacing: 0.3px;
      }

      /* BEGIN FEATURE 2 - Elite Group Switch Buttons */
      .group-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        margin: 0;
        position: relative;
        z-index: 50;
        padding: 2px 0;
      }

      .group-buttons::-webkit-scrollbar {
        height: 2px;
      }

      .group-buttons::-webkit-scrollbar-track {
        background: transparent;
      }

      .group-buttons::-webkit-scrollbar-thumb {
        background: rgba(138, 180, 255, 0.3);
        border-radius: 2px;
      }

      /* WHITE EMBOSS BUTTONS - GLASSMORPHISM DESIGN */
      /* OUTER CIRCLE */
      .btn-wrapper {
        --size: 40px;
        --padding: 5px;
        --hue: 142deg;

        width: var(--size);
        height: var(--size);
        border-radius: 50%;
        background: #ffffff;

        display: flex;
        align-items: center;
        justify-content: center;

        /* soft background halo */
        box-shadow:
          0 10px 22px rgba(0, 0, 0, 0.12),
          0 4px 10px rgba(0, 0, 0, 0.06),
          inset 2px 2px 5px rgba(255, 255, 255, 0.8),
          inset -2px -2px 6px rgba(0, 0, 0, 0.04);
      }

      /* Active wrapper grows to 50px and adds neon glow */
      .btn-wrapper:has(.btn.active) {
        --size: 50px;
        box-shadow:
          0 0 15px hsla(var(--hue), 100%, 60%, 0.35),
          0 0 30px hsla(var(--hue), 100%, 60%, 0.21),
          0 0 45px hsla(var(--hue), 100%, 60%, 0.1),
          0 10px 22px rgba(0, 0, 0, 0.12),
          0 4px 10px rgba(0, 0, 0, 0.06),
          inset 2px 2px 5px rgba(255, 255, 255, 0.8),
          inset -2px -2px 6px rgba(0, 0, 0, 0.04);
      }

      /* Group-specific colors */
      .btn-wrapper.group-A {
        --hue: 346deg;
      } /* Pastel Pink */
      .btn-wrapper.group-B {
        --hue: 23deg;
      } /* Peach/Coral */
      .btn-wrapper.group-C {
        --hue: 50deg;
      } /* Soft Yellow */
      .btn-wrapper.group-D {
        --hue: 145deg;
      } /* Mint Green */
      .btn-wrapper.group-E {
        --hue: 204deg;
      } /* Baby Blue */
      .btn-wrapper.group-F {
        --hue: 260deg;
      } /* Pastel Lavender */

      /* Amount buttons - darker green */
      .btn-wrapper.amount {
        --hue: 145deg;
      }
      .btn-wrapper.amount .btn.active .btn-txt {
        background: linear-gradient(180deg, hsla(145, 80%, 40%, 1), hsla(145, 75%, 28%, 1));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        color: transparent;
        filter: drop-shadow(0 0 7px hsla(145, 80%, 35%, 0.85)) drop-shadow(0 0 12px hsla(145, 75%, 28%, 0.75));
      }

      /* INNER BUTTON (EMBOSSED) */
      .btn {
        width: calc(100% - 2 * var(--padding));
        height: calc(100% - 2 * var(--padding));
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background: #f5f5f5;

        display: flex;
        align-items: center;
        justify-content: center;

        /* ‚ú® EMBOSS EFFECT HERE ‚ú® */
        box-shadow:
          inset 3px 3px 6px rgba(0, 0, 0, 0.12),
          /* bottom-right shadow */ inset -3px -3px 7px rgba(255, 255, 255, 0.9),
          /* top-left highlight */ 0 3px 6px rgba(0, 0, 0, 0.08); /* slight outer lift */

        transition:
          transform 0.15s ease,
          box-shadow 0.25s ease;
      }

      /* TEXT + PERFECT CENTER */
      .btn-txt {
        font-size: 18px;
        font-weight: 700;
        line-height: 1;
        display: flex;
        align-items: center;
        color: #333;
        transition: all 0.3s ease;
      }

      .btn-txt.small {
        font-size: 13px;
      }

      /* ACTIVE (CLICK) GLOW + BACKGROUND GLOSS */
      .btn.active {
        box-shadow:
          inset 2px 2px 6px rgba(255, 255, 255, 0.9),
          inset -4px -4px 12px rgba(0, 0, 0, 0.08),
          0 0 18px hsla(var(--hue), 80%, 65%, 0.25);
      }

      .btn.active .btn-txt {
        background: linear-gradient(180deg, hsla(var(--hue), 100%, 48%, 1), hsla(var(--hue), 90%, 35%, 1));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        color: transparent;

        filter: drop-shadow(0 0 7px hsla(var(--hue), 100%, 48%, 0.95))
          drop-shadow(0 0 12px hsla(var(--hue), 100%, 38%, 0.85));
      }

      /* CLICK PRESS */
      .btn:active {
        transform: scale(0.96);
      }

      .student-status {
        font-size: 0.85rem;
        opacity: 0.8;
        margin-bottom: 4px;
      }

      /* Quick View - Today Highlight */
      .quickview-today-stroke {
        border: 2px solid rgba(255, 255, 255, 0.65) !important;
        border-radius: 12px;
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
      }

      .price-pill {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 0.85rem;
        background: linear-gradient(135deg, #8ab4ff, #a855f7);
        color: #fff;
        font-weight: 700;
        margin-top: 8px;
      }

      .status-pill-single {
        padding: 6px 16px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        border: 1px solid;
        user-select: none;
      }

      .status-active {
        background: rgba(76, 175, 80, 0.25);
        border: 2px solid #4caf50;
        color: #5eff6c;
        text-shadow:
          0 0 10px rgba(94, 255, 108, 0.5),
          0 0 20px rgba(94, 255, 108, 0.32);
        box-shadow:
          0 0 15px rgba(76, 175, 80, 0.38),
          0 0 30px rgba(76, 175, 80, 0.25),
          0 0 45px rgba(76, 175, 80, 0.13),
          inset 0 0 10px rgba(94, 255, 108, 0.13);
      }

      .status-active:hover {
        background: rgba(76, 175, 80, 0.25);
        border-color: rgba(76, 175, 80, 0.6);
        transform: scale(1.05);
      }

      .status-paused {
        background: rgba(251, 191, 36, 0.15);
        border-color: rgba(251, 191, 36, 0.4);
        color: #fbbf24;
      }

      .status-paused:hover {
        background: rgba(251, 191, 36, 0.25);
        border-color: rgba(251, 191, 36, 0.6);
        transform: scale(1.05);
      }

      .status-graduated {
        background: rgba(167, 139, 250, 0.15);
        border-color: rgba(167, 139, 250, 0.4);
        color: #a78bfa; /* Lavender purple for graduated students */
      }

      .status-graduated:hover {
        background: rgba(167, 139, 250, 0.25);
        border-color: rgba(167, 139, 250, 0.6);
        transform: scale(1.05);
      }

      .mini-toggle {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
      }

      .mini-toggle input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.1);
        transition: 0.3s;
        border-radius: 24px;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .slider:before {
        position: absolute;
        content: '';
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: #8ab4ff;
        border-color: #8ab4ff;
        box-shadow:
          0 0 10px hsla(145, 100%, 50%, 0.5),
          0 0 20px hsla(145, 100%, 50%, 0.3),
          0 0 30px hsla(145, 100%, 50%, 0.15);
      }

      input:checked + .slider:before {
        transform: translateX(20px);
      }

      .inline-form-group {
        margin-bottom: 16px;
      }

      .inline-form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: #f3f4f6;
        font-size: 12px;
      }

      .inline-form-group input,
      .inline-form-group textarea {
        width: 100%;
        padding: 10px;
        background: rgba(255, 255, 255, 0.08);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: #f3f4f6;
        font-size: 14px;
        font-family: inherit;
      }

      .inline-form-group input:focus,
      .inline-form-group textarea:focus {
        outline: none;
        border-color: #8ab4ff;
        background: rgba(138, 180, 255, 0.12);
      }

      .inline-form-group textarea {
        min-height: 60px;
        resize: vertical;
      }

      .inline-actions {
        display: flex;
        gap: 8px;
        margin-top: 16px;
      }

      .action-btn {
        flex: 1;
        padding: 10px;
        border: 2px solid;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
      }

      .edit-btn {
        background: rgba(138, 180, 255, 0.15);
        border-color: #8ab4ff;
        color: #8ab4ff;
      }

      .edit-btn:hover {
        background: rgba(138, 180, 255, 0.25);
      }

      .waiting-btn {
        background: rgba(168, 85, 247, 0.15);
        border-color: #a855f7;
        color: #a855f7;
      }

      .waiting-btn:hover {
        background: rgba(168, 85, 247, 0.25);
      }

      .delete-btn {
        background: rgba(244, 67, 54, 0.15);
        border-color: #f44336;
        color: #f44336;
      }

      .delete-btn:hover {
        background: rgba(244, 67, 54, 0.25);
      }

      .group-select-btn.selected {
        background: #8ab4ff !important;
        color: white !important;
        border-color: #8ab4ff !important;
      }

      .student-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        overflow: visible !important;
      }

      .student-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow: visible !important;
      }

      .info-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .info-label {
        font-size: 12px;
        color: #6b7280;
        font-weight: 600;
      }

      .info-value {
        font-size: 15px;
        color: #8ab4ff;
        font-weight: 700;
      }

      .info-column {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .info-text {
        font-size: 13px;
        color: #f3f4f6;
        word-break: break-word;
      }

      .aliases-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .alias-badge {
        font-size: 11px;
        padding: 4px 10px;
        background: rgba(138, 180, 255, 0.15);
        border: 1px solid rgba(138, 180, 255, 0.3);
        border-radius: 6px;
        color: #8ab4ff;
        font-weight: 600;
      }

      /* ========== BEGIN FLOATING NAV STYLES ========== */
      .floating-nav {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        gap: 8px;
        background: linear-gradient(135deg, rgba(30, 30, 46, 0.95), rgba(42, 42, 62, 0.95));
        backdrop-filter: blur(16px);
        border: 1px solid rgba(138, 180, 255, 0.25);
        border-radius: 20px;
        padding: 10px 14px;
        box-shadow:
          0 8px 32px rgba(0, 0, 0, 0.5),
          0 0 0 1px rgba(255, 255, 255, 0.05) inset;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .floating-nav .nav-btn {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.06);
        color: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.12);
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-size: 18px;
        font-weight: 400;
        position: relative;
      }

      .floating-nav .nav-btn:hover {
        background: linear-gradient(135deg, rgba(138, 180, 255, 0.2), rgba(168, 85, 247, 0.2));
        color: #fff;
        border-color: rgba(138, 180, 255, 0.4);
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 8px 20px rgba(138, 180, 255, 0.4);
      }

      .floating-nav .nav-btn:active {
        transform: scale(0.96);
      }

      .floating-nav .nav-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none !important;
      }

      /* Notification badge on bell icon */
      .notification-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        font-size: 9px;
        font-weight: 700;
        padding: 2px 5px;
        border-radius: 10px;
        min-width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(239, 68, 68, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.3);
        animation: pulseBadge 2s ease-in-out infinite;
      }

      @keyframes pulseBadge {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 2px 8px rgba(239, 68, 68, 0.6);
        }
        50% {
          transform: scale(1.1);
          box-shadow: 0 2px 12px rgba(239, 68, 68, 0.9);
        }
      }

      /* BEGIN CLASS COUNTDOWN TIMER */
      /* Class Countdown Overlay - Legacy (kept for backward compatibility) */
      #classCountdownOverlay {
        position: fixed;
        bottom: 80px;
        right: 20px;
        padding: 12px 16px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(30, 30, 46, 0.95), rgba(42, 42, 62, 0.95));
        backdrop-filter: blur(16px);
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        z-index: 9998;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(138, 180, 255, 0.3);
        animation: slideInUp 0.3s ease;
      }

      /* Enhanced Class Countdown Timer Panel - Liquid Glass Popup Style */
      #enhancedCountdownTimer {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 560px;
        max-height: 760px;
        padding: 0;
        border-radius: 18px;
        background: rgba(30, 30, 40, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', system-ui, sans-serif;
        font-size: 13px;
        z-index: 9999;
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.8),
          0 0 0 1px rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        user-select: none;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Time-based color tints */
      #enhancedCountdownTimer.time-safe {
        background: rgba(15, 40, 45, 0.95);
        border-color: rgba(0, 255, 160, 0.95);
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.8),
          0 0 50px rgba(0, 255, 160, 0.8),
          0 0 80px rgba(0, 255, 160, 0.4);
      }

      #enhancedCountdownTimer.time-upcoming {
        background: rgba(50, 47, 15, 0.95);
        border-color: rgba(255, 220, 50, 0.95);
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.8),
          0 0 50px rgba(255, 220, 50, 0.8),
          0 0 80px rgba(255, 220, 50, 0.4);
        transition: all 0.8s ease-in-out;
      }

      #enhancedCountdownTimer.time-warning {
        background: rgba(55, 40, 15, 0.95);
        border-color: rgba(255, 160, 50, 0.95);
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.8),
          0 0 55px rgba(255, 160, 50, 0.85),
          0 0 85px rgba(255, 160, 50, 0.5);
        transition: all 0.8s ease-in-out;
      }

      #enhancedCountdownTimer.time-critical {
        background: rgba(60, 20, 20, 0.95);
        border-color: rgba(255, 60, 60, 1);
        transition: all 1s ease-in-out;
      }

      /* Gradual blinking for critical state (<6h) */
      #enhancedCountdownTimer.time-critical.pulse-slow {
        animation: redPulseSlow 2.5s ease-in-out infinite;
      }

      #enhancedCountdownTimer.time-critical.pulse-medium {
        animation: redPulseMedium 1.5s ease-in-out infinite;
      }

      #enhancedCountdownTimer.time-critical.pulse-fast {
        animation: redPulseFast 1s ease-in-out infinite;
      }

      @keyframes redPulseSlow {
        0%,
        100% {
          border-color: rgba(255, 60, 60, 0.95);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 55px rgba(255, 60, 60, 0.8),
            0 0 90px rgba(255, 60, 60, 0.5);
        }
        50% {
          border-color: rgba(255, 60, 60, 1);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 70px rgba(255, 60, 60, 0.9),
            0 0 110px rgba(255, 60, 60, 0.6);
        }
      }

      @keyframes redPulseMedium {
        0%,
        100% {
          border-color: rgba(255, 50, 50, 0.95);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 60px rgba(255, 50, 50, 0.85),
            0 0 95px rgba(255, 50, 50, 0.55);
        }
        50% {
          border-color: rgba(255, 50, 50, 1);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 75px rgba(255, 50, 50, 0.95),
            0 0 115px rgba(255, 50, 50, 0.65);
        }
      }

      @keyframes redPulseFast {
        0%,
        100% {
          border-color: rgba(255, 40, 40, 1);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 65px rgba(255, 40, 40, 0.9),
            0 0 100px rgba(255, 40, 40, 0.6);
        }
        50% {
          border-color: rgba(255, 30, 30, 1);
          box-shadow:
            0 12px 40px rgba(0, 0, 0, 0.8),
            0 0 80px rgba(255, 30, 30, 1),
            0 0 120px rgba(255, 30, 30, 0.7);
        }
      }

      #enhancedCountdownTimer:hover {
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
        border-color: rgba(138, 180, 255, 0.4);
      }

      #enhancedCountdownTimer .timer-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 18px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
      }

      #enhancedCountdownTimer .timer-icon {
        font-size: 14px;
        margin-right: 5px;
        opacity: 0.9;
      }

      #enhancedCountdownTimer .timer-title {
        font-size: 13px;
        font-weight: 500;
        color: var(--secondary);
        opacity: 0.9;
        letter-spacing: 0.2px;
        flex: 1;
      }

      #enhancedCountdownTimer .timer-close {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.5);
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        padding: 0;
        line-height: 1;
        font-weight: 300;
      }

      #enhancedCountdownTimer .timer-close:hover {
        background: rgba(239, 68, 68, 0.12);
        border-color: rgba(239, 68, 68, 0.3);
        color: rgba(239, 68, 68, 0.9);
        transform: scale(1.05);
      }

      /* Classes List Container */
      #enhancedCountdownTimer .timer-classes-list {
        overflow-y: auto;
        max-height: 600px;
        padding: 12px;
        flex: 1;
      }

      #enhancedCountdownTimer .timer-classes-list::-webkit-scrollbar {
        width: 6px;
      }

      #enhancedCountdownTimer .timer-classes-list::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }

      #enhancedCountdownTimer .timer-classes-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      #enhancedCountdownTimer .timer-classes-list::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      #enhancedCountdownTimer .timer-no-classes {
        padding: 60px 20px;
        text-align: center;
        color: rgba(255, 255, 255, 0.6);
        font-size: 14px;
        line-height: 1.6;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 200px;
      }

      /* Individual Class Item */
      #enhancedCountdownTimer .timer-class-item {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 14px 16px;
        margin-bottom: 10px;
        transition: transform 0.2s ease;
        cursor: pointer;
        user-select: none;
        position: relative;
      }

      #enhancedCountdownTimer .timer-class-item:last-child {
        margin-bottom: 0;
      }

      #enhancedCountdownTimer .timer-class-item:hover {
        transform: translateX(-2px);
      }

      #enhancedCountdownTimer .timer-class-item:not(.skipped):active {
        transform: scale(0.98);
      }

      #enhancedCountdownTimer .timer-class-item:not(.class-critical):hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.2);
      }

      /* Next Class Highlight */
      #enhancedCountdownTimer .timer-class-item.next-class {
        background: rgba(138, 180, 255, 0.12);
        border-color: rgba(138, 180, 255, 0.3);
        box-shadow: 0 2px 8px rgba(138, 180, 255, 0.2);
      }

      /* State-based styling - Per-Class Card Tinting */
      /* >24h - Safe green tint */
      #enhancedCountdownTimer .timer-class-item.class-safe {
        border-color: rgba(0, 255, 160, 0.5);
        background: rgba(0, 255, 160, 0.22);
        box-shadow: 0 0 12px rgba(0, 255, 160, 0.3);
      }

      /* 12-24h - Yellow tint */
      #enhancedCountdownTimer .timer-class-item.class-upcoming {
        border-color: rgba(255, 220, 60, 0.55);
        background: rgba(255, 220, 60, 0.25);
        box-shadow: 0 0 14px rgba(255, 220, 60, 0.35);
      }

      /* 6-12h - Orange tint */
      #enhancedCountdownTimer .timer-class-item.class-warning {
        border-color: rgba(255, 160, 40, 0.6);
        background: rgba(255, 160, 40, 0.28);
        box-shadow: 0 0 16px rgba(255, 160, 40, 0.4);
      }

      /* <6h - Red tint with pulse animation */
      #enhancedCountdownTimer .timer-class-item.class-critical {
        border-color: rgba(255, 100, 100, 0.7);
        background: linear-gradient(135deg, rgba(80, 20, 20, 0.5), rgba(120, 30, 30, 0.4));
        background-color: rgba(200, 60, 60, 0.45) !important;
        box-shadow: 0 0 18px rgba(255, 100, 100, 0.5);
        animation: pulseRed 2s ease-in-out infinite !important;
      }

      /* Pulse animation for red (<6h) classes */
      @keyframes pulseRed {
        0%,
        100% {
          border-color: rgba(255, 100, 100, 0.7);
          box-shadow: 0 0 18px rgba(255, 80, 80, 0.5);
          transform: scale(1);
        }
        50% {
          border-color: rgba(255, 120, 120, 1);
          box-shadow:
            0 0 32px rgba(255, 80, 80, 0.8),
            0 0 16px rgba(255, 40, 40, 0.6);
          transform: scale(1.01);
        }
      }

      /* Legacy state classes for backward compatibility */
      #enhancedCountdownTimer .timer-class-item.warning {
        border-color: rgba(251, 191, 36, 0.5);
        background: rgba(251, 191, 36, 0.12);
        box-shadow: 0 0 12px rgba(251, 191, 36, 0.2);
      }

      #enhancedCountdownTimer .timer-class-item.urgent {
        border-color: rgba(239, 68, 68, 0.6);
        background: rgba(239, 68, 68, 0.15);
        box-shadow: 0 0 16px rgba(239, 68, 68, 0.25);
      }

      #enhancedCountdownTimer .timer-class-item.in-progress {
        border-color: rgba(16, 185, 129, 0.5);
        background: rgba(16, 185, 129, 0.12);
        box-shadow: 0 0 12px rgba(16, 185, 129, 0.2);
      }

      /* Class Item Header */
      #enhancedCountdownTimer .timer-class-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
      }

      #enhancedCountdownTimer .timer-class-icon {
        font-size: 12px;
        flex-shrink: 0;
      }

      #enhancedCountdownTimer .timer-class-group {
        font-size: 15px;
        font-weight: 600;
        color: #fff;
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #enhancedCountdownTimer .timer-class-countdown {
        font-size: 14px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.85);
        flex-shrink: 0;
      }

      /* Class Item Details */
      #enhancedCountdownTimer .timer-class-details {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        flex-wrap: wrap;
      }

      #enhancedCountdownTimer .timer-class-day {
        font-weight: 500;
        color: rgba(255, 255, 255, 0.7);
      }

      #enhancedCountdownTimer .timer-class-separator {
        opacity: 0.5;
      }

      #enhancedCountdownTimer .timer-class-time {
        font-size: 11px;
      }

      @keyframes scaleInFade {
        from {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.9);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      @keyframes slideInUpFade {
        from {
          opacity: 0;
          transform: translateY(25px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* SKIP CLASS FEATURE */
      #enhancedCountdownTimer .timer-class-item.skipped {
        opacity: 0.4;
        background: rgba(100, 100, 100, 0.15) !important;
        border-color: rgba(150, 150, 150, 0.3) !important;
        box-shadow: none !important;
        animation: none !important;
        text-decoration: line-through;
        pointer-events: none;
      }

      #enhancedCountdownTimer .timer-class-item.skipped .timer-class-group::before {
        content: '‚ö´ ';
        color: rgba(150, 150, 150, 0.7);
      }

      /* Skip Class Confirmation Dialog */
      #skipClassDialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(30, 30, 40, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 24px;
        min-width: 380px;
        max-width: 90%;
        box-shadow:
          0 20px 60px rgba(0, 0, 0, 0.9),
          0 0 40px rgba(138, 180, 255, 0.3);
        backdrop-filter: blur(20px);
        z-index: 100002;
        display: none;
        animation: scaleInFade 0.3s ease-out;
      }

      #skipClassDialog.show {
        display: block;
      }

      #skipClassDialog .dialog-header {
        font-size: 18px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #skipClassDialog .dialog-message {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.5;
        margin-bottom: 20px;
      }

      #skipClassDialog .dialog-class-info {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 20px;
        border-left: 3px solid rgba(255, 180, 50, 0.6);
      }

      #skipClassDialog .dialog-class-name {
        font-size: 15px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 4px;
      }

      #skipClassDialog .dialog-class-time {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
      }

      #skipClassDialog .dialog-warning {
        font-size: 13px;
        color: rgba(255, 200, 100, 0.9);
        margin-bottom: 20px;
        padding: 10px;
        background: rgba(255, 200, 100, 0.1);
        border-radius: 6px;
        border-left: 3px solid rgba(255, 200, 100, 0.5);
      }

      #skipClassDialog .dialog-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      #skipClassDialog .dialog-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      #skipClassDialog .dialog-btn-cancel {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #skipClassDialog .dialog-btn-cancel:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      #skipClassDialog .dialog-btn-confirm {
        background: rgba(255, 100, 100, 0.8);
        color: #fff;
      }

      #skipClassDialog .dialog-btn-confirm:hover {
        background: rgba(255, 100, 100, 1);
        box-shadow: 0 4px 12px rgba(255, 100, 100, 0.4);
      }

      #skipClassDialog .dialog-btn-undo {
        background: rgba(100, 200, 255, 0.8);
        color: #fff;
      }

      #skipClassDialog .dialog-btn-undo:hover {
        background: rgba(100, 200, 255, 1);
        box-shadow: 0 4px 12px rgba(100, 200, 255, 0.4);
      }

      #skipClassOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 100001;
        display: none;
      }

      #skipClassOverlay.show {
        display: block;
      }

      @keyframes slideInRight {
        from {
          opacity: 0;
          transform: translateX(400px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      /* END SKIP CLASS FEATURE */

      /* END CLASS COUNTDOWN TIMER */
      /* Responsive adjustments */
      /* Refresh animation */
      body.refreshing {
        animation: refreshPulse 0.8s ease;
      }

      @keyframes refreshPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.95;
        }
      }
      /* ========== END FLOATING NAV STYLES ========== */
    </style>
  </head>
  <body>
    <!-- Email Preview Modal -->
    <div
      id="emailPreviewModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        z-index: 100005;
        align-items: center;
        justify-content: center;
        padding: 20px;
      "
    >
      <div
        style="
          background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
          border: 2px solid rgba(165, 180, 252, 0.4);
          border-radius: 20px;
          width: 800px;
          height: 85vh;
          overflow: hidden;
          box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        "
      >
        <div
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 24px 32px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
          "
        >
          <h2
            style="
              display: flex;
              align-items: center;
              gap: 12px;
              margin: 0;
              font-size: 24px;
              font-weight: 700;
              color: #a5b4fc;
            "
          >
            <span>üëÅÔ∏è</span>
            <span>Email Preview</span>
          </h2>
          <span
            onclick="closeEmailPreviewModal()"
            style="
              font-size: 36px;
              color: rgba(255, 255, 255, 0.6);
              cursor: pointer;
              transition: all 0.2s ease;
              line-height: 1;
              width: 36px;
              height: 36px;
              display: flex;
              align-items: center;
              justify-content: center;
            "
          >
            &times;
          </span>
        </div>
        <div style="padding: 0; height: calc(100% - 81px)">
          <iframe
            id="emailPreviewFrame"
            style="width: 100%; height: 100%; border: none; border-radius: 0 0 16px 16px"
          ></iframe>
        </div>
      </div>
    </div>

    <!-- Main App Container (hidden until authenticated) -->
    <div id="mainApp" style="display: none">
      <!-- ========== CANCEL CLASS DIALOG ========== -->
      <div id="skipClassOverlay"></div>
      <div id="skipClassDialog">
        <div class="dialog-header">
          <span>‚ö†Ô∏è</span>
          <span>Cancel Class Session</span>
        </div>
        <div class="dialog-message">Are you sure you want to cancel this class for all students?</div>
        <div class="dialog-class-info">
          <div class="dialog-class-name" id="skipDialogClassName"></div>
          <div class="dialog-class-time" id="skipDialogClassTime"></div>
        </div>
        <div class="dialog-warning">‚ÑπÔ∏è Payments will automatically roll over to the next scheduled class.</div>
        <div class="dialog-actions" style="display: flex; gap: 12px; justify-content: center">
          <button
            class="dialog-btn dialog-btn-cancel"
            id="skipDialogCancelBtn"
            style="flex: 0 0 auto; min-width: 120px"
          >
            Cancel
          </button>
          <button
            class="dialog-btn"
            id="cancelClassBtn"
            onclick="window.SkipClassManager.confirmCancelClass()"
            style="
              flex: 0 0 auto;
              min-width: 180px;
              background: linear-gradient(135deg, #ef4444, #dc2626);
              border: 1px solid rgba(239, 68, 68, 0.4);
            "
          >
            üö´ Cancel Entire Class
          </button>
        </div>
      </div>
      <!-- ========== END CANCEL CLASS DIALOG ========== -->

      <!-- ========== BEGIN NOTIFICATION CENTER PANEL ========== -->
      <!-- Notification Center Overlay -->
      <div
        id="notificationCenterOverlay"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 100003;
          backdrop-filter: blur(4px);
          opacity: 0;
          transition: opacity 0.3s;
        "
        onclick="closeNotificationCenter()"
      ></div>

      <!-- Notification Center Panel -->
      <div
        id="notificationCenterPanel"
        style="
          display: none;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 700px;
          max-width: 90%;
          max-height: 80vh;
          background: rgba(30, 30, 40, 0.98);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 18px;
          backdrop-filter: blur(20px);
          box-shadow:
            0 20px 60px rgba(0, 0, 0, 0.9),
            0 0 40px rgba(138, 180, 255, 0.3);
          z-index: 100004;
          flex-direction: column;
          overflow: hidden;
          opacity: 0;
          transition: opacity 0.3s;
        "
      >
        <!-- Header -->
        <div
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
          "
        >
          <div style="display: flex; align-items: center; gap: 12px">
            <span style="font-size: 20px">üîî</span>
            <h2 style="margin: 0; font-size: 20px; font-weight: 700; color: #fff">Notifications</h2>
            <span
              id="notificationCount"
              style="font-size: 13px; color: rgba(255, 255, 255, 0.6); font-weight: 500"
            ></span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px">
            <button
              onclick="clearAllNotifications()"
              style="
                padding: 8px 14px;
                background: rgba(34, 197, 94, 0.15);
                border: 1px solid rgba(34, 197, 94, 0.3);
                border-radius: 8px;
                color: #22c55e;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(34, 197, 94, 0.25)'"
              onmouseout="this.style.background='rgba(34, 197, 94, 0.15)'"
            >
              Clear All
            </button>
            <button
              onclick="markAllNotificationsAsRead()"
              style="
                padding: 8px 14px;
                background: rgba(138, 180, 255, 0.15);
                border: 1px solid rgba(138, 180, 255, 0.3);
                border-radius: 8px;
                color: #8ab4ff;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(138, 180, 255, 0.25)'"
              onmouseout="this.style.background='rgba(138, 180, 255, 0.15)'"
            >
              Mark All Read
            </button>
            <button
              onclick="closeNotificationCenter()"
              style="
                width: 32px;
                height: 32px;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                color: rgba(255, 255, 255, 0.6);
                font-size: 20px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
                padding: 0;
              "
              onmouseover="this.style.background='rgba(239, 68, 68, 0.15)'; this.style.borderColor='rgba(239, 68, 68, 0.3)'; this.style.color='#ef4444';"
              onmouseout="this.style.background='rgba(255, 255, 255, 0.05)'; this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.color='rgba(255, 255, 255, 0.6)';"
            >
              √ó
            </button>
          </div>
        </div>

        <!-- Notifications List -->
        <div id="notificationsList" style="flex: 1; overflow-y: auto; padding: 16px 24px">
          <!-- Will be populated dynamically -->
        </div>
      </div>
      <!-- ========== END NOTIFICATION CENTER PANEL ========== -->

      <!-- ========== BEGIN FLOATING NAV HTML ========== -->
      <!-- Floating Navigation Bar -->
      <div id="floatingNav" class="floating-nav" style="display: none">
        <button id="navTopBtn" class="nav-btn" title="Scroll to Top">‚Üë</button>
        <button id="navNotificationBtn" class="nav-btn" title="Notifications" onclick="openNotificationCenter()">
          ‚óâ
          <span class="notification-badge" style="display: none"></span>
        </button>
        <button id="navEarningForecastBtn" class="nav-btn" title="Earning Forecast Overview">$</button>
        <button id="navCalendarBtn" class="nav-btn" title="Smart Payment Calendar" onclick="openSmartCalendar()">
          ‚ò∞
        </button>
        <button id="navTimerBtn" class="nav-btn" title="Class Countdown Timer">‚ó∑</button>
        <button id="navQuickViewBtn" class="nav-btn" title="Quick View ‚Äì Group Schedules">‚óà</button>
      </div>
      <!-- ========== END FLOATING NAV HTML ========== -->

      <!-- Payment Actions Popup Backdrop -->
      <div
        id="paymentActionsBackdrop"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.75);
          z-index: 9999;
          backdrop-filter: blur(6px);
        "
        onclick="closePaymentActionsPopup()"
      ></div>

      <!-- Payment Actions Popup Modal -->
      <div
        id="paymentActionsPopup"
        style="
          display: none;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
          border: 2px solid rgba(138, 180, 255, 0.3);
          border-radius: 16px;
          padding: 24px;
          min-width: 400px;
          max-width: 500px;
          max-height: 85vh;
          overflow-y: auto;
          backdrop-filter: blur(20px);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
          z-index: 10000;
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: sticky;
            top: -24px;
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            padding: 0 0 12px 0;
            z-index: 1;
          "
        >
          <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 700">Payment Actions</h3>
          <button
            onclick="closePaymentActionsPopup()"
            style="
              background: none;
              border: none;
              color: white;
              font-size: 24px;
              cursor: pointer;
              padding: 0;
              width: 30px;
              height: 30px;
              display: flex;
              align-items: center;
              justify-content: center;
              opacity: 0.7;
              transition: opacity 0.2s;
            "
            onmouseover="this.style.opacity='1'"
            onmouseout="this.style.opacity='0.7'"
          >
            &times;
          </button>
        </div>

        <div
          style="
            margin-bottom: 20px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
          "
        >
          <div style="margin-bottom: 8px">
            <strong style="color: white">Payer:</strong>
            <span id="popupPayerName" style="color: #94a3b8">‚Äî</span>
          </div>
          <div style="margin-bottom: 8px">
            <strong style="color: white">Amount:</strong>
            <span id="popupPaymentAmount" style="color: #22c55e">‚Äî</span>
          </div>
          <div>
            <strong style="color: white">Message:</strong>
            <span id="popupPaymentMessage" style="color: #94a3b8">‚Äî</span>
          </div>
        </div>

        <div style="display: flex; flex-direction: column; gap: 10px">
          <button
            onclick="showCreateAliasForm()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #22c55e;
              border-radius: 12px;
              color: #22c55e;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(34,197,94,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            Create Payer Alias
          </button>
          <button
            onclick="showChangeDateForm()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #3b82f6;
              border-radius: 12px;
              color: #3b82f6;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(59,130,246,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            Change Email Date
          </button>
          <button
            onclick="deleteThisPayment()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #dc2626;
              border-radius: 12px;
              color: #dc2626;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(220,38,38,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            üóëÔ∏è Delete This Payment
          </button>
          <button
            onclick="ignoreThisPayment()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #f59e0b;
              border-radius: 12px;
              color: #f59e0b;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(245,158,11,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            Ignore This Payment
          </button>
          <button
            onclick="ignoreAllFromPayer()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #ef4444;
              border-radius: 12px;
              color: #ef4444;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(239,68,68,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            Ignore All From Payer
          </button>
          <button
            onclick="linkPaymentToStudent()"
            style="
              width: 100%;
              padding: 14px;
              background: transparent;
              border: 2px solid #8b5cf6;
              border-radius: 12px;
              color: #8b5cf6;
              font-weight: 600;
              font-size: 14px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='rgba(139,92,246,0.1)'"
            onmouseout="this.style.background='transparent'"
          >
            üë§ Link to Student
          </button>
        </div>

        <!-- Create Alias Form (hidden by default) -->
        <div
          id="createAliasForm"
          style="
            display: none;
            margin-top: 20px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
          "
        >
          <h4 style="margin: 0 0 12px 0; color: white; font-size: 14px">Create Payer Alias</h4>
          <input
            type="text"
            id="aliasStudentName"
            placeholder="Student name..."
            style="
              width: 100%;
              padding: 10px;
              background: rgba(255, 255, 255, 0.1);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 6px;
              color: white;
              margin-bottom: 12px;
            "
            onkeydown="if(event.key==='Enter'){saveAlias();}"
          />
          <div style="display: flex; gap: 8px">
            <button
              onclick="saveAlias()"
              style="
                flex: 1;
                padding: 10px;
                background: #22c55e;
                border: none;
                border-radius: 6px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Save
            </button>
            <button
              onclick="hideCreateAliasForm()"
              style="
                flex: 1;
                padding: 10px;
                background: rgba(255, 255, 255, 0.1);
                border: none;
                border-radius: 6px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Cancel
            </button>
          </div>
        </div>

        <!-- Change Date Form (hidden by default) -->
        <div
          id="changeDateForm"
          style="
            display: none;
            margin-top: 20px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
          "
        >
          <h4 style="margin: 0 0 12px 0; color: white; font-size: 14px">Change Email Date</h4>
          <input
            type="date"
            id="newEmailDate"
            style="
              width: 100%;
              padding: 10px;
              background: rgba(255, 255, 255, 0.1);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 6px;
              color: white;
              margin-bottom: 12px;
            "
            onkeydown="if(event.key==='Enter'){saveNewDate();}"
          />
          <div style="display: flex; gap: 8px">
            <button
              onclick="saveNewDate()"
              style="
                flex: 1;
                padding: 10px;
                background: #3b82f6;
                border: none;
                border-radius: 6px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Save
            </button>
            <button
              onclick="hideChangeDateForm()"
              style="
                flex: 1;
                padding: 10px;
                background: rgba(255, 255, 255, 0.1);
                border: none;
                border-radius: 6px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- Full Sync Date Range Modal -->
      <div
        id="fullSyncModal"
        style="
          display: none;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(145deg, rgba(20, 20, 30, 0.98), rgba(30, 30, 45, 0.98));
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 16px;
          padding: 32px;
          min-width: 500px;
          backdrop-filter: blur(20px);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
          z-index: 10001;
        "
      >
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px">
          <h3 style="margin: 0; color: white; font-size: 20px; font-weight: 700">Full Payment Sync</h3>
          <button
            onclick="closeFullSyncDatePicker()"
            style="
              background: none;
              border: none;
              color: white;
              font-size: 28px;
              cursor: pointer;
              padding: 0;
              width: 32px;
              height: 32px;
              display: flex;
              align-items: center;
              justify-content: center;
              opacity: 0.9;
            "
          >
            &times;
          </button>
        </div>

        <div
          style="
            margin-bottom: 24px;
            padding: 16px;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.1), rgba(192, 57, 43, 0.05));
            border-left: 4px solid #e74c3c;
            border-radius: 8px;
          "
        >
          <div style="font-weight: 700; color: white; margin-bottom: 6px; font-size: 14px">
            Complete Historical Sync
          </div>
          <div style="font-size: 13px; color: #94a3b8; line-height: 1.6">
            Fetches ALL Zelle payment emails from your Gmail within the specified date range. All payments will be saved
            automatically to Supabase.
          </div>
        </div>

        <div style="margin-bottom: 16px; display: flex; gap: 8px">
          <button
            onclick="setFullSyncThisWeek()"
            style="
              flex: 1;
              padding: 10px;
              background: rgba(59, 130, 246, 0.15);
              border: 1px solid rgba(59, 130, 246, 0.3);
              border-radius: 8px;
              color: #60a5fa;
              font-weight: 600;
              cursor: pointer;
              font-size: 13px;
            "
          >
            This Week
          </button>
          <button
            onclick="setFullSyncThisMonth()"
            style="
              flex: 1;
              padding: 10px;
              background: rgba(59, 130, 246, 0.15);
              border: 1px solid rgba(59, 130, 246, 0.3);
              border-radius: 8px;
              color: #60a5fa;
              font-weight: 600;
              cursor: pointer;
              font-size: 13px;
            "
          >
            This Month
          </button>
          <button
            onclick="setFullSyncLastMonth()"
            style="
              flex: 1;
              padding: 10px;
              background: rgba(59, 130, 246, 0.15);
              border: 1px solid rgba(59, 130, 246, 0.3);
              border-radius: 8px;
              color: #60a5fa;
              font-weight: 600;
              cursor: pointer;
              font-size: 13px;
            "
          >
            Last Month
          </button>
        </div>

        <div style="margin-bottom: 20px">
          <label style="display: block; font-weight: 600; color: white; margin-bottom: 8px; font-size: 14px">
            From Date *
          </label>
          <input
            type="date"
            id="fullSyncFromDate"
            value="2024-07-01"
            style="
              width: 100%;
              padding: 14px 16px;
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 10px;
              color: white;
              font-size: 14px;
            "
          />
        </div>

        <div style="margin-bottom: 24px">
          <label style="display: block; font-weight: 600; color: white; margin-bottom: 8px; font-size: 14px">
            To Date *
          </label>
          <input
            type="date"
            id="fullSyncToDate"
            style="
              width: 100%;
              padding: 14px 16px;
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 10px;
              color: white;
              font-size: 14px;
            "
          />
        </div>

        <div style="display: flex; gap: 12px">
          <button
            onclick="closeFullSyncDatePicker()"
            style="
              flex: 1;
              padding: 14px;
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 10px;
              color: white;
              font-weight: 600;
              cursor: pointer;
            "
          >
            Cancel
          </button>
          <button
            onclick="performFullSync()"
            style="
              flex: 2;
              padding: 14px;
              background: linear-gradient(135deg, #22c55e, #16a34a);
              border: none;
              border-radius: 10px;
              color: white;
              font-weight: 600;
              cursor: pointer;
            "
          >
            Start Full Sync
          </button>
        </div>
      </div>

      <!-- ============================== -->
      <!-- üß± STUDENT MANAGER MODULE -->
      <!-- ============================== -->
      <div
        id="studentManagerModal"
        onclick="closeStudentManagerOnOutsideClick(event)"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.6);
          z-index: 20000;
          backdrop-filter: blur(4px);
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1400px;
            max-height: 90vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.8);
          "
        >
          <!-- Header -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              padding: 20px 24px;
            "
          >
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px">
              <h1
                style="
                  margin: 0;
                  background: linear-gradient(135deg, #8ab4ff, #a855f7);
                  -webkit-background-clip: text;
                  background-clip: text;
                  -webkit-text-fill-color: transparent;
                  font-size: 28px;
                  font-weight: 900;
                "
              >
                üë©‚Äç‚öïÔ∏è Student Manager
              </h1>
              <div style="display: flex; gap: 12px; align-items: center">
                <button
                  onclick="openAddStudent()"
                  style="
                    padding: 10px 18px;
                    background: linear-gradient(135deg, #22c55e, #16a34a);
                    border: none;
                    border-radius: 10px;
                    color: white;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
                  "
                >
                  + Add Student
                </button>
                <!-- BEGIN BULK ADD STUDENTS FEATURE -->
                <button
                  onclick="openBulkAddStudents()"
                  style="
                    padding: 10px 18px;
                    background: linear-gradient(135deg, #3b82f6, #2563eb);
                    border: none;
                    border-radius: 10px;
                    color: white;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                  "
                >
                  üìã Bulk Add
                </button>
                <!-- END BULK ADD STUDENTS FEATURE -->
                <button
                  onclick="openWaitingList()"
                  style="
                    padding: 10px 18px;
                    background: rgba(168, 85, 247, 0.2);
                    border: 2px solid #a855f7;
                    color: #a855f7;
                    border-radius: 10px;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                  "
                >
                  Waiting List
                </button>
                <button
                  onclick="findDuplicates()"
                  style="
                    padding: 10px 18px;
                    background: rgba(251, 146, 60, 0.2);
                    border: 2px solid #fb923c;
                    color: #fb923c;
                    border-radius: 10px;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                  "
                >
                  Find Duplicates
                </button>
                <button
                  id="syncCloudBtn"
                  onclick="syncWithCloud()"
                  style="
                    padding: 10px 18px;
                    background: rgba(255, 255, 255, 0.08);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 10px;
                    color: white;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                  "
                >
                  ‚òÅÔ∏è Sync Cloud
                </button>
                <button
                  onclick="closeStudentManager()"
                  style="
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    color: white;
                    font-size: 24px;
                    cursor: pointer;
                  "
                >
                  &times;
                </button>
              </div>
            </div>

            <!-- Filter Controls -->
            <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center">
              <input
                type="text"
                id="studentSearchInput"
                placeholder="üîç Search by name, group, phone, email, notes..."
                oninput="debouncedFilterStudents()"
                style="
                  flex: 1;
                  min-width: 250px;
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                "
              />

              <select
                id="filterGroup"
                onchange="filterStudents()"
                style="
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 600;
                  min-width: 150px;
                "
              >
                <option value="">All Groups</option>
                <option value="no-group">No Group</option>
              </select>

              <select
                id="filterStatus"
                onchange="filterStudents()"
                style="
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 600;
                  min-width: 150px;
                "
              >
                <option value="">All Statuses</option>
                <option value="active">Active</option>
                <option value="paused">Paused</option>
                <option value="graduated">Graduated</option>
              </select>

              <select
                id="filterPayment"
                onchange="filterStudents()"
                style="
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 600;
                  min-width: 150px;
                "
              >
                <option value="">All Payment Status</option>
                <option value="unpaid">Unpaid Classes</option>
                <option value="credit">Has Credit Balance</option>
              </select>

              <select
                id="sortPrice"
                onchange="filterStudents()"
                style="
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 600;
                  min-width: 150px;
                "
              >
                <option value="">Sort by Price</option>
                <option value="highest">Price: Highest First</option>
                <option value="lowest">Price: Lowest First</option>
              </select>

              <button
                onclick="clearFilters()"
                style="
                  padding: 10px 16px;
                  background: rgba(255, 255, 255, 0.08);
                  border: 1px solid rgba(255, 255, 255, 0.2);
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 600;
                  cursor: pointer;
                "
              >
                Clear Filters
              </button>
            </div>
          </div>

          <!-- Students Grid -->
          <div
            id="studentGrid"
            style="
              padding: 24px;
              overflow-y: auto;
              max-height: calc(90vh - 200px);
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
              gap: 20px;
            "
          ></div>
        </div>
      </div>

      <!-- Add/Edit Student Modal -->
      <div
        id="studentModal"
        onclick="if(event.target.id==='studentModal'){closeStudentModal();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 25000;
          backdrop-filter: blur(4px);
          align-items: center;
          justify-content: center;
          padding: 20px;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
          "
        >
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
            <h2 id="modalTitle" style="margin: 0; font-size: 24px; color: var(--primary)">Add New Student</h2>
            <span
              onclick="closeStudentModal()"
              style="font-size: 28px; color: #6b7280; cursor: pointer; transition: all 0.2s"
            >
              &times;
            </span>
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Student Name *
            </label>
            <input
              type="text"
              id="studentName"
              placeholder="Enter full name"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Group(s)
            </label>
            <div id="groupBtns" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px">
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'A')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                A
              </button>
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'B')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                B
              </button>
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'C')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                C
              </button>
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'D')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                D
              </button>
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'E')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                E
              </button>
              <button
                class="group-select-btn"
                onclick="toggleGroup(this, 'F')"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                F
              </button>
            </div>
            <input
              type="text"
              id="customGroups"
              placeholder="Or enter custom groups (comma-separated, optional)"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Pay Per Class
            </label>
            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px">
              <button
                class="pay-select-btn"
                onclick="selectPayAmount(this, 25)"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                $25
              </button>
              <button
                class="pay-select-btn"
                onclick="selectPayAmount(this, 50)"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                $50
              </button>
              <button
                class="pay-select-btn"
                onclick="selectPayAmount(this, 75)"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                $75
              </button>
              <button
                class="pay-select-btn"
                onclick="selectPayAmount(this, 100)"
                style="
                  padding: 8px 16px;
                  background: rgba(255, 255, 255, 0.05);
                  color: #6b7280;
                  border: 2px solid rgba(255, 255, 255, 0.2);
                  border-radius: 8px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  font-size: 14px;
                "
              >
                $100
              </button>
            </div>
            <input
              type="number"
              id="studentPay"
              placeholder="Or enter custom amount"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #eab308; font-size: 14px">
              üí∞ Credit Balance
            </label>
            <div style="margin-bottom: 8px; font-size: 12px; color: #94a3b8; line-height: 1.4">
              Credit will auto-apply to upcoming classes until it reaches $0
            </div>
            <div style="position: relative">
              <span
                style="
                  position: absolute;
                  left: 12px;
                  top: 50%;
                  transform: translateY(-50%);
                  color: #eab308;
                  font-weight: 700;
                  font-size: 16px;
                "
              >
                $
              </span>
              <input
                type="number"
                id="studentBalance"
                placeholder="0.00"
                step="0.01"
                min="0"
                style="
                  width: 100%;
                  padding: 12px 12px 12px 32px;
                  background: rgba(234, 179, 8, 0.1);
                  border: 2px solid rgba(234, 179, 8, 0.3);
                  border-radius: 8px;
                  color: #eab308;
                  font-size: 16px;
                  font-weight: 700;
                "
                onkeydown="if(event.key==='Enter'){saveStudent();}"
              />
            </div>
            <div id="currentBalanceDisplay" style="margin-top: 8px; font-size: 11px; color: #6b7280"></div>
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Phone
            </label>
            <input
              type="tel"
              id="studentPhone"
              placeholder="(555) 123-4567"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Email(s)
              <span style="color: #94a3b8; font-weight: 400; font-size: 12px">(comma-separated for multiple)</span>
            </label>
            <input
              type="text"
              id="studentEmail"
              placeholder="email1@example.com, email2@example.com"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
            <div style="color: #94a3b8; font-size: 11px; margin-top: 4px">
              üí° You can add multiple emails separated by commas. All emails will receive notifications.
            </div>
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Aliases (comma-separated)
            </label>
            <input
              type="text"
              id="studentAliases"
              placeholder="Nick, Nickname"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Notes
            </label>
            <textarea
              id="studentNotes"
              placeholder="Additional notes..."
              style="
                width: 100%;
                min-height: 100px;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
                resize: vertical;
              "
            ></textarea>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 24px">
            <button
              onclick="saveStudentFromModal()"
              style="
                flex: 1;
                padding: 12px;
                background: linear-gradient(135deg, #22c55e, #16a34a);
                border: none;
                border-radius: 10px;
                color: white;
                font-weight: 700;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
              "
            >
              Save Student
            </button>
            <button
              onclick="closeStudentModal()"
              style="
                flex: 1;
                padding: 12px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 10px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- BEGIN BULK ADD STUDENTS FEATURE -->
      <!-- Bulk Add Students Modal -->
      <div
        id="bulkAddStudentsModal"
        onclick="if(event.target.id==='bulkAddStudentsModal'){closeBulkAddStudents();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 25000;
          backdrop-filter: blur(4px);
          align-items: center;
          justify-content: center;
          padding: 20px;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 18px;
            padding: 30px;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
          "
        >
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
            <h2
              style="
                margin: 0;
                font-size: 24px;
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 900;
              "
            >
              üìã Bulk Add Students ‚Äî Paste or Type Below
            </h2>
            <span
              onclick="closeBulkAddStudents()"
              style="font-size: 28px; color: #6b7280; cursor: pointer; transition: color 0.2s"
              onmouseover="this.style.color='white'"
              onmouseout="this.style.color='#6b7280'"
            >
              &times;
            </span>
          </div>

          <div
            style="
              margin-bottom: 16px;
              padding: 12px;
              background: rgba(59, 130, 246, 0.1);
              border: 1px solid rgba(59, 130, 246, 0.3);
              border-radius: 8px;
              color: #94a3b8;
              font-size: 13px;
              line-height: 1.6;
            "
          >
            <strong style="color: #3b82f6">Flexible Format:</strong>
            One student per line ‚Äî comma-separated or labeled
            <br />
            <code
              style="
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 4px;
                color: #e5e7eb;
                font-size: 12px;
              "
            >
              Name, Email, Phone, Group, $Amount
            </code>
            <br />
            <code
              style="
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 4px;
                color: #e5e7eb;
                font-size: 12px;
              "
            >
              Name (Alias), Email, Phone, Group, $Amount
            </code>
          </div>

          <div
            style="
              margin-bottom: 12px;
              padding: 10px;
              background: rgba(255, 255, 255, 0.03);
              border-radius: 6px;
              color: #6b7280;
              font-size: 12px;
            "
          >
            <strong style="color: #94a3b8">Examples:</strong>
            <br />
            <span style="font-family: monospace; color: #8ab4ff">
              Hasmik Antonova (Level Up), Hasmik.Antonova@gmail.com, 909-555-4321, A, $100
            </span>
            <br />
            <span style="font-family: monospace; color: #8ab4ff">
              Varduni Nerseyan, Varduni1982@yahoo.com, (818)299-7867, E, $100
            </span>
          </div>

          <textarea
            id="bulkStudentInput"
            placeholder="Paste student records here (one per line)..."
            style="
              width: 100%;
              min-height: 250px;
              padding: 14px;
              background: rgba(255, 255, 255, 0.05);
              backdrop-filter: blur(10px);
              border: 2px solid rgba(255, 255, 255, 0.15);
              border-radius: 10px;
              color: white;
              font-size: 13px;
              font-family: monospace;
              resize: vertical;
              line-height: 1.8;
            "
          ></textarea>

          <div
            id="bulkAddValidationMessage"
            style="margin-top: 12px; padding: 10px; border-radius: 8px; display: none"
          ></div>

          <div style="display: flex; gap: 12px; margin-top: 20px">
            <button
              onclick="processBulkAddStudents()"
              style="
                flex: 1;
                padding: 14px;
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                border: none;
                border-radius: 10px;
                color: white;
                font-weight: 700;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                transition: all 0.2s;
              "
              onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 16px rgba(59, 130, 246, 0.4)'"
              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.3)'"
            >
              Add Students
            </button>
            <button
              onclick="closeBulkAddStudents()"
              style="
                flex: 1;
                padding: 14px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 10px;
                color: white;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(255,255,255,0.12)'"
              onmouseout="this.style.background='rgba(255,255,255,0.08)'"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
      <!-- END BULK ADD STUDENTS FEATURE -->

      <!-- Waiting List Modal -->
      <div
        id="waitingListModal"
        onclick="if(event.target.id==='waitingListModal'){closeWaitingList();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 25000;
          backdrop-filter: blur(4px);
          align-items: center;
          justify-content: center;
          padding: 20px;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 1000px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
          "
        >
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
            <h2 style="margin: 0; font-size: 24px; color: var(--primary)">Student Waiting List</h2>
            <span onclick="closeWaitingList()" style="font-size: 28px; color: #6b7280; cursor: pointer">&times;</span>
          </div>
          <button
            onclick="openAddWaitingList()"
            style="
              margin-bottom: 20px;
              width: 100%;
              padding: 12px;
              background: linear-gradient(135deg, #22c55e, #16a34a);
              border: none;
              border-radius: 10px;
              color: white;
              font-weight: 700;
              cursor: pointer;
            "
          >
            + Add to Waiting List
          </button>
          <div
            id="waitingListContent"
            style="display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 20px"
          ></div>
        </div>
      </div>

      <!-- Add Waiting List Student Modal -->
      <div
        id="addWaitingListModal"
        onclick="if(event.target.id==='addWaitingListModal'){closeAddWaitingList();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 26000;
          backdrop-filter: blur(4px);
          align-items: center;
          justify-content: center;
          padding: 20px;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
          "
        >
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
            <h2 style="margin: 0; font-size: 24px; color: var(--primary)">Add to Waiting List</h2>
            <span onclick="closeAddWaitingList()" style="font-size: 28px; color: #6b7280; cursor: pointer">
              &times;
            </span>
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Full Name *
            </label>
            <input
              type="text"
              id="waitingListFullName"
              placeholder="Enter full name"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveWaitingListStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Email *
            </label>
            <input
              type="email"
              id="waitingListEmail"
              placeholder="Enter email address"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveWaitingListStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Phone Number *
            </label>
            <input
              type="tel"
              id="waitingListPhone"
              placeholder="Enter phone number"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveWaitingListStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Preferred Language
            </label>
            <input
              type="text"
              id="waitingListLanguage"
              placeholder="e.g., English, Spanish, Armenian"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveWaitingListStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Preferred Start Date
            </label>
            <input
              type="date"
              id="waitingListStartDate"
              style="
                width: 100%;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
              "
              onkeydown="if(event.key==='Enter'){saveWaitingListStudent();}"
            />
          </div>

          <div style="margin-bottom: 20px">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #f3f4f6; font-size: 14px">
              Notes
            </label>
            <textarea
              id="waitingListNotes"
              placeholder="Any additional information..."
              style="
                width: 100%;
                min-height: 100px;
                padding: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #f3f4f6;
                font-size: 14px;
                resize: vertical;
              "
            ></textarea>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 24px">
            <button
              onclick="saveWaitingListStudent()"
              style="
                flex: 1;
                padding: 12px;
                background: linear-gradient(135deg, #22c55e, #16a34a);
                border: none;
                border-radius: 10px;
                color: white;
                font-weight: 700;
                cursor: pointer;
              "
            >
              Add to List
            </button>
            <button
              onclick="closeAddWaitingList()"
              style="
                flex: 1;
                padding: 12px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 10px;
                color: white;
                font-weight: 600;
                cursor: pointer;
              "
            >
              Cancel
            </button>
          </div>
        </div>
      </div>

      <!-- Duplicate Students Modal -->
      <div
        id="duplicatesModal"
        onclick="if(event.target.id==='duplicatesModal'){closeDuplicatesModal();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 25000;
          backdrop-filter: blur(4px);
          align-items: center;
          justify-content: center;
          padding: 20px;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
          "
        >
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
            <h2 style="margin: 0; font-size: 24px; color: var(--primary)">Duplicate Students</h2>
            <span onclick="closeDuplicatesModal()" style="font-size: 28px; color: #6b7280; cursor: pointer">
              &times;
            </span>
          </div>
          <div id="duplicatesContent"></div>
        </div>
      </div>

      <!-- Group Manager Modal -->
      <div
        id="groupManagerModal"
        onclick="closeGroupManagerOnOutsideClick(event)"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.6);
          z-index: 20000;
          backdrop-filter: blur(4px);
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.8);
          "
        >
          <!-- Header -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              padding: 20px 24px;
              display: flex;
              align-items: center;
              justify-content: space-between;
            "
          >
            <h1
              style="
                margin: 0;
                background: linear-gradient(135deg, #8ab4ff, #a855f7);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
                font-size: 28px;
                font-weight: 900;
              "
            >
              üìö Group Manager
            </h1>
            <div style="display: flex; gap: 12px; align-items: center">
              <!-- BEGIN QUICK VIEW BUTTON -->
              <button
                id="quickViewBtn"
                onclick="openQuickView()"
                style="
                  padding: 10px 18px;
                  background: linear-gradient(135deg, #10b981, #059669);
                  border: none;
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 700;
                  cursor: pointer;
                  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                "
              >
                üìÖ Quick View
              </button>
              <!-- END QUICK VIEW BUTTON -->
              <button
                id="addGroupBtn"
                onclick="addNewGroup()"
                style="
                  padding: 10px 18px;
                  background: linear-gradient(135deg, #8ab4ff, #a855f7);
                  border: none;
                  border-radius: 10px;
                  color: white;
                  font-size: 14px;
                  font-weight: 700;
                  cursor: pointer;
                  box-shadow: 0 4px 12px rgba(138, 180, 255, 0.3);
                "
              >
                + Add Group
              </button>
              <button
                onclick="closeGroupManager()"
                style="
                  background: rgba(255, 255, 255, 0.1);
                  border: 1px solid rgba(255, 255, 255, 0.2);
                  width: 36px;
                  height: 36px;
                  border-radius: 50%;
                  color: white;
                  font-size: 24px;
                  cursor: pointer;
                "
              >
                &times;
              </button>
            </div>
          </div>

          <!-- Groups Grid -->
          <div
            id="groupGrid"
            style="
              padding: 24px;
              overflow-y: auto;
              max-height: calc(90vh - 90px);
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
              gap: 20px;
            "
          ></div>
        </div>
      </div>

      <!-- Toast Notification -->
      <div
        id="toast"
        style="
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #8ab4ff, #a855f7);
          color: white;
          padding: 10px 16px;
          border-radius: 10px;
          font-weight: 700;
          box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
          opacity: 0;
          pointer-events: none;
          transition: 0.3s;
          z-index: 30000;
        "
      ></div>

      <!-- Countdown Panel -->
      <div
        id="countdownPanel"
        style="
          display: none;
          position: fixed;
          background: rgba(17, 24, 39, 0.95);
          backdrop-filter: blur(20px);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 14px;
          padding: 12px 16px;
          font-size: 0.9rem;
          color: white;
          z-index: 25000;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
        "
      ></div>

      <!-- Custom Confirm Dialog -->
      <div
        id="customConfirmModal"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.75);
          z-index: 30000;
          backdrop-filter: blur(6px);
          align-items: center;
          justify-content: center;
          flex-direction: column;
        "
      >
        <div
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 32px;
            max-width: 480px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: modalSlideIn 0.2s ease-out;
          "
        >
          <div style="text-align: center; margin-bottom: 24px">
            <div id="confirmIcon" style="font-size: 48px; margin-bottom: 16px">‚ö†Ô∏è</div>
            <h3 id="confirmTitle" style="margin: 0 0 12px 0; font-size: 20px; font-weight: 700; color: white">
              Confirm Action
            </h3>
            <p
              id="confirmMessage"
              style="margin: 0; color: #94a3b8; font-size: 15px; line-height: 1.6; white-space: pre-line"
            ></p>
          </div>
          <div style="display: flex; gap: 12px">
            <button
              id="confirmCancelBtn"
              style="
                flex: 1;
                padding: 14px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: white;
                font-weight: 600;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
              "
            >
              Cancel
            </button>
            <button
              id="confirmOkBtn"
              style="
                flex: 1;
                padding: 14px;
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                border: none;
                border-radius: 10px;
                color: white;
                font-weight: 700;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
              "
            >
              Confirm
            </button>
          </div>
        </div>
      </div>

      <!-- Custom Alert Dialog -->
      <div
        id="customAlertModal"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.75);
          z-index: 30000;
          backdrop-filter: blur(6px);
          align-items: center;
          justify-content: center;
          flex-direction: column;
        "
      >
        <div
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 32px;
            max-width: 420px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: modalSlideIn 0.2s ease-out;
          "
        >
          <div style="text-align: center; margin-bottom: 24px">
            <div id="alertIcon" style="font-size: 48px; margin-bottom: 16px">‚ÑπÔ∏è</div>
            <h3 id="alertTitle" style="margin: 0 0 12px 0; font-size: 20px; font-weight: 700; color: white">Notice</h3>
            <p
              id="alertMessage"
              style="margin: 0; color: #94a3b8; font-size: 15px; line-height: 1.6; white-space: pre-line"
            ></p>
          </div>
          <button
            id="alertOkBtn"
            style="
              width: 100%;
              padding: 14px;
              background: linear-gradient(135deg, #22c55e, #16a34a);
              border: none;
              border-radius: 10px;
              color: white;
              font-weight: 700;
              cursor: pointer;
              font-size: 14px;
              transition: all 0.2s;
              box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            "
          >
            OK
          </button>
        </div>
      </div>

      <!-- Custom Prompt Dialog -->
      <div
        id="customPromptModal"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.75);
          z-index: 30000;
          backdrop-filter: blur(6px);
          align-items: center;
          justify-content: center;
          flex-direction: column;
        "
      >
        <div
          style="
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 16px;
            padding: 32px;
            max-width: 460px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: modalSlideIn 0.2s ease-out;
          "
        >
          <div style="margin-bottom: 24px">
            <div style="text-align: center; font-size: 42px; margin-bottom: 16px">‚úèÔ∏è</div>
            <h3
              id="promptTitle"
              style="margin: 0 0 12px 0; font-size: 20px; font-weight: 700; color: white; text-align: center"
            >
              Input Required
            </h3>
            <p
              id="promptMessage"
              style="
                margin: 0 0 16px 0;
                color: #94a3b8;
                font-size: 14px;
                line-height: 1.6;
                text-align: center;
                white-space: pre-line;
              "
            ></p>
            <input
              type="text"
              id="promptInput"
              style="
                width: 100%;
                padding: 14px 16px;
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: white;
                font-size: 15px;
                transition: all 0.2s;
              "
              placeholder="Enter value..."
            />
          </div>
          <div style="display: flex; gap: 12px">
            <button
              id="promptCancelBtn"
              style="
                flex: 1;
                padding: 14px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: white;
                font-weight: 600;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
              "
            >
              Cancel
            </button>
            <button
              id="promptOkBtn"
              style="
                flex: 1;
                padding: 14px;
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                border: none;
                border-radius: 10px;
                color: white;
                font-weight: 700;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
              "
            >
              Submit
            </button>
          </div>
        </div>
      </div>

      <!-- BEGIN QUICK VIEW MODAL -->
      <div
        id="quickViewModal"
        onclick="if(event.target.id==='quickViewModal')closeQuickView()"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 21000;
          backdrop-filter: blur(6px);
          align-items: center;
          justify-content: center;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1100px;
            max-height: 80vh;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
          "
        >
          <!-- Header -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              padding: 20px 24px;
              display: flex;
              align-items: center;
              justify-content: space-between;
              flex-shrink: 0;
            "
          >
            <h1
              style="
                margin: 0;
                background: linear-gradient(135deg, #10b981, #059669);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
                font-size: 26px;
                font-weight: 900;
              "
            >
              üìÖ Quick View ‚Äî Group Schedules
            </h1>
            <button
              onclick="closeQuickView()"
              style="
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                width: 36px;
                height: 36px;
                border-radius: 50%;
                color: white;
                font-size: 24px;
                cursor: pointer;
                flex-shrink: 0;
              "
            >
              &times;
            </button>
          </div>

          <!-- Tabs -->
          <div
            style="
              background: rgba(255, 255, 255, 0.03);
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              padding: 16px 24px;
              display: flex;
              gap: 12px;
              flex-shrink: 0;
            "
          >
            <button
              id="tabByGroup"
              onclick="switchQuickViewTab('byGroup')"
              style="
                padding: 10px 20px;
                background: linear-gradient(135deg, #8ab4ff, #a855f7);
                border: none;
                border-radius: 10px;
                color: white;
                font-size: 14px;
                font-weight: 700;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(138, 180, 255, 0.3);
                transition: all 0.2s;
              "
            >
              By Group
            </button>
            <button
              id="tabByWeekday"
              onclick="switchQuickViewTab('byWeekday')"
              style="
                padding: 10px 20px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: rgba(255, 255, 255, 0.7);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              "
            >
              By Weekday (LA)
            </button>
            <button
              id="tabByWeekdayYerevan"
              onclick="switchQuickViewTab('byWeekdayYerevan')"
              style="
                padding: 10px 20px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: rgba(255, 255, 255, 0.7);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              "
            >
              By Weekday (Yerevan)
            </button>
          </div>

          <!-- Content -->
          <div id="quickViewContent" style="padding: 24px; overflow-y: auto; flex: 1"></div>
        </div>
      </div>
      <!-- END QUICK VIEW MODAL -->

      <!-- Hidden File Input for Backup Import -->
      <input type="file" id="backupFileInput" accept=".json" style="display: none" />

      <div class="container">
        <div class="header">
          <h1>
            Payment Records
            <span style="font-size: 14px; color: rgba(255, 255, 255, 0.7); font-weight: 500">
              üîÑ ARNOMA v2.9.1 - Gmail OAuth Auto-Refresh üîÑ
            </span>
          </h1>
          <select id="paymentFilterDropdown" class="filter-dropdown">
            <option value="all">All Payments</option>
            <option value="matched">Matched Only</option>
            <option value="unmatched">Unmatched Only</option>
            <option value="ignored">Ignored</option>
          </select>
          <div class="header-controls">
            <button
              id="fullSyncBtn"
              class="gmail-btn"
              onclick="openFullSyncDatePicker()"
              title="Full sync - choose date range to fetch all payments"
            >
              <span id="fullSyncBtnText">Full Sync</span>
            </button>
            <button id="gmailBtn" class="gmail-btn" onclick="toggleGmailConnection()">
              <span id="gmailBtnText">Gmail</span>
            </button>
            <button
              id="autoRefreshToggle"
              class="control-btn"
              onclick="toggleAutoRefresh()"
              title="Toggle 30-second auto-refresh (currently OFF)"
              style="font-size: 11px; font-weight: 700"
            >
              30s
            </button>
            <button
              id="earningsForecastBtn"
              class="control-btn"
              onclick="openEarningsForecast()"
              title="Earning Forecast"
            >
              $
            </button>
            <button id="syncBtn" class="control-btn" onclick="fetchTodaysEmails()" title="Fetch Today's Payment Emails">
              ‚òÅÔ∏è
            </button>
            <button id="calendarBtn" class="control-btn" onclick="openSmartCalendar()" title="Smart Payment Calendar">
              üìÖ
            </button>
            <div style="position: relative">
              <button id="settingsBtn" class="control-btn" onclick="toggleSettingsMenu()" title="Settings">‚öôÔ∏è</button>
              <div
                id="settingsMenu"
                style="
                  display: none;
                  position: absolute;
                  top: 44px;
                  right: 0;
                  background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
                  border: 2px solid rgba(138, 180, 255, 0.3);
                  border-radius: 12px;
                  min-width: 250px;
                  backdrop-filter: blur(20px);
                  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                  z-index: 1000;
                  overflow: hidden;
                "
              >
                <div
                  style="
                    padding: 12px 18px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    font-size: 11px;
                    font-weight: 700;
                    color: #8ab4ff;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                  "
                >
                  Navigation
                </div>
                <div
                  onclick="openStudentManager()"
                  style="
                    padding: 14px 18px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.2s;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                  "
                  onmouseover="this.style.background='rgba(138,180,255,0.15)'"
                  onmouseout="this.style.background='transparent'"
                >
                  üë• Student Manager
                </div>
                <div
                  onclick="openGroupManager()"
                  style="
                    padding: 14px 18px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.2s;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                  "
                  onmouseover="this.style.background='rgba(168,85,247,0.15)'"
                  onmouseout="this.style.background='transparent'"
                >
                  üìÖ Group Manager
                </div>
                <div
                  onclick="openEmailSystem()"
                  style="
                    padding: 14px 18px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.2s;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                  "
                  onmouseover="this.style.background='rgba(239,68,68,0.15)'"
                  onmouseout="this.style.background='transparent'"
                >
                  üìß Email System
                </div>

                <div
                  style="
                    padding: 12px 18px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    font-size: 11px;
                    font-weight: 700;
                    color: #8ab4ff;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    margin-top: 8px;
                  "
                >
                  Data Management
                </div>
                <div
                  onclick="exportFullBackup()"
                  style="
                    padding: 14px 18px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.2s;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                  "
                  onmouseover="this.style.background='rgba(34,197,94,0.15)'"
                  onmouseout="this.style.background='transparent'"
                >
                  üíæ Export Full Backup
                </div>
                <div
                  onclick="restoreFromCloud()"
                  style="
                    padding: 14px 18px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    font-weight: 600;
                    transition: all 0.2s;
                  "
                  onmouseover="this.style.background='rgba(59,130,246,0.15)'"
                  onmouseout="this.style.background='transparent'"
                >
                  ‚òÅÔ∏è Reload from Supabase Cloud
                </div>

                <div
                  style="
                    padding: 12px 18px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    font-size: 11px;
                    font-weight: 700;
                    color: #8ab4ff;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    margin-top: 8px;
                  "
                >
                  Gmail Timezone Fix
                </div>
                <div style="padding: 12px 18px; border-bottom: 1px solid rgba(255, 255, 255, 0.05)">
                  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px">
                    <span style="color: white; font-size: 12px; font-weight: 500">‚ùÑÔ∏è Winter (‚Äì12h)</span>
                    <label
                      id="toggle12Label"
                      for="laOffset12Toggle"
                      style="position: relative; display: inline-block; width: 40px; height: 22px; cursor: pointer"
                    >
                      <input
                        type="checkbox"
                        id="laOffset12Toggle"
                        class="la-offset-toggle"
                        style="position: absolute; opacity: 0; width: 1px; height: 1px; margin: 0"
                      />
                      <span
                        class="toggle-slider"
                        style="
                          position: absolute;
                          cursor: pointer;
                          top: 0;
                          left: 0;
                          right: 0;
                          bottom: 0;
                          background: rgba(100, 116, 139, 0.4);
                          transition: 0.3s;
                          border-radius: 22px;
                          border: 1px solid rgba(255, 255, 255, 0.2);
                        "
                      ></span>
                      <span
                        class="toggle-knob"
                        style="
                          position: absolute;
                          height: 16px;
                          width: 16px;
                          left: 3px;
                          bottom: 2px;
                          background: white;
                          transition: 0.3s;
                          border-radius: 50%;
                        "
                      ></span>
                    </label>
                  </div>
                  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px">
                    <span style="color: white; font-size: 12px; font-weight: 500">‚òÄÔ∏è Summer (‚Äì11h)</span>
                    <label
                      id="toggle11Label"
                      for="laOffset11Toggle"
                      style="position: relative; display: inline-block; width: 40px; height: 22px; cursor: pointer"
                    >
                      <input
                        type="checkbox"
                        id="laOffset11Toggle"
                        class="la-offset-toggle"
                        style="position: absolute; opacity: 0; width: 1px; height: 1px; margin: 0"
                      />
                      <span
                        class="toggle-slider"
                        style="
                          position: absolute;
                          cursor: pointer;
                          top: 0;
                          left: 0;
                          right: 0;
                          bottom: 0;
                          background: rgba(100, 116, 139, 0.4);
                          transition: 0.3s;
                          border-radius: 22px;
                          border: 1px solid rgba(255, 255, 255, 0.2);
                        "
                      ></span>
                      <span
                        class="toggle-knob"
                        style="
                          position: absolute;
                          height: 16px;
                          width: 16px;
                          left: 3px;
                          bottom: 2px;
                          background: white;
                          transition: 0.3s;
                          border-radius: 50%;
                        "
                      ></span>
                    </label>
                  </div>
                  <div style="font-size: 9px; color: #6b7280; margin-top: 4px">üí° In LA? Keep both OFF</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Month Total Stats -->
        <div class="month-total-section">
          <div class="month-total-header-row" onclick="toggleMonthTotals()" style="cursor: pointer">
            <button type="button" class="month-total-toggle" id="monthTotalsToggle" title="Expand totals">
              <span id="monthTotalsToggleIcon">‚ñæ</span>
            </button>
          </div>
          <div class="month-total-values" id="monthTotalsData">
            <div class="month-total-content">
              <div class="month-total-item">
                <select
                  id="monthSelector"
                  class="month-selector"
                  onchange="updateMonthTotals()"
                  onclick="event.stopPropagation();"
                >
                  <!-- Will be populated dynamically -->
                </select>
              </div>
              <div class="month-total-stats">
                <div class="month-total-item">
                  <div class="month-total-label">PAYMENTS:</div>
                  <div class="month-total-value" id="monthTotalCount">0</div>
                </div>
                <div class="month-total-item">
                  <div class="month-total-label">USD:</div>
                  <div class="month-total-value" id="monthTotalUSD">0 $</div>
                </div>
                <div class="month-total-item">
                  <div class="month-total-label">AMD:</div>
                  <div class="month-total-value" style="color: #94a3b8" id="monthTotalAMD">0 ÷è</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="content" id="paymentEmailsContent">
          <!-- Payment records will be rendered here -->
        </div>
      </div>

      <!-- BEGIN EARNING FORECAST MODAL -->
      <div
        id="earningsForecastModal"
        onclick="if(event.target.id==='earningsForecastModal'){closeEarningsForecast();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 25000;
          backdrop-filter: blur(6px);
          opacity: 0;
          transition: opacity 0.25s ease;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 30, 50, 0.98) 100%);
            backdrop-filter: blur(24px);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
          "
        >
          <!-- Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px">
            <h2
              style="
                margin: 0;
                background: linear-gradient(135deg, #a3ffda, #22c55e);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
                font-size: 24px;
                font-weight: 900;
              "
            >
              üí∞ Earning Forecast Overview
            </h2>
            <button
              onclick="closeEarningsForecast()"
              style="
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                width: 36px;
                height: 36px;
                border-radius: 50%;
                color: white;
                font-size: 24px;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(255,255,255,0.2)'"
              onmouseout="this.style.background='rgba(255,255,255,0.1)'"
            >
              &times;
            </button>
          </div>

          <!-- Content -->
          <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 24px">
            <!-- Active Students Count - Clickable -->
            <div
              onclick="openStudentBreakdown()"
              style="
                margin-bottom: 20px;
                padding: 16px;
                background: rgba(138, 180, 255, 0.1);
                border: 1px solid rgba(138, 180, 255, 0.3);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(138,180,255,0.2)'; this.style.borderColor='rgba(138,180,255,0.5)'"
              onmouseout="this.style.background='rgba(138,180,255,0.1)'; this.style.borderColor='rgba(138,180,255,0.3)'"
            >
              <div
                style="
                  font-size: 12px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 1px;
                  margin-bottom: 8px;
                "
              >
                Active Students
                <span style="font-size: 10px; opacity: 0.7">(click for details)</span>
              </div>
              <div id="forecastActiveCount" style="font-size: 32px; font-weight: 900; color: white">0</div>
            </div>

            <!-- Projected Earnings -->
            <div style="margin-bottom: 20px">
              <div
                style="
                  font-size: 14px;
                  font-weight: 700;
                  color: #a3ffda;
                  text-transform: uppercase;
                  letter-spacing: 1px;
                  margin-bottom: 12px;
                "
              >
                üìä Projected Earnings
              </div>

              <div style="display: flex; gap: 12px; margin-bottom: 12px">
                <div
                  style="
                    flex: 1;
                    padding: 16px;
                    background: rgba(34, 197, 94, 0.1);
                    border: 1px solid rgba(34, 197, 94, 0.3);
                    border-radius: 12px;
                  "
                >
                  <div
                    style="
                      font-size: 11px;
                      font-weight: 700;
                      color: #22c55e;
                      text-transform: uppercase;
                      letter-spacing: 0.5px;
                      margin-bottom: 6px;
                    "
                  >
                    Weekly
                  </div>
                  <div id="forecastWeekly" style="font-size: 24px; font-weight: 900; color: white">0 $</div>
                </div>

                <div
                  style="
                    flex: 1;
                    padding: 16px;
                    background: rgba(34, 197, 94, 0.15);
                    border: 1px solid rgba(34, 197, 94, 0.4);
                    border-radius: 12px;
                  "
                >
                  <div
                    style="
                      font-size: 11px;
                      font-weight: 700;
                      color: #22c55e;
                      text-transform: uppercase;
                      letter-spacing: 0.5px;
                      margin-bottom: 6px;
                    "
                  >
                    Monthly
                  </div>
                  <div id="forecastMonthly" style="font-size: 24px; font-weight: 900; color: white">0 $</div>
                </div>
              </div>
            </div>

            <!-- Actual Earnings -->
            <div
              style="
                padding: 20px;
                background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(168, 85, 247, 0.15));
                border: 2px solid rgba(138, 180, 255, 0.4);
                border-radius: 12px;
              "
            >
              <div
                style="
                  font-size: 14px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 1px;
                  margin-bottom: 8px;
                "
              >
                üíµ Actual Received (This Month)
              </div>
              <div id="forecastActual" style="font-size: 32px; font-weight: 900; color: white">0 $</div>
            </div>

            <!-- Footer Note -->
            <div style="margin-top: 20px; text-align: center; font-size: 11px; color: #94a3b8; font-style: italic">
              Updates automatically as students or payments change
            </div>
          </div>
        </div>
      </div>
      <!-- END EARNING FORECAST MODAL -->

      <!-- BEGIN STUDENT BREAKDOWN MODAL -->
      <div
        id="studentBreakdownModal"
        onclick="if(event.target.id==='studentBreakdownModal'){closeStudentBreakdown();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          z-index: 26000;
          backdrop-filter: blur(8px);
          opacity: 0;
          transition: opacity 0.25s ease;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 30, 50, 0.98) 100%);
            backdrop-filter: blur(24px);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
            overflow-y: auto;
          "
        >
          <!-- Header -->
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 24px;
              position: sticky;
              top: 0;
              background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 30, 50, 0.98) 100%);
              padding-bottom: 16px;
              z-index: 10;
            "
          >
            <h2
              style="
                margin: 0;
                background: linear-gradient(135deg, #8ab4ff, #a855f7);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
                font-size: 22px;
                font-weight: 900;
              "
            >
              üë• Student Earning Breakdown
            </h2>
            <button
              onclick="closeStudentBreakdown()"
              style="
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                width: 36px;
                height: 36px;
                border-radius: 50%;
                color: white;
                font-size: 24px;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(255,255,255,0.2)'"
              onmouseout="this.style.background='rgba(255,255,255,0.1)'"
            >
              &times;
            </button>
          </div>

          <!-- Student List -->
          <div id="studentBreakdownList" style="display: flex; flex-direction: column; gap: 12px">
            <!-- Will be populated dynamically -->
          </div>

          <!-- Total Summary -->
          <div
            style="
              margin-top: 24px;
              padding: 20px;
              background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(22, 163, 74, 0.15));
              border: 2px solid rgba(34, 197, 94, 0.4);
              border-radius: 12px;
            "
          >
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px">
              <div style="font-size: 14px; font-weight: 700; color: #22c55e; text-transform: uppercase">
                Total Weekly
              </div>
              <div id="breakdownTotalWeekly" style="font-size: 24px; font-weight: 900; color: white">0 $</div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center">
              <div style="font-size: 14px; font-weight: 700; color: #22c55e; text-transform: uppercase">
                Total Monthly
              </div>
              <div id="breakdownTotalMonthly" style="font-size: 24px; font-weight: 900; color: white">0 $</div>
            </div>
          </div>
        </div>
      </div>
      <!-- END STUDENT BREAKDOWN MODAL -->

      <!-- SMART CALENDAR PAYMENT SYSTEM -->
      <div
        id="smartCalendarModal"
        onclick="if(event.target.id==='smartCalendarModal'){closeSmartCalendar();}"
        style="
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.85);
          z-index: 27000;
          backdrop-filter: blur(10px);
          opacity: 0;
          transition: opacity 0.3s ease;
        "
      >
        <div
          onclick="event.stopPropagation()"
          style="
            position: relative;
            margin: 2% auto;
            max-width: 1400px;
            max-height: 92vh;
            background: linear-gradient(135deg, rgba(30, 30, 46, 0.98) 0%, rgba(42, 42, 62, 0.98) 100%);
            border: 2px solid rgba(138, 180, 255, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            display: flex;
            flex-direction: column;
          "
        >
          <!-- Header -->
          <div
            style="
              padding: 12px 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              display: flex;
              justify-content: space-between;
              align-items: center;
              background: linear-gradient(135deg, rgba(138, 180, 255, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%);
            "
          >
            <div style="display: flex; align-items: center; gap: 8px">
              <span style="font-size: 20px">üìÖ</span>
              <div>
                <h2 style="margin: 0; font-size: 16px; font-weight: 900; color: white; letter-spacing: -0.5px">
                  Smart Payment Calendar
                </h2>
                <p style="margin: 2px 0 0 0; font-size: 10px; color: #94a3b8">
                  Track scheduled classes, payments, and balances
                </p>
              </div>
            </div>
            <button
              onclick="closeSmartCalendar()"
              style="
                width: 28px;
                height: 28px;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                color: white;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(239,68,68,0.2)'; this.style.borderColor='rgba(239,68,68,0.4)';"
              onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='rgba(255,255,255,0.1)';"
            >
              √ó
            </button>
          </div>

          <!-- Calendar Navigation -->
          <div
            style="
              padding: 12px 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.1);
              display: flex;
              justify-content: space-between;
              align-items: center;
              background: rgba(0, 0, 0, 0.2);
            "
          >
            <button
              onclick="changeCalendarMonth(-1)"
              style="
                padding: 8px 14px;
                background: rgba(138, 180, 255, 0.1);
                border: 1px solid rgba(138, 180, 255, 0.3);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(138,180,255,0.2)'"
              onmouseout="this.style.background='rgba(138,180,255,0.1)'"
            >
              ‚Üê Previous
            </button>
            <div style="text-align: center">
              <div
                id="calendarMonthYear"
                style="font-size: 20px; font-weight: 900; color: white; letter-spacing: -0.5px"
              >
                December 2024
              </div>
              <div id="calendarSubtitle" style="font-size: 13px; color: #94a3b8; margin-top: 2px">
                Loading schedule...
              </div>
            </div>
            <button
              onclick="changeCalendarMonth(1)"
              style="
                padding: 8px 14px;
                background: rgba(138, 180, 255, 0.1);
                border: 1px solid rgba(138, 180, 255, 0.3);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='rgba(138,180,255,0.2)'"
              onmouseout="this.style.background='rgba(138,180,255,0.1)'"
            >
              Next ‚Üí
            </button>
          </div>

          <!-- Calendar Grid -->
          <div style="flex: 1; overflow-y: auto; padding: 16px 20px">
            <!-- Day Headers -->
            <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; margin-bottom: 8px">
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Sun
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Mon
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Tue
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Wed
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Thu
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Fri
              </div>
              <div
                style="
                  text-align: center;
                  font-size: 10px;
                  font-weight: 700;
                  color: #8ab4ff;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  padding: 4px 0;
                "
              >
                Sat
              </div>
            </div>

            <!-- Calendar Cells -->
            <div
              id="calendarGrid"
              style="
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 8px;
                min-height: 400px;
                overflow: visible;
              "
            >
              <!-- Generated dynamically -->
            </div>
          </div>

          <!-- Legend -->
          <div
            style="
              padding: 20px 30px;
              border-top: 1px solid rgba(255, 255, 255, 0.1);
              background: rgba(0, 0, 0, 0.2);
              display: flex;
              gap: 24px;
              flex-wrap: wrap;
            "
          >
            <div style="display: flex; align-items: center; gap: 8px">
              <span
                style="width: 12px; height: 12px; background: #22c55e; border-radius: 50%; display: inline-block"
              ></span>
              <span style="font-size: 12px; color: #94a3b8">üü¢ Paid</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px">
              <span
                style="width: 12px; height: 12px; background: #eab308; border-radius: 50%; display: inline-block"
              ></span>
              <span style="font-size: 12px; color: #94a3b8">üü° Deposit Active</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px">
              <span
                style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%; display: inline-block"
              ></span>
              <span style="font-size: 12px; color: #94a3b8">üî¥ Unpaid</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px">
              <span
                style="width: 12px; height: 12px; background: #64748b; border-radius: 50%; display: inline-block"
              ></span>
              <span style="font-size: 12px; color: #94a3b8">‚ö™ Absent</span>
            </div>
          </div>
        </div>
      </div>
      <!-- END SMART CALENDAR -->

      <script>
        // ============================================================================
        // STORAGE & DATA MANAGEMENT
        // ============================================================================

        const STORAGE_KEYS = {
          PAYMENTS: 'firestone:payments:v3',
          GMAIL_TOKEN: 'firestone:gmail:token',
          GMAIL_EXPIRY: 'firestone:gmail:expiry',
          GMAIL_LAST_CHECK: 'firestone:gmail:last-check',
        };

        const UI_STATE_KEYS = {
          MONTH_TOTALS_COLLAPSED: 'firestone:payments:monthTotalsCollapsed',
        };

        let monthTotalsCollapsed = localStorage.getItem(UI_STATE_KEYS.MONTH_TOTALS_COLLAPSED) === 'true';

        // Timing constants
        const TIMING = {
          NEW_PAYMENT_INDICATOR: 60000, // 60 seconds
          AUTO_REFRESH_INTERVAL: 30000, // 30 seconds
          API_DELAY: 100, // 100ms between API calls
          FULL_SYNC_API_DELAY: 150, // 150ms to respect Gmail rate limits during full sync
        };

        let gmailAccessToken = localStorage.getItem(STORAGE_KEYS.GMAIL_TOKEN);
        let gmailTokenExpiry = localStorage.getItem(STORAGE_KEYS.GMAIL_EXPIRY);

        // ============================================================================
        // SUPABASE DATA OPERATIONS - Replace localStorage with cloud database
        // ============================================================================

        const PaymentStore = {
          getAll: function () {
            return window.paymentsCache || [];
          },
          fetchAll: async function () {
            // ‚ö° PERFORMANCE: Use cache if available and fresh (less than 30 seconds old)
            const cacheTimestamp = window.paymentsCacheTimestamp || 0;
            const cacheAge = Date.now() - cacheTimestamp;
            if (window.paymentsCache && window.paymentsCache.length > 0 && cacheAge < 30000) {
              debugLog('‚ö° Using cached payments (age:', cacheAge, 'ms)');
              return window.paymentsCache;
            }

            try {
              // Load ALL payments from Supabase (no limit - we need accurate count)
              const { data, error } = await supabase
                .from('payments')
                .select('*')
                .order('date', { ascending: false });

              if (error) {
                console.error('‚ùå Error loading payments from Supabase:', error);
                return window.paymentsCache || [];
              }

              // CRITICAL FIX: Convert snake_case from Supabase back to camelCase for JavaScript
              const paymentsFromSupabase = (data || []).map(p => ({
                // Core payment data
                id: p.id,
                gmailId: p.gmail_id,
                amount: p.amount,
                date: p.date,

                // Raw immutable data from email
                payerNameRaw: p.payer_name_raw,
                payerEmailRaw: p.payer_email_raw,
                memo: p.memo,
                message: p.message,

                // Display fields (computed/resolved)
                payerName: p.payer_name,
                senderName: p.sender_name,
                studentName: p.student_name,
                studentEmail: p.student_email,
                groupId: p.group_id,

                // Manual linking (highest priority - user override)
                linkedStudentId: p.linked_student_id,
                manuallyLinked: p.manually_linked,

                // Automatic resolution metadata
                derivedStudentId: p.derived_student_id,
                resolvedStudentName: p.resolved_student_name,
                derivedStudentGroup: p.derived_student_group,
                resolutionSource: p.resolution_source,

                // Legacy/compatibility field
                studentId: p.student_id,

                // Status tracking
                status: p.status,
                viewed: p.viewed,
                ignoredOnce: p.ignored_once,
                ignorePermanently: p.ignore_permanently,

                // Timestamps
                emailDate: p.email_date,
                createdAt: p.created_at,
                linkedAt: p.linked_at,
                dateModifiedAt: p.date_modified_at,
              }));

              window.paymentsCache = paymentsFromSupabase;
              window.paymentsCacheTimestamp = Date.now(); // PERFORMANCE: Track cache freshness
              return window.paymentsCache;
            } catch (err) {
              console.error('‚ùå Exception loading payments:', err);
              return window.paymentsCache || [];
            }
          },
          save: async function (payments) {
            try {
              // CRITICAL FIX: Map JavaScript camelCase to Supabase snake_case
              const paymentsForSupabase = payments.map(p => ({
                // Core payment data
                id: p.id,
                gmail_id: p.gmailId || null, // FIX: gmailId -> gmail_id
                amount: p.amount,
                date: p.date,

                // Raw immutable data from email
                payer_name_raw: p.payerNameRaw || p.payerName, // FIX: snake_case
                payer_email_raw: p.payerEmailRaw || null, // FIX: snake_case
                memo: p.memo || null,
                message: p.message || null,

                // Display fields (computed/resolved)
                payer_name: p.payerName, // FIX: snake_case
                sender_name: p.senderName, // FIX: snake_case
                student_name: p.studentName, // FIX: snake_case
                student_email: p.studentEmail || null, // FIX: snake_case
                group_id: p.groupId || null, // FIX: snake_case

                // Manual linking (highest priority - user override)
                linked_student_id: p.linkedStudentId || null, // Already snake_case
                manually_linked: p.manuallyLinked || false, // Already snake_case

                // Automatic resolution metadata
                derived_student_id: p.derivedStudentId || null, // Already snake_case
                resolved_student_name: p.resolvedStudentName || null, // Already snake_case
                derived_student_group: p.derivedStudentGroup || null, // Already snake_case
                resolution_source: p.resolutionSource || 'none', // Already snake_case

                // Legacy/compatibility field
                student_id: p.studentId || p.linkedStudentId || p.derivedStudentId || null, // FIX: snake_case

                // Status tracking
                status: p.status || 'unmatched',
                viewed: p.viewed || false,
                ignored_once: p.ignoredOnce || false, // FIX: snake_case
                ignore_permanently: p.ignorePermanently || false, // FIX: snake_case

                // Timestamps
                email_date: p.emailDate || p.date, // FIX: snake_case
                created_at: p.createdAt || new Date().toISOString(), // FIX: snake_case
                linked_at: p.linkedAt || null, // FIX: snake_case
                date_modified_at: p.dateModifiedAt || null, // FIX: snake_case
              }));

              if (paymentsForSupabase.length > 0) {
              }

              // For bulk save, we'll upsert all payments
              const { data, error } = await supabase
                .from('payments')
                .upsert(paymentsForSupabase, { onConflict: 'id' })
                .select();

              if (error) {
                console.error('‚ùå Error saving payments to Supabase:', error);
                console.error('üìã Error details:', {
                  code: error.code,
                  message: error.message,
                  details: error.details,
                  hint: error.hint,
                });
                console.error('üìã Failed payload sample:', paymentsForSupabase[0]);

                // Try to save to cache anyway so data isn't lost
                window.paymentsCache = payments;
                showNotification('‚ö†Ô∏è Failed to save to database, but cached locally', 'warning');
                return;
              }

              // Convert snake_case response back to camelCase for cache
              const paymentsFromSupabase = (data || []).map(p => ({
                id: p.id,
                gmailId: p.gmail_id,
                amount: p.amount,
                date: p.date,
                payerNameRaw: p.payer_name_raw,
                payerEmailRaw: p.payer_email_raw,
                memo: p.memo,
                message: p.message,
                payerName: p.payer_name,
                senderName: p.sender_name,
                studentName: p.student_name,
                studentEmail: p.student_email,
                groupId: p.group_id,
                linkedStudentId: p.linked_student_id,
                manuallyLinked: p.manually_linked,
                derivedStudentId: p.derived_student_id,
                resolvedStudentName: p.resolved_student_name,
                derivedStudentGroup: p.derived_student_group,
                resolutionSource: p.resolution_source,
                studentId: p.student_id,
                status: p.status,
                viewed: p.viewed,
                ignoredOnce: p.ignored_once,
                ignorePermanently: p.ignore_permanently,
                emailDate: p.email_date,
                createdAt: p.created_at,
                linkedAt: p.linked_at,
                dateModifiedAt: p.date_modified_at,
              }));

              window.paymentsCache = paymentsFromSupabase;
              window.paymentsCacheTimestamp = Date.now(); // PERFORMANCE: Track cache freshness
              dispatchPaymentsUpdated(paymentsFromSupabase);

              // Auto-backup on every save
              try {
                const backupData = {
                  timestamp: new Date().toISOString(),
                  payments: payments,
                  payment_count: payments.length,
                  source: 'auto-save',
                };
                await createAutoBackup(backupData);
              } catch (error) {
                console.error('Auto-backup failed:', error);
              }
            } catch (err) {
              console.error('‚ùå Exception saving payments:', err);
            }
          },
        };

        // Supabase helper functions for individual operations
        async function addPayment(paymentData) {
          const { data, error } = await supabase.from('payments').insert([paymentData]).select();

          if (error) {
            console.error('‚ùå Error adding payment:', error);
            return null;
          }

          // AUTO-SEND: Payment Receipt Email
          if (data && data[0]) {
            const payment = data[0];
            const students = getCachedStudents();
            const student = students.find(s => String(s.id) === String(payment.derivedStudentId));

            if (student && student.email) {
              verboseLog('üìß Auto-sending payment receipt email to:', student.name);
              try {
                const emailResult = await sendPaymentReceiptEmail(
                  student,
                  payment.amount,
                  payment.date || new Date().toISOString().split('T')[0],
                  student.balance
                );

                if (emailResult.success) {
                  verboseLog('‚úÖ Payment receipt email sent successfully');
                  // Create notification
                  if (window.NotificationCenter) {
                    await window.NotificationCenter.add(
                      window.NotificationCenter.NotificationType.SUCCESS,
                      `Payment Receipt Sent: $${payment.amount}`,
                      `Confirmation email sent to ${student.name} (${student.email})`,
                      {
                        studentName: student.name,
                        metadata: {
                          amount: payment.amount,
                          date: payment.date,
                          email: student.email,
                        },
                      }
                    );
                  }
                } else {
                  console.error('‚ö†Ô∏è Payment receipt email failed:', emailResult.error);
                }
              } catch (emailError) {
                console.error('‚ö†Ô∏è Payment receipt email failed:', emailError);
                // Don't block payment - email failure is non-critical
              }
            }
          }

          return data[0];
        }

        async function updatePayment(id, updates) {
          const { data, error } = await supabase.from('payments').update(updates).eq('id', id).select();

          if (error) {
            console.error('‚ùå Error updating payment:', error);
            return null;
          }

          return data[0];
        }

        async function deletePayment(id) {
          const { error } = await supabase.from('payments').delete().eq('id', id);

          if (error) {
            console.error('‚ùå Error deleting payment:', error);
            return false;
          }

          return true;
        }

        window.studentsCache = Array.isArray(window.studentsCache) ? window.studentsCache : [];

        function getCachedStudents() {
          return Array.isArray(window.studentsCache) ? window.studentsCache : [];
        }

        function normalizeStudentStatusValue(status) {
          if (!status) return 'active';
          const lower = String(status).toLowerCase();
          if (lower === 'pause' || lower === 'paused') return 'paused';
          if (lower === 'graduate' || lower === 'graduated') return 'graduated';
          return 'active';
        }

        function mapSupabaseStudent(record) {
          if (!record) return null;

          // CRITICAL FIX: Use delimiter that won't appear in names (|||)
          // This prevents "Company, Inc." from being split into ["Company", "Inc."]
          let aliases = [];
          if (typeof record.aliases === 'string') {
            if (record.aliases.includes('|||')) {
              // New format: delimited by |||
              aliases = record.aliases
                .split('|||')
                .map(alias => alias.trim())
                .filter(Boolean);
            } else {
              // Legacy format: comma-separated (but this breaks company names with commas)
              // For backward compatibility, keep as single alias if it looks like a company name
              aliases = record.aliases ? [record.aliases.trim()] : [];
            }
          } else if (Array.isArray(record.aliases)) {
            aliases = record.aliases;
          }

          return {
            ...record,
            group: record.group_name ?? record.group ?? null,
            payPerClass: record.price_per_class ?? record.payPerClass ?? null,
            balance: record.balance ?? 0,
            status: normalizeStudentStatusValue(record.status),
            showInGrid: record.show_in_grid ?? record.showInGrid ?? true, // Default true only for legacy records
            isActive: record.is_active ?? record.isActive ?? true,
            statusChangedDate: record.status_changed_date ?? record.statusChangedDate ?? null,
            created_at: record.created_at ?? null, // Preserve creation timestamp for calendar logic
            aliases,
          };
        }

        async function loadStudents() {
          // ‚ö° PERFORMANCE: Use cache if available and fresh (less than 30 seconds old)
          const cacheTimestamp = window.studentsCacheTimestamp || 0;
          const cacheAge = Date.now() - cacheTimestamp;
          if (window.studentsCache && window.studentsCache.length > 0 && cacheAge < 30000) {
            debugLog('‚ö° Using cached students (age:', cacheAge, 'ms)');
            return window.studentsCache;
          }

          // ‚ö° FIX #6: CAP QUERY - Load only active/recent students initially
          const { data, error } = await supabase
            .from('students')
            .select('*')
            .order('name', { ascending: true })
            .limit(150); // Limit for performance

          if (error) {
            console.error('‚ùå Error loading students:', error);
            return window.studentsCache || [];
          }

          // Map Supabase column names to local property names
          const mappedData = (data || []).map(mapSupabaseStudent).filter(Boolean);

          window.studentsCache = mappedData;
          window.studentsCacheTimestamp = Date.now(); // PERFORMANCE: Track cache freshness
          return mappedData;
        }

        async function saveStudent(studentData) {
          // Check if this is an update (has a numeric Supabase ID) or insert
          const isUpdate = studentData.id && typeof studentData.id === 'number';

          // Track old groups for enrollment email
          let oldGroups = [];
          if (isUpdate) {
            const students = getCachedStudents();
            const existingStudent = students.find(s => s.id === studentData.id);
            if (existingStudent && existingStudent.group) {
              oldGroups = existingStudent.group
                .split(',')
                .map(g => g.trim())
                .filter(Boolean);
            }
          }

          // Prepare payload - map local field names to Supabase columns
          const payload = {
            name: studentData.name,
            group_name: studentData.group || studentData.group_name || null,
            price_per_class: studentData.price_per_class ?? studentData.payPerClass ?? null,
            balance: studentData.balance ?? 0,
            status: normalizeStudentStatusValue(studentData.status),
            status_changed_date: studentData.statusChangedDate ?? null,
          };

          // Add optional fields only if they exist in the Supabase schema
          if (studentData.email) payload.email = studentData.email;
          if (studentData.phone) payload.phone = studentData.phone;
          if (studentData.notes) payload.notes = studentData.notes;

          // Save show_in_grid to Supabase (controls calendar visibility)
          if (typeof studentData.showInGrid === 'boolean') {
            payload.show_in_grid = studentData.showInGrid;
            console.log('‚úÖ Adding show_in_grid to payload:', payload.show_in_grid);
          } else {
            console.warn('‚ö†Ô∏è showInGrid is not a boolean:', typeof studentData.showInGrid, studentData.showInGrid);
          }

          // Handle aliases - convert array to delimited string using ||| separator
          // This prevents aliases with commas (like "Company, Inc.") from being split incorrectly
          if (studentData.aliases) {
            payload.aliases = Array.isArray(studentData.aliases)
              ? studentData.aliases.join('|||')
              : studentData.aliases;
          }

          // CRITICAL: Set created_at for new students (used for red dot calendar logic)
          // This ensures red dots only appear for classes AFTER the student was added
          if (!isUpdate) {
            payload.created_at = studentData.created_at || studentData.createdAt || new Date().toISOString();
          }

          // CRITICAL: Never include 'id' in payload for INSERT
          // Only use it in UPDATE .eq() clause
          if (payload.id) {
            delete payload.id;
          }

          console.log('üì§ Supabase payload:', isUpdate ? 'UPDATE' : 'INSERT', payload);

          try {
            let result;

            if (isUpdate) {
              // Update existing record by numeric ID
              result = await supabase.from('students').update(payload).eq('id', studentData.id).select();
            } else {
              // Insert new record - let Supabase generate ID
              result = await supabase.from('students').insert([payload]).select();
            }

            const { data, error } = result;

            if (error) {
              console.error('‚ùå Error saving student:', error);
              console.error('Error details:', error.message, error.details, error.hint);
              console.error('Payload sent:', payload);
              return null;
            }

            const mappedRecord = mapSupabaseStudent(data?.[0]);

            // AUTO-SEND: Group Enrollment Email (only for newly added groups)
            if (mappedRecord && mappedRecord.email && mappedRecord.group) {
              const newGroups = mappedRecord.group
                .split(',')
                .map(g => g.trim())
                .filter(Boolean);
              const addedGroups = newGroups.filter(g => !oldGroups.includes(g));

              if (addedGroups.length > 0) {
                verboseLog(`üìß Sending enrollment emails for ${addedGroups.length} new group(s):`, addedGroups);

                // Send enrollment email for each newly added group
                for (const groupName of addedGroups) {
                  try {
                    const group = window.groupsCache?.find(g => g.name === groupName);
                    const groupSchedule = group?.schedule || 'Schedule TBD';

                    await sendGroupEnrollmentEmail(mappedRecord, groupName, groupSchedule);
                  } catch (emailError) {
                    console.error(`‚ö†Ô∏è Enrollment email failed for group ${groupName}:`, emailError);
                    // Continue to next group - don't block on email failure
                  }
                }
              }
            }

            return mappedRecord;
          } catch (err) {
            console.error('‚ùå Exception saving student:', err);
            return null;
          }
        }

        async function deleteStudentRecord(id) {
          try {
            const { error } = await supabase.from('students').delete().eq('id', id);

            if (error) {
              throw error;
            }

            return true;
          } catch (error) {
            console.error('‚ùå Error deleting student:', error);
            return false;
          }
        }

        async function loadGroupsFromSupabase() {
          // PERFORMANCE: Use cache if available and fresh (less than 30 seconds old)
          const cacheTimestamp = window.groupsCacheTimestamp || 0;
          const cacheAge = Date.now() - cacheTimestamp;
          if (window.groupsCache && window.groupsCache.length > 0 && cacheAge < 30000) {
            debugLog('‚ö° Using cached groups (age:', cacheAge, 'ms)');
            return window.groupsCache;
          }

          const { data, error } = await supabase.from('groups').select('*').order('updated_at', { ascending: false });

          if (error) {
            console.error('‚ùå Error loading groups:', error);
            return window.groupsCache || [];
          }

          // Map group_name back to name for app compatibility
          const mappedData = (data || []).map(group => ({
            id: group.id,
            name: group.group_name,
            schedule: group.schedule,
            color: group.color,
            active: group.active ?? true, // Default true for legacy records
            one_time_schedules: group.one_time_schedules || [],
            created_at: group.created_at,
            updated_at: group.updated_at,
          }));

          // De-duplicate by name, keeping the most recently updated/created row
          const deduped = [];
          const seen = new Set();
          const sorted = [...mappedData].sort((a, b) => {
            const aTime = new Date(a.updated_at || a.created_at || 0).getTime();
            const bTime = new Date(b.updated_at || b.created_at || 0).getTime();
            return bTime - aTime; // newest first
          });
          for (const g of sorted) {
            if (!g.name) continue;
            const key = String(g.name).trim().toUpperCase();
            if (!seen.has(key)) {
              deduped.push(g);
              seen.add(key);
            }
          }

          window.groupsCache = deduped;
          window.groupsCacheTimestamp = Date.now(); // PERFORMANCE: Track cache freshness
          return window.groupsCache;
        }
        async function saveGroup(groupData) {
          // Map 'name' to 'group_name' for Supabase
          const payload = {
            group_name: groupData.name || groupData.group_name,
            schedule: groupData.schedule,
            color: groupData.color,
          };

          // Save active field if provided
          if (typeof groupData.active === 'boolean') {
            payload.active = groupData.active;
          }

          // Save one-time schedules if provided
          if (groupData.one_time_schedules !== undefined) {
            payload.one_time_schedules = groupData.one_time_schedules;
          }

          // Track old schedule for email notification
          let oldSchedule = null;
          if (groupData.id && window.groupsCache) {
            const existingGroup = window.groupsCache.find(g => g.id === groupData.id);
            oldSchedule = existingGroup?.schedule;
          }

          let data, error;

          if (groupData.id) {
            // UPDATE existing group - use eq() to match by id
            ({ data, error } = await supabase.from('groups').update(payload).eq('id', groupData.id).select());
          } else {
            // INSERT new group - check if name exists first
            const { data: existing, error: checkError } = await supabase
              .from('groups')
              .select('id')
              .eq('group_name', payload.group_name)
              .maybeSingle();

            if (checkError) {
              console.error('Error checking for existing group:', checkError);
            }

            if (existing) {
              // Group with this name already exists, update it
              ({ data, error } = await supabase.from('groups').update(payload).eq('id', existing.id).select());
            } else {
              // Insert new group
              ({ data, error } = await supabase.from('groups').insert([payload]).select());
            }
          }

          if (error) {
            console.error('‚ùå Error saving group:', error);
            return null;
          }

          // AUTO-SEND: Schedule Change Email (only if schedule actually changed)
          if (data && data[0] && oldSchedule && oldSchedule !== payload.schedule) {
            const groupName = payload.group_name;
            const newSchedule = payload.schedule;

            verboseLog(`üìß Schedule changed for ${groupName}: "${oldSchedule}" ‚Üí "${newSchedule}"`);

            // Get all active students in this group
            const students = getCachedStudents();
            const groupStudents = students.filter(s => s.group && s.group.includes(groupName) && s.status === 'active');

            verboseLog(`üìß Sending schedule change emails to ${groupStudents.length} students`);

            // Send email to each active student
            for (const student of groupStudents) {
              if (student.email) {
                try {
                  await sendScheduleChangeEmail(student, groupName, oldSchedule, newSchedule);
                } catch (emailError) {
                  console.error(`‚ö†Ô∏è Schedule change email failed for ${student.name}:`, emailError);
                  // Continue to next student - don't block on email failure
                }
              }
            }
          }

          return data[0];
        }

        async function deleteGroupById(id) {
          const { error } = await supabase.from('groups').delete().eq('id', id);

          if (error) {
            console.error('‚ùå Error deleting group:', error);
            return false;
          }

          return true;
        }

        // ============================================================================
        // PAYMENT-STUDENT LINKING & ALIAS RESOLUTION SYSTEM
        // ============================================================================

        // Dispatch events for cross-module communication
        function dispatchPaymentsUpdated(payments) {
          window.dispatchEvent(
            new CustomEvent('payments:updated', {
              detail: { changed: payments.map(p => p.id) },
            })
          );
        }

        function dispatchStudentsUpdatedFromPayments() {
          window.dispatchEvent(
            new CustomEvent('students:updated', {
              detail: { source: 'payment-linking' },
            })
          );
        }

        // Server sync hook (placeholder for external integrations)
        async function syncWithServer({ paymentsChanged = [], studentsChanged = [] }) {
          // Future: Trigger GitHub automation or other webhooks
        }

        // Normalize string for alias matching
        function normalizeForMatching(str) {
          if (!str) return '';
          return String(str).toLowerCase().trim().replace(/\s+/g, ' ');
        }

        // Resolve payment to student using alias system
        function resolvePaymentToStudent(payment, studentCache) {
          const students = Array.isArray(studentCache) ? studentCache : getCachedStudents();

          // Priority 1: Manual link (check both linkedStudentId and studentId)
          const manualStudentId = payment.linkedStudentId || payment.studentId;
          if (manualStudentId && payment.manuallyLinked) {
            const student = students.find(s => s.id === manualStudentId);
            if (student) {
              return {
                studentId: student.id,
                studentName: student.name,
                studentEmail: student.email,
                studentGroup: student.group || student.groups || '',
                source: 'manual',
              };
            }
          }

          // Priority 2: Direct name match (NEW - AUTOMATIC MATCHING)
          const payerNorm = normalizeForMatching(payment.payerNameRaw || payment.payerName);
          const emailNorm = normalizeForMatching(payment.payerEmailRaw || payment.studentEmail);

          const directNameMatches = students.filter(student => normalizeForMatching(student.name) === payerNorm);

          if (directNameMatches.length === 1) {
            return {
              studentId: directNameMatches[0].id,
              studentName: directNameMatches[0].name,
              studentEmail: directNameMatches[0].email,
              studentGroup: directNameMatches[0].group || directNameMatches[0].groups || '',
              source: 'direct',
            };
          } else if (directNameMatches.length > 1) {
            return {
              studentId: null,
              studentName: payment.payerNameRaw || payment.payerName || 'Unmatched',
              studentEmail: null,
              studentGroup: '',
              source: 'conflict',
              conflicts: directNameMatches,
            };
          }

          // Priority 3: Alias or Email resolution
          const matches = [];

          students.forEach(student => {
            // Check aliases
            if (student.aliases && Array.isArray(student.aliases)) {
              const aliasMatch = student.aliases.some(alias => normalizeForMatching(alias) === payerNorm);
              if (aliasMatch) {
                matches.push(student);
                return;
              }
            }

            // Check email match
            if (emailNorm && normalizeForMatching(student.email) === emailNorm) {
              matches.push(student);
              return;
            }
          });

          if (matches.length === 1) {
            return {
              studentId: matches[0].id,
              studentName: matches[0].name,
              studentEmail: matches[0].email,
              studentGroup: matches[0].group || matches[0].groups || '',
              source: 'alias',
            };
          } else if (matches.length > 1) {
            return {
              studentId: null,
              studentName: payment.payerNameRaw || payment.payerName || 'Unmatched',
              studentEmail: null,
              studentGroup: '',
              source: 'conflict',
              conflicts: matches,
            };
          }

          // Priority 4: No match - unmatched
          return {
            studentId: null,
            studentName: payment.payerNameRaw || payment.payerName || 'Unmatched',
            studentEmail: payment.payerEmailRaw || null,
            studentGroup: '',
            source: 'none',
          };
        }

        // Recompute resolution for all payments
        async function recomputePaymentResolutions() {
          const payments = PaymentStore.getAll();
          const students = getCachedStudents();
          let updated = false;

          payments.forEach(payment => {
            const resolution = resolvePaymentToStudent(payment, students);

            // Update derived fields
            const oldDerivedId = payment.derivedStudentId;
            const oldResolved = payment.resolvedStudentName;
            const oldGroup = payment.derivedStudentGroup;
            const oldStudentName = payment.studentName;

            payment.derivedStudentId = resolution.studentId;
            payment.resolvedStudentName = resolution.studentName;
            payment.derivedStudentGroup = resolution.studentGroup;
            payment.resolutionSource = resolution.source;

            // Set studentName for calendar lookup (use resolved name)
            if (resolution.studentName) {
              payment.studentName = resolution.studentName;
            }

            if (resolution.source === 'conflict') {
              payment.conflictCandidates = resolution.conflicts.map(s => s.id);
            } else {
              delete payment.conflictCandidates;
            }

            if (
              oldDerivedId !== payment.derivedStudentId ||
              oldResolved !== payment.resolvedStudentName ||
              oldGroup !== payment.derivedStudentGroup ||
              oldStudentName !== payment.studentName
            ) {
              updated = true;
            }
          });

          if (updated) {
            await PaymentStore.save(payments);
          }
        }

        // Process overpayments and convert to credit
        async function processOverpayments() {
          try {
            const payments = PaymentStore.getAll();
            const students = getCachedStudents();
            const processedOverpayments = JSON.parse(localStorage.getItem('processedOverpayments') || '{}');
            const creditsApplied = [];

            debugLog('üí∞ Processing overpayments for', payments.length, 'payments...');

            for (const payment of payments) {
              // Skip if already processed
              if (processedOverpayments[payment.id]) {
                continue;
              }

              // Skip if payment isn't resolved to a student
              if (!payment.derivedStudentId) {
                continue;
              }

              // Find student (handle both string and number IDs)
              const student = students.find(s => String(s.id) === String(payment.derivedStudentId));
              if (!student) {
                debugLog(`‚ö†Ô∏è Student ID ${payment.derivedStudentId} not found for payment ${payment.id}`);
                continue;
              }

              const studentPrice = parseFloat(student.payPerClass || student.price_per_class || 0);
              const paymentAmount = parseFloat(payment.amount || 0);

              // DISABLED: Auto-credit feature removed per user request
              // Check if overpayment
              if (false && paymentAmount > studentPrice && studentPrice > 0) {
                const excess = paymentAmount - studentPrice;

                debugLog(
                  `üí∞ OVERPAYMENT DETECTED: ${student.name} paid $${paymentAmount}, price is $${studentPrice}, excess: $${excess}`
                );

                try {
                  // Update credit balance via RPC (atomic SQL)
                  const { data, error } = await supabase.rpc('increment_credit_balance', {
                    student_id: student.id,
                    amount: excess,
                  });

                  if (error) {
                    console.warn('RPC increment_credit_balance failed, using fallback UPDATE:', error);
                    // Fallback: manual update if RPC doesn't exist
                    const newBalance = parseFloat(student.balance || 0) + excess;
                    const { error: updateError } = await supabase
                      .from('students')
                      .update({ balance: newBalance })
                      .eq('id', student.id);

                    if (updateError) {
                      console.error('Failed to update student balance:', updateError);
                      continue;
                    }

                    student.balance = newBalance;
                  } else {
                    // Update local cache
                    student.balance = parseFloat(student.balance || 0) + excess;
                  }

                  // Mark as processed
                  processedOverpayments[payment.id] = {
                    processedAt: new Date().toISOString(),
                    excess: excess,
                    studentId: student.id,
                  };
                  localStorage.setItem('processedOverpayments', JSON.stringify(processedOverpayments));

                  // Generate system notification
                  await window.NotificationCenter.add(
                    window.NotificationCenter.NotificationType.CREDIT,
                    'Credit Added (Auto)',
                    `${student.name} paid $${paymentAmount.toFixed(2)} ‚Äî $${excess.toFixed(2)} added as credit. Email NOT sent automatically.`,
                    {
                      studentId: student.id,
                      amount: excess,
                      paymentId: payment.id,
                    }
                  );

                  // DON'T send email automatically - only notify
                  debugLog(`‚úÖ Credit added to ${student.name}: $${excess.toFixed(2)} (email not sent)`);

                  creditsApplied.push({
                    student: student.name,
                    payment: paymentAmount,
                    credit: excess,
                    newBalance: student.balance,
                    email: student.email,
                  });
                } catch (error) {
                  console.error(`Failed to process overpayment for ${student.name}:`, error);
                }
              }
            }

            // Refresh UI if credits were applied
            if (creditsApplied.length > 0) {
              await loadStudents();
              window.dispatchEvent(new CustomEvent('students:updated'));

              const totalCredit = creditsApplied.reduce((sum, c) => sum + c.credit, 0);
              const studentNames = creditsApplied.map(c => c.student).join(', ');

              showNotification(
                `üí∞ Applied $${totalCredit.toFixed(2)} in credits to ${creditsApplied.length} student(s). Emails NOT sent - review and send manually if needed.`,
                'success',
                10000 // Show for 10 seconds
              );

              debugLog('‚úÖ Credits applied (emails not sent):', creditsApplied);
              debugLog('üìã Students who received credit:', studentNames);
            } else {
              verboseLog('No new overpayments to process');
            }

            return creditsApplied;
          } catch (error) {
            console.error('Error processing overpayments:', error);
            showNotification('‚ùå Error processing overpayments', 'error');
            return [];
          }
        }

        // Send credit added confirmation email to student
        async function sendCreditAddedEmail(student, creditAmount, newBalance) {
          try {
            if (!student.email) {
              verboseLog(`No email for ${student.name}, skipping credit email`);
              return false;
            }

            const emailSubject = 'Credit Added to Your Account - ARNOMA NCLEX-RN';
            const emailBody = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
                .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
                .header h1 { margin: 0; font-size: 24px; }
                .content { background: #ffffff; padding: 30px; border: 1px solid #e5e7eb; border-top: none; border-radius: 0 0 10px 10px; }
                .credit-amount { font-size: 42px; font-weight: 700; color: #10b981; text-align: center; margin: 20px 0; }
                .balance-box { background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); border-left: 4px solid #667eea; padding: 20px; margin: 20px 0; border-radius: 8px; }
                .balance-box strong { color: #667eea; font-size: 18px; }
                .info-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 20px 0; border-radius: 8px; }
                .footer { text-align: center; color: #6b7280; font-size: 14px; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>üí∞ Credit Added!</h1>
                </div>
                <div class="content">
                  <p style="font-size: 16px;">Hello <strong>${escapeHtml(student.name)}</strong>,</p>

                  <p style="font-size: 16px;">Great news!</p>

                  <div class="credit-amount">$${creditAmount.toFixed(2)}</div>
                  <p style="text-align: center; color: #6b7280; margin-top: -10px;">has been added as credit to your account</p>

                  <div class="balance-box">
                    <strong>Your Current Credit Balance:</strong>
                    <div style="font-size: 28px; color: #667eea; font-weight: 700; margin-top: 8px;">$${newBalance.toFixed(2)}</div>
                  </div>

                  <div class="info-box">
                    <strong style="color: #f59e0b;">üí° How to use your credit:</strong>
                    <p style="margin: 8px 0 0 0; color: #78350f;">Your credit will be automatically applied to your next class payment. No action needed!</p>
                  </div>

                  <p style="font-size: 14px; color: #6b7280; margin-top: 30px;">
                    If you have any questions about your credit balance, please don't hesitate to contact us.
                  </p>
                </div>
                <div class="footer">
                  <p>ARNOMA NCLEX-RN Preparation</p>
                  <p>This is an automated notification about your account credit.</p>
                </div>
              </div>
            </body>
            </html>
          `;

            const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
              },
              body: JSON.stringify({
                to: student.email,
                subject: emailSubject,
                html: emailBody,
              }),
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('Failed to send credit email:', errorText);
              return false;
            }

            // Track sent email
            await window.trackSentEmail(student.email, emailSubject, 'Credit Notification', emailBody, {
              recipientName: student.name,
              creditAmount: creditAmount,
              newBalance: newBalance,
            });

            verboseLog(`‚úÖ Credit email sent to ${student.name}`);
            return true;
          } catch (error) {
            console.error('Error sending credit email:', error);
            return false;
          }
        }

        // Helper: Send credit emails to multiple students (use after reviewing auto-applied credits)
        async function sendCreditEmailsToStudents(studentIds) {
          const students = getCachedStudents();
          const results = [];

          for (const studentId of studentIds) {
            const student = students.find(s => String(s.id) === String(studentId));
            if (!student) {
              console.warn(`Student ID ${studentId} not found`);
              continue;
            }

            if (!student.balance || student.balance <= 0) {
              verboseLog(`${student.name} has no credit balance, skipping email`);
              continue;
            }

            const emailSent = await sendCreditAddedEmail(student, student.balance, student.balance);
            results.push({
              student: student.name,
              email: student.email,
              sent: emailSent,
            });
          }

          verboseLog('Email results:', results);
          const successCount = results.filter(r => r.sent).length;
          showNotification(`‚úÖ Sent ${successCount} of ${results.length} credit emails`, 'success');
          return results;
        }

        // Show payment context menu
        function showPaymentContextMenu(event, paymentId) {
          try {
            event.preventDefault();
            event.stopPropagation();

            // Close any existing menus
            const existingMenu = document.getElementById('paymentContextMenu');
            if (existingMenu) existingMenu.remove();

            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === paymentId);
            if (!payment) {
              console.error('Payment not found:', paymentId);
              return;
            }

            const resolution = resolvePaymentToStudent(payment, getCachedStudents());

            const menu = document.createElement('div');
            menu.id = 'paymentContextMenu';
            menu.style.cssText = `
          position: fixed;
          left: ${event.clientX}px;
          top: ${event.clientY}px;
          background: rgba(15,20,35,0.98);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 10px;
          box-shadow: 0 8px 24px rgba(0,0,0,0.8);
          backdrop-filter: blur(20px);
          z-index: 10000;
          min-width: 220px;
          padding: 6px;
          animation: slideDownFade 0.2s ease;
        `;

            const menuItems = [];

            // Link to Existing Student
            menuItems.push({
              icon: 'üîó',
              label: 'Link to Existing Student',
              action: () => showLinkToStudentModal(paymentId),
            });

            // Add Alias (only if resolved to a student)
            if (resolution.studentId) {
              menuItems.push({
                icon: 'üìù',
                label: 'Add Alias to This Student',
                action: () => showAddAliasModal(paymentId, resolution.studentId),
              });
            }

            // Add New Student
            menuItems.push({
              icon: '‚ûï',
              label: 'Add New Student',
              action: () => showAddNewStudentFromPayment(paymentId),
            });

            // Unlink Student (only if manually linked)
            if (payment.linkedStudentId) {
              menuItems.push({
                icon: 'üîì',
                label: 'Unlink Student',
                action: () => unlinkPaymentFromStudent(paymentId),
              });
            }

            // Resolve Conflict (if multiple matches)
            if (resolution.source === 'conflict' && resolution.conflicts) {
              menuItems.push({
                icon: '‚ö†Ô∏è',
                label: `Resolve Conflict (${resolution.conflicts.length} matches)`,
                action: () => showResolveConflictModal(paymentId, resolution.conflicts),
              });
            }

            // Store actions in window for onclick access
            window.paymentMenuActions = menuItems.map(item => item.action);

            menu.innerHTML = menuItems
              .map(
                (item, idx) => `
          <div onclick="event.stopPropagation(); window.paymentMenuActions[${idx}](); document.getElementById('paymentContextMenu')?.remove();" style="
            padding: 10px 14px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
          " onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">
            <span style="font-size: 16px;">${item.icon}</span>
            <span>${item.label}</span>
          </div>
        `
              )
              .join('');

            document.body.appendChild(menu);

            // Close menu on outside click
            setTimeout(() => {
              document.addEventListener('click', function closeMenu(e) {
                if (!menu.contains(e.target)) {
                  menu.remove();
                  document.removeEventListener('click', closeMenu);
                }
              });
            }, 100);

            // Adjust position if menu goes off screen
            const rect = menu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
              menu.style.left = window.innerWidth - rect.width - 10 + 'px';
            }
            if (rect.bottom > window.innerHeight) {
              menu.style.top = window.innerHeight - rect.height - 10 + 'px';
            }
          } catch (error) {
            console.error('Error showing payment context menu:', error);
            showNotification('‚ùå Error opening menu', 'error');
          }
        }

        // Link payment to existing student
        function showLinkToStudentModal(paymentId) {
          const modal = document.createElement('div');
          modal.id = 'linkStudentModal';
          modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(8px);
        z-index: 11000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease;
      `;

          const students = getCachedStudents();

          const modalContent = document.createElement('div');
          modalContent.style.cssText = `
        background: rgba(15,20,35,0.98);
        border: 2px solid rgba(59,130,246,0.4);
        border-radius: 16px;
        padding: 28px;
        max-width: 480px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;

          modalContent.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: white; font-size: 20px; font-weight: 700;">
          üîó Link to Existing Student
        </h3>

        <input type="text" id="studentSearchInput" placeholder="Search by name or email..." style="width: 100%; padding: 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 14px; margin-bottom: 16px;">

        <div id="studentListContainer" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
          ${students
            .map(
              student => `
            <div class="student-select-item" data-student-id="${escapeHtml(student.id)}" data-payment-id="${escapeHtml(paymentId)}" style="padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;">
              <div style="color: white; font-weight: 600; margin-bottom: 4px;">${escapeHtml(student.name)}</div>
              <div style="color: #94a3b8; font-size: 12px;">${escapeHtml(student.email || '‚Äî')}</div>
              ${student.groups && student.groups.length > 0 ? `<div style="color: #3b82f6; font-size: 11px; margin-top: 4px;">Group: ${escapeHtml(student.groups.join(', '))}</div>` : ''}
            </div>
          `
            )
            .join('')}
        </div>

        <button id="closeLinkModalBtn" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
          Cancel
        </button>
      `;

          modal.appendChild(modalContent);
          document.body.appendChild(modal);

          // Add event listeners
          const searchInput = document.getElementById('studentSearchInput');
          if (searchInput) {
            searchInput.addEventListener('input', debounce(filterStudentList, 300));
          }

          const studentItems = document.querySelectorAll('.student-select-item');
          studentItems.forEach(item => {
            item.addEventListener('click', function () {
              const studentId = this.getAttribute('data-student-id');
              const paymentId = this.getAttribute('data-payment-id');
              selectStudentForLink(paymentId, studentId);
            });

            item.addEventListener('mouseover', function () {
              this.style.background = 'rgba(59,130,246,0.15)';
              this.style.borderColor = 'rgba(59,130,246,0.4)';
            });

            item.addEventListener('mouseout', function () {
              this.style.background = 'rgba(255,255,255,0.05)';
              this.style.borderColor = 'rgba(255,255,255,0.1)';
            });
          });

          const closeBtn = document.getElementById('closeLinkModalBtn');
          if (closeBtn) {
            closeBtn.addEventListener('click', closeLinkStudentModal);
          }

          // Close on background click
          modal.addEventListener('click', function (e) {
            if (e.target === modal) {
              closeLinkStudentModal();
            }
          });
        }

        // BEGIN LINKING & SEARCH FIX
        function filterStudentList() {
          const searchInput = document.getElementById('studentSearchInput');
          if (!searchInput) return;

          const searchTerm = searchInput.value.toLowerCase().trim();
          const studentItems = document.querySelectorAll('.student-select-item');

          let visibleCount = 0;

          studentItems.forEach(item => {
            // Get student name and email from the text content
            const textContent = item.textContent.toLowerCase();
            const matches = !searchTerm || textContent.includes(searchTerm);

            if (matches) {
              item.style.display = 'block';
              visibleCount++;
            } else {
              item.style.display = 'none';
            }
          });

          // Show "no results" message if nothing matches
          const container = document.getElementById('studentListContainer');
          if (container) {
            let noResultsMsg = container.querySelector('.no-results-message');

            if (visibleCount === 0 && searchTerm) {
              if (!noResultsMsg) {
                noResultsMsg = document.createElement('div');
                noResultsMsg.className = 'no-results-message';
                noResultsMsg.style.cssText = 'padding: 20px; text-align: center; color: #94a3b8; font-size: 14px;';
                noResultsMsg.textContent = 'No students match your search';
                container.appendChild(noResultsMsg);
              }
            } else if (noResultsMsg) {
              noResultsMsg.remove();
            }
          }
        }
        // END LINKING & SEARCH FIX

        // BEGIN LINKING & SEARCH FIX
        function selectStudentForLink(paymentId, studentId) {
          try {
            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === paymentId);

            if (!payment) {
              showNotification('‚ùå Payment not found', 'error');
              closeLinkStudentModal();
              return;
            }

            const students = getCachedStudents();
            const student = students.find(s => s.id === studentId);

            if (!student) {
              showNotification('‚ùå Student not found', 'error');
              closeLinkStudentModal();
              return;
            }

            // BEGIN CRITICAL BUG FIX - Payment ‚Üî Student Linking Logic
            // Update payment with manual link fields (resolver will compute derived fields)
            // - linkedStudentId: primary field for manual linking
            // - manuallyLinked: flag to activate manual resolution path
            // - resolutionSource: tracks how this link was created
            // - linkedAt: audit timestamp
            payment.linkedStudentId = studentId; // ‚úÖ Primary manual link field
            payment.manuallyLinked = true;
            payment.linkedAt = new Date().toISOString();
            payment.resolutionSource = 'manual';

            // Recompute resolution to update derived fields
            const resolution = resolvePaymentToStudent(payment, students);
            payment.derivedStudentId = resolution.studentId;
            payment.resolvedStudentName = resolution.studentName;
            payment.derivedStudentGroup = resolution.studentGroup;
            // END CRITICAL BUG FIX

            // Remove any conflict markers
            delete payment.conflictCandidates;

            // Save to localStorage
            PaymentStore.save(payments);

            // Trigger update event
            window.dispatchEvent(
              new CustomEvent('payments:updated', {
                detail: { payments: [payment] },
              })
            );

            // Sync to server
            syncWithServer({ paymentsChanged: [payment] });

            showNotification('‚úÖ Payment linked to student', 'success');
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error linking payment to student:', error);
            showNotification('‚ùå Failed to link payment', 'error');
          }

          closeLinkStudentModal();
        }
        // END LINKING & SEARCH FIX

        // Add alias to student
        async function showAddAliasModal(paymentId, studentId) {
          const payments = PaymentStore.getAll();
          const payment = payments.find(p => p.id === paymentId);
          const students = getCachedStudents();
          const student = students.find(s => s.id === studentId);

          if (!payment || !student) return;

          const payerName = payment.payerNameRaw || payment.payerName;

          const confirmed = await customConfirm(`Add alias "${payerName}" to ${student.name}?`, {
            title: 'Add Alias',
            icon: 'üè∑Ô∏è',
            okText: 'Add Alias',
          });

          if (confirmed) {
            if (!student.aliases) student.aliases = [];

            // Check if alias already exists (case-insensitive)
            const exists = student.aliases.some(a => normalizeForMatching(a) === normalizeForMatching(payerName));

            if (!exists) {
              const originalAliases = Array.isArray(student.aliases) ? [...student.aliases] : [];
              student.aliases.push(payerName);
              const saved = await saveStudent(student);
              if (!saved) {
                student.aliases = originalAliases;
                showNotification('‚ùå Failed to save alias to Supabase', 'error');
                return;
              }
              Object.assign(student, saved);
              window.dispatchEvent(new CustomEvent('students:updated', { detail: [student] }));
              syncWithServer({ studentsChanged: [student] });

              // Recompute all payment resolutions
              recomputePaymentResolutions();
              renderPaymentEmailsView();

              showNotification(`‚úÖ Added alias "${payerName}" to ${student.name}`, 'success');
            } else {
              showNotification('‚ö†Ô∏è Alias already exists', 'warning');
            }
          }
        }

        // Add new student from payment
        function showAddNewStudentFromPayment(paymentId) {
          const payments = PaymentStore.getAll();
          const payment = payments.find(p => p.id === paymentId);
          if (!payment) return;

          const payerName = payment.payerNameRaw || payment.payerName || '';
          const payerEmail = payment.payerEmailRaw || payment.studentEmail || '';

          // Pre-fill add student form
          openStudentManager();

          setTimeout(() => {
            const nameInput = document.getElementById('studentName');
            const emailInput = document.getElementById('studentEmail');
            const notesInput = document.getElementById('studentNotes');

            if (nameInput) nameInput.value = payerName;
            if (emailInput) emailInput.value = payerEmail;
            if (notesInput)
              notesInput.value = `Created from payment ${payment.id} on ${new Date().toLocaleDateString()}`;

            // Store payment ID for linking after save
            window._linkPaymentAfterCreate = paymentId;
          }, 500);
        }

        // Unlink payment from student
        function unlinkPaymentFromStudent(paymentId) {
          const payments = PaymentStore.getAll();
          const payment = payments.find(p => p.id === paymentId);

          if (payment) {
            delete payment.linkedStudentId;

            // Re-resolve using aliases
            const resolution = resolvePaymentToStudent(payment);
            payment.resolvedStudentName = resolution.studentName;
            payment.resolutionSource = resolution.source;

            PaymentStore.save(payments);
            syncWithServer({ paymentsChanged: [payment] });

            showNotification('üîì Student unlinked', 'success');
            renderPaymentEmailsView();
          }
        }

        // Resolve alias conflict
        function showResolveConflictModal(paymentId, conflicts) {
          showLinkToStudentModal(paymentId); // Reuse the link modal
        }

        // Listen for student updates to recompute aliases
        window.addEventListener('students:updated', function () {
          recomputePaymentResolutions();
          const modal = document.getElementById('groupManagerModal');
          if (!modal || modal.style.display !== 'block') {
            // Only re-render if not in group manager
            renderPaymentEmailsView();
          }
        });

        // ============================================================================

        // Utility functions
        function escapeHtml(text) {
          if (!text) return '';
          const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;',
          };
          return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function cleanPaymentMemoText(text) {
          if (!text) return '';

          let cleaned = String(text)
            .replace(/[^\x20-\x7E\n\r\t]/g, '')
            .replace(/\s+/g, ' ')
            .trim();

          // Remove footer text that might have been included in the message
          cleaned = cleaned
            .replace(/\*?\s*If\s+you'?d?\s+rather\s+not\s+follow\s+links.*/gi, '')
            .replace(/\*?\s*The\s+money\s+is\s+ready\s+for\s+use.*/gi, '')
            .replace(/\*?\s*Pay\s+it\s+forward.*/gi, '')
            .replace(/\*?\s*Thanks\s+for\s+using\s+Zelle.*/gi, '')
            .replace(/\*?\s*You\s+can\s+add\s+a\s+note.*/gi, '')
            .replace(/\*?\s*View\s+transaction\s+details.*/gi, '')
            .trim();

          // If the message is ONLY footer text, asterisks, or generic content, return empty string
          if (
            !cleaned ||
            cleaned.length < 3 ||
            /^[\*\s\-‚Äî.]+$/.test(cleaned) ||
            /^(The money|Pay it|If you|Thanks|You can|View)+$/i.test(cleaned)
          ) {
            return '';
          }

          return cleaned;
        }

        // Enhanced duplicate detection per developer command
        function buildPaymentDuplicateKey(payment) {
          if (!payment) return null;

          const amount = parseFloat(payment.amount);
          const payer = (payment.payerName || payment.senderName || '').toLowerCase().trim();

          // Use the actual transaction date from email, not the fetch date
          const dateSource = payment.emailDate || payment.date || payment.createdAt;
          const date = dateSource ? new Date(dateSource) : null;

          if (!payer || Number.isNaN(amount) || !date || Number.isNaN(date.getTime())) {
            console.warn('‚ö†Ô∏è Cannot build duplicate key - missing data:', { payer, amount, date });
            return null;
          }

          // Use date only (ignore time) for duplicate detection
          const dateKey = date.toISOString().split('T')[0];
          const key = `${dateKey}|${amount.toFixed(2)}|${payer}`;

          return key;
        }

        // Per developer command: Check if payment is duplicate by Gmail ID or composite key
        function isDuplicatePayment(gmailId, payment, existingPayments) {
          // Check 1: Gmail ID already exists
          const gmailIdExists = existingPayments.some(p => p.gmailId === gmailId || p.emailId === gmailId);
          if (gmailIdExists) {
            // Removed verbose log - only log summary at end of fetch
            return true;
          }

          // Check 2: Composite key (payer + amount + date)
          const compositeKey = buildPaymentDuplicateKey(payment);
          if (!compositeKey) return false;

          const compositeExists = existingPayments.some(p => {
            const existingKey = buildPaymentDuplicateKey(p);
            return existingKey === compositeKey;
          });

          if (compositeExists) {
            // Removed verbose log - only log summary at end of fetch
            return true;
          }

          return false;
        }

        /**
         * Global Currency Formatter
         * Formats any numeric amount with comma thousand separators and currency symbol
         * @param {number|string} amount - The amount to format
         * @param {string} symbol - Currency symbol (default: '$')
         * @returns {string} Formatted currency string in "x,xxx $" format
         * @example
         *   formatCurrency(1000) ‚Üí "1,000 $"
         *   formatCurrency(25000, '÷è') ‚Üí "25,000 ÷è"
         *   formatCurrency(-1200) ‚Üí "-1,200 $"
         */
        function formatCurrency(amount, symbol = '$') {
          const num = parseFloat(amount) || 0;
          const formatted = Math.abs(num).toLocaleString('en-US', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
          });
          const sign = num < 0 ? '-' : '';
          return `${sign}${formatted} ${symbol}`;
        }

        function formatDualCurrencyHTML(amountUSD, colorUSD = '#22c55e', colorAMD = '#94a3b8') {
          const usd = parseFloat(amountUSD) || 0;
          const amd = Math.round(usd * 387.5);
          return `<span class="amount-usd" style="color: ${colorUSD};">${formatCurrency(usd, '$')}</span> <span class="amount-amd" style="color: ${colorAMD};">‚Äî ${formatCurrency(amd, '÷è')}</span>`;
        }

        function updateMonthTotalsVisibility() {
          const totalsContainer = document.getElementById('monthTotalsData');
          const toggleIcon = document.getElementById('monthTotalsToggleIcon');
          const toggleBtn = document.getElementById('monthTotalsToggle');

          if (!totalsContainer || !toggleIcon || !toggleBtn) return;

          if (monthTotalsCollapsed) {
            totalsContainer.classList.add('collapsed');
            toggleIcon.textContent = '‚ñ∏';
            toggleBtn.title = 'Expand totals';
          } else {
            totalsContainer.classList.remove('collapsed');
            toggleIcon.textContent = '‚ñæ';
            toggleBtn.title = 'Collapse totals';
          }
        }

        function toggleMonthTotals() {
          monthTotalsCollapsed = !monthTotalsCollapsed;
          localStorage.setItem(UI_STATE_KEYS.MONTH_TOTALS_COLLAPSED, monthTotalsCollapsed.toString());
          updateMonthTotalsVisibility();
        }

        function updatePaymentProjectionStats(count, amount) {
          const countEl = document.getElementById('totalPaymentsCount');
          const amountEl = document.getElementById('totalPaymentsAmount');

          if (countEl) countEl.textContent = count;
          if (amountEl) amountEl.innerHTML = formatDualCurrencyHTML(amount);
        }

        function populateMonthSelector() {
          const paymentLog = PaymentStore.getAll();
          const selector = document.getElementById('monthSelector');
          if (!selector) return;

          // Get all unique months from payments
          const monthsSet = new Set();
          paymentLog.forEach(payment => {
            const emailDate = payment.emailDate || payment.transactionDate || payment.createdAt || payment.date;
            if (!emailDate) return;

            const paymentDate = new Date(emailDate);
            if (isNaN(paymentDate.getTime())) return;

            const monthKey = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}`;
            monthsSet.add(monthKey);
          });

          // Convert to array and sort (newest first)
          const months = Array.from(monthsSet).sort().reverse();

          // Build options
          const now = new Date();
          const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

          let html = '<option value="current">This Month</option>';

          months.forEach(monthKey => {
            if (monthKey === currentMonthKey) return; // Skip current month (already added)

            const [year, month] = monthKey.split('-');
            const date = new Date(parseInt(year), parseInt(month), 1);
            const monthName = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

            html += `<option value="${monthKey}">${monthName}</option>`;
          });

          html += '<option value="ytd">Year to Date</option>';
          html += '<option value="all" selected>All Time</option>';

          selector.innerHTML = html;
        }

        function updateMonthTotals() {
          const paymentLog = PaymentStore.getAll();
          const selector = document.getElementById('monthSelector');
          const selectedPeriod = selector ? selector.value : 'current';

          const now = new Date();
          const currentMonth = now.getMonth();
          const currentYear = now.getFullYear();

          let periodCount = 0;
          let periodTotal = 0;

          paymentLog.forEach(payment => {
            const isIgnored = payment.ignoredOnce || payment.ignorePermanently;
            if (isIgnored) return;

            const emailDate = payment.emailDate || payment.transactionDate || payment.createdAt || payment.date;
            if (!emailDate) return;

            const paymentDate = new Date(emailDate);
            if (isNaN(paymentDate.getTime())) return;

            let includePayment = false;

            if (selectedPeriod === 'current') {
              // This month only
              includePayment = paymentDate.getMonth() === currentMonth && paymentDate.getFullYear() === currentYear;
            } else if (selectedPeriod === 'ytd') {
              // Year to date
              includePayment = paymentDate.getFullYear() === currentYear;
            } else if (selectedPeriod === 'all') {
              // All time
              includePayment = true;
            } else if (selectedPeriod.includes('-')) {
              // Specific month (format: YYYY-MM)
              const [targetYear, targetMonth] = selectedPeriod.split('-').map(Number);
              includePayment = paymentDate.getMonth() === targetMonth && paymentDate.getFullYear() === targetYear;
            }

            if (includePayment) {
              periodCount++;
              periodTotal += parseFloat(payment.amount) || 0;
            }
          });

          // Update display with null checks
          const countEl = document.getElementById('monthTotalCount');
          const usdEl = document.getElementById('monthTotalUSD');
          const amdEl = document.getElementById('monthTotalAMD');

          if (countEl) countEl.textContent = periodCount.toLocaleString('en-US');
          if (usdEl) usdEl.textContent = formatCurrency(periodTotal, '$');
          if (amdEl) amdEl.textContent = formatCurrency(Math.round(periodTotal * 387.5), '÷è');

          updateMonthTotalsVisibility();
        }

        // Main render function
        function renderPaymentEmailsView() {
          if (paymentRenderRAF !== null) {
            cancelAnimationFrame(paymentRenderRAF);
          }
          paymentRenderRAF = requestAnimationFrame(() => {
            paymentRenderRAF = null;
            renderPaymentEmailsViewImmediate();
          });
        }

        function renderPaymentEmailsViewImmediate() {
          const renderToken = ++paymentRenderToken;
          const container = document.getElementById('paymentEmailsContent');
          if (!container) return;

          updateMonthTotalsVisibility();

          const paymentLog = PaymentStore.getAll();

          const filterDropdown = document.getElementById('paymentFilterDropdown');
          const filterValue = filterDropdown ? filterDropdown.value : 'all';

          let filteredPayments = paymentLog;
          if (filterValue === 'matched') {
            filteredPayments = paymentLog.filter(p => p.studentId && !p.ignoredOnce && !p.ignorePermanently);
          } else if (filterValue === 'unmatched') {
            filteredPayments = paymentLog.filter(p => !p.studentId && !p.ignoredOnce && !p.ignorePermanently);
          } else if (filterValue === 'ignored') {
            filteredPayments = paymentLog.filter(p => p.ignoredOnce || p.ignorePermanently);
          }

          if (filteredPayments.length === 0) {
            container.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">üìß</div>
            <p>No ${filterValue === 'all' ? '' : filterValue + ' '}payment records found</p>
          </div>
        `;
            updatePaymentProjectionStats(0, 0);
            updateMonthTotals();
            return;
          }

          let totalCount = 0;
          let totalAmount = 0;
          filteredPayments.forEach(payment => {
            if (!payment.ignoredOnce && !payment.ignorePermanently) {
              totalCount += 1;
              totalAmount += parseFloat(payment.amount) || 0;
            }
          });

          updatePaymentProjectionStats(totalCount, totalAmount);
          updateMonthTotals();

          const paymentsByDate = {};
          filteredPayments.forEach(payment => {
            const emailDate = payment.emailDate || payment.transactionDate || payment.createdAt || payment.date;
            if (!emailDate) {
              return;
            }

            const date = new Date(emailDate);
            if (Number.isNaN(date.getTime())) {
              return;
            }

            const dateKey = date.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            });

            if (!paymentsByDate[dateKey]) {
              paymentsByDate[dateKey] = {
                date,
                payments: [],
                total: 0,
              };
            }

            paymentsByDate[dateKey].payments.push(payment);

            if (!payment.ignoredOnce && !payment.ignorePermanently) {
              paymentsByDate[dateKey].total += parseFloat(payment.amount) || 0;
            }
          });

          const sortedDates = Object.keys(paymentsByDate).sort((a, b) => {
            return paymentsByDate[b].date - paymentsByDate[a].date;
          });

          if (sortedDates.length === 0) {
            container.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">üìß</div>
            <p>No payments with valid timestamps found</p>
          </div>
        `;
            addClickToMarkPaymentsViewed();
            return;
          }

          // BEGIN PAYMENT RECORDS ORDER & HIGHLIGHT FIX
          // Sort payments within each date group - NEWEST FIRST
          Object.values(paymentsByDate).forEach(dateGroup => {
            dateGroup.payments.sort((a, b) => {
              // Primary: Use emailDate/transactionDate (actual payment timestamp)
              const dateA = new Date(a.emailDate || a.transactionDate || a.createdAt || 0);
              const dateB = new Date(b.emailDate || b.transactionDate || b.createdAt || 0);

              const timeDiff = dateB - dateA;
              if (timeDiff !== 0) return timeDiff;

              // Secondary: If timestamps identical, use createdAt
              const createdA = new Date(a.createdAt || 0);
              const createdB = new Date(b.createdAt || 0);
              return createdB - createdA;
            });
          });
          // END PAYMENT RECORDS ORDER & HIGHLIGHT FIX

          container.innerHTML = `
        <div class="loading-state" style="padding: 32px; text-align: center; color: #94a3b8;">
          Rendering payments‚Ä¶
        </div>
      `;

          const studentsCache = getCachedStudents();
          const resolutionCache = new Map();

          const getResolutionForPayment = payment => {
            const cacheKey =
              payment.id ||
              `${payment.payerNameRaw || payment.payerName || ''}_${payment.amount || ''}_${payment.emailDate || payment.transactionDate || payment.createdAt || ''}`;
            if (resolutionCache.has(cacheKey)) {
              return resolutionCache.get(cacheKey);
            }
            const resolution = resolvePaymentToStudent(payment, studentsCache);
            resolutionCache.set(cacheKey, resolution);
            return resolution;
          };

          const DATE_CHUNK_SIZE = 2;
          let dateIndex = 0;

          const renderNextChunk = () => {
            if (renderToken !== paymentRenderToken) {
              return;
            }

            if (dateIndex === 0) {
              container.innerHTML = '';
            }

            const chunkDates = sortedDates.slice(dateIndex, dateIndex + DATE_CHUNK_SIZE);
            let chunkHtml = '';

            chunkDates.forEach(dateKey => {
              const dateData = paymentsByDate[dateKey];
              let rowsHtml = '';

              dateData.payments.forEach(payment => {
                const rawTimestamp = payment.emailDate || payment.transactionDate || payment.createdAt || '';
                let displayTime = '‚Äî';
                if (rawTimestamp) {
                  const timestampDate = new Date(rawTimestamp);
                  if (!Number.isNaN(timestampDate.getTime())) {
                    displayTime = timestampDate.toLocaleTimeString('en-US', {
                      hour: 'numeric',
                      minute: '2-digit',
                      hour12: true,
                    });
                  }
                }

                const amountUSD = parseFloat(payment.amount) || 0;
                const resolution = getResolutionForPayment(payment);
                const groupDisplay =
                  resolution.studentGroup ||
                  payment.derivedStudentGroup ||
                  payment.group ||
                  payment.studentGroup ||
                  '‚Äî';
                const payerNameRaw = payment.payerNameRaw || payment.payerName || '‚Äî';
                const studentNameResolved = resolution.studentName;
                const resolutionBadge =
                  resolution.source === 'conflict'
                    ? '<span style="background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.4); padding: 2px 5px; border-radius: 4px; color: #ef4444; font-size: 9px; font-weight: 700; margin-left: 4px; cursor: pointer;" onclick="event.stopPropagation(); showPaymentContextMenu(event, \'${payment.id}\')">CONFLICT</span>'
                    : '';

                const messageText = cleanPaymentMemoText(payment.message || payment.note || payment.memo || '');
                const messageDisplay = messageText ? messageText : '‚Äî';
                const isIgnored = payment.ignoredOnce || payment.ignorePermanently;
                const rowOpacity = isIgnored ? 'opacity: 0.4;' : '';
                const isNew =
                  payment.createdAt &&
                  Date.now() - new Date(payment.createdAt).getTime() < TIMING.NEW_PAYMENT_INDICATOR;
                const newIndicatorClass = isNew && !payment.viewed ? 'payment-row-new' : '';

                const amountAMD = Math.round(amountUSD * 387.5);

                rowsHtml += `
              <div class="${newIndicatorClass}" style="display: grid; grid-template-columns: 110px 200px 200px 80px 180px 1fr 40px; gap: 12px; padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 14px; color: #e5e7eb; transition: background 0.2s; ${rowOpacity}" onmouseover="this.style.background='rgba(255,255,255,.03)'" onmouseout="this.style.background='transparent'">
                <div style="color: #94a3b8;">${displayTime}</div>
                <div
                  ondblclick="showPaymentActionsPopup(event, '${payment.id}', '${escapeHtml(payerNameRaw).replace(/'/g, "\\'")}', ${amountUSD.toFixed(2)}, '${escapeHtml(messageText || '').replace(/'/g, "\\'")}', '${escapeHtml(studentNameResolved).replace(/'/g, "\\'")}', '${escapeHtml(resolution.studentId || '').replace(/'/g, "\\'")}');"
                  style="cursor: pointer; transition: 0.2s; color: white; font-weight: 400;"
                  onmouseover="this.style.color='var(--primary)'; this.style.fontWeight='700';"
                  onmouseout="this.style.color='white'; this.style.fontWeight='400';"
                  title="Double-click for actions"
                >${escapeHtml(payerNameRaw)}</div>
                <div style="font-weight: 600; color: white;">
                  ${
                    !resolution.studentId && resolution.source === 'none'
                      ? 'Unmatched'
                      : resolution.studentId
                        ? `<span
                      onclick="event.stopPropagation(); openStudentEditFromPayment('${resolution.studentId}');"
                      style="cursor: pointer; transition: 0.2s;"
                      onmouseover="this.style.color='var(--primary)'; this.style.textDecoration='underline';"
                      onmouseout="this.style.color='white'; this.style.textDecoration='none';"
                      title="Click to edit student"
                    >${escapeHtml(studentNameResolved)}${resolutionBadge}</span>`
                        : escapeHtml(studentNameResolved)
                  }
                  ${!resolution.studentId && resolution.source === 'none' ? '<div style="margin-top: 4px;"><span style="padding: 3px 8px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; color: #ef4444; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">Unmatched</span></div>' : ''}
                </div>
                <div style="font-weight: 600; color: #3b82f6; text-align: center;">${escapeHtml(groupDisplay)}</div>
                <div><span style="color: #22c55e; font-weight: 700;">${formatCurrency(amountUSD, '$')}</span> <span style="color: #94a3b8; font-size: 12.7px;">‚Äî ${formatCurrency(amountAMD, '÷è')}</span></div>
                <div style="color: var(--secondary); font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(messageDisplay)}">${escapeHtml(messageDisplay)}</div>
                <div
                  onclick="event.stopPropagation(); showPaymentContextMenu(event, '${payment.id}')"
                  style="display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0.5; font-size: 18px; font-weight: bold; transition: opacity 0.2s;"
                  onmouseover="this.style.opacity='1'"
                  onmouseout="this.style.opacity='0.5'"
                  title="Open menu"
                >‚ãÆ</div>
              </div>
            `;
              });

              chunkHtml += `
            <div style="margin-bottom: 32px;">
              <div style="display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.05)); border-left: 4px solid #3b82f6; border-radius: 8px; margin-bottom: 12px;">
                <span style="font-size: 16px; font-weight: 700; color: white;">${dateKey}</span>
                <span style="margin-left: auto; font-size: 14px; font-weight: 700; color: #e5e7eb;">
                  Total: <span style="color: #3b82f6; font-weight: 700;">${formatCurrency(dateData.total, '$')}</span> <span style="color: #94a3b8; font-size: 12.7px;">‚Äî ${formatCurrency(Math.round(dateData.total * 387.5), '÷è')}</span>
                </span>
              </div>
              <div style="background: transparent; border: 1px solid rgba(255,255,255,0.1); border-radius: 18px; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); box-shadow: 0 8px 28px rgba(0,0,0,0.35); overflow: hidden; transition: 0.25s ease-in-out;" onmouseover="this.style.borderColor='rgba(255,255,255,0.25)';" onmouseout="this.style.borderColor='rgba(255,255,255,0.1)';">
                <div style="display: grid; grid-template-columns: 110px 200px 200px 80px 180px 1fr 40px; gap: 12px; padding: 12px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; font-weight: 700; color: #94a3b8;">
                  <div>DATE</div>
                  <div>PAYER NAME</div>
                  <div>STUDENT NAME</div>
                  <div style="text-align:center;">GROUP</div>
                  <div>AMOUNT (USD ‚Äî AMD)</div>
                  <div>MESSAGE</div>
                  <div style="text-align: center;">‚ãÆ</div>
                </div>
                ${rowsHtml}
              </div>
            </div>
          `;
            });

            if (chunkHtml) {
              container.insertAdjacentHTML('beforeend', chunkHtml);
            }

            dateIndex += DATE_CHUNK_SIZE;

            if (dateIndex < sortedDates.length) {
              requestAnimationFrame(renderNextChunk);
            } else {
              addClickToMarkPaymentsViewed();
            }
          };

          requestAnimationFrame(renderNextChunk);
        }

        function addClickToMarkPaymentsViewed() {
          // One click clears ALL green blinking indicators
          const container = document.getElementById('paymentEmailsContent');
          const oldListener = container?._clickListener;
          if (oldListener) {
            container.removeEventListener('click', oldListener);
          }

          // Add new listener - click ANYWHERE in the payment records container
          const markAllPaymentsAsViewed = function () {
            const newPaymentRows = document.querySelectorAll('.payment-row-new');
            if (newPaymentRows.length === 0) return;

            // Mark all payments as viewed
            const payments = PaymentStore.getAll();
            let hasChanges = false;

            payments.forEach(payment => {
              if (
                !payment.viewed &&
                payment.createdAt &&
                Date.now() - new Date(payment.createdAt).getTime() < TIMING.NEW_PAYMENT_INDICATOR
              ) {
                payment.viewed = true;
                hasChanges = true;
              }
            });

            if (hasChanges) {
              PaymentStore.save(payments);

              // Remove animation class immediately from ALL green blinking rows
              newPaymentRows.forEach(row => {
                row.classList.remove('payment-row-new');
                row.style.animation = 'none';
                row.style.boxShadow = 'none';
              });

              // Remove this listener after first acknowledgment
              if (container) {
                container.removeEventListener('click', markAllPaymentsAsViewed);
                container._clickListener = null;
              }
            }
          };

          // Store reference and attach to container
          if (container) {
            container._clickListener = markAllPaymentsAsViewed;
            container.addEventListener('click', markAllPaymentsAsViewed, { once: false });
          }
          // END PAYMENT RECORDS ORDER & HIGHLIGHT FIX
        }

        // ============================================================================
        // GMAIL INTEGRATION - Enhanced for robust message retrieval
        // ============================================================================

        const GMAIL_CLIENT_ID = '67231383915-4kpdv0k6u517admvhl7jlejku7qtbsjj.apps.googleusercontent.com';
        const GMAIL_SCOPES =
          'https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send';
        const GMAIL_CONNECTION_KEY = 'gmail-connection'; // Per developer command spec

        // Enhanced Gmail connection with persistent token management
        function getGmailConnection() {
          const stored = localStorage.getItem(GMAIL_CONNECTION_KEY);
          if (!stored) return null;

          try {
            const connection = JSON.parse(stored);
            // Check if token is expired
            if (connection.expiry_date && Date.now() >= connection.expiry_date) {
              debugLog('Gmail token expired');
              localStorage.removeItem(GMAIL_CONNECTION_KEY);
              return null;
            }
            return connection;
          } catch (e) {
            console.error('Error parsing Gmail connection:', e);
            return null;
          }
        }

        function saveGmailConnection(token, expiresIn, userEmail = null) {
          const connection = {
            access_token: token,
            expiry_date: Date.now() + expiresIn * 1000,
            user_email: userEmail,
            connected_at: new Date().toISOString(),
          };

          localStorage.setItem(GMAIL_CONNECTION_KEY, JSON.stringify(connection));
          localStorage.setItem(STORAGE_KEYS.GMAIL_TOKEN, token);
          localStorage.setItem(STORAGE_KEYS.GMAIL_EXPIRY, connection.expiry_date.toString());

          gmailAccessToken = token;
          gmailTokenExpiry = connection.expiry_date.toString();
        }

        function clearGmailConnection() {
          localStorage.removeItem(GMAIL_CONNECTION_KEY);
          localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
          localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
          gmailAccessToken = null;
          gmailTokenExpiry = null;
        }

        // BEGIN PAYMENT RECORDS ORDER & HIGHLIGHT FIX
        // Gmail connection stability - check and refresh token automatically
        async function ensureGmailTokenValid() {
          if (!gmailAccessToken) return false;

          // Check if token is about to expire (within 5 minutes)
          const expiry = parseInt(gmailTokenExpiry || '0');
          const now = Date.now();
          const fiveMinutes = 5 * 60 * 1000;

          if (expiry && expiry - now < fiveMinutes) {
            debugLog('üîÑ Gmail token expiring soon, refreshing via Supabase...');

            try {
              // Call refresh token Edge Function
              const response = await fetch(`${SUPABASE_URL}/functions/v1/gmail-refresh-token`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
                },
                body: JSON.stringify({
                  userId: 'admin', // Replace with actual user ID if using auth
                }),
              });

              if (!response.ok) {
                throw new Error('Token refresh failed');
              }

              const { access_token, expires_at } = await response.json();

              // Calculate expires_in from expires_at
              const expiresIn = Math.floor((new Date(expires_at).getTime() - Date.now()) / 1000);

              // Save refreshed token
              saveGmailConnection(access_token, expiresIn);
              debugLog('‚úÖ Gmail token refreshed successfully');
              debugLog('New expiry:', new Date(expires_at).toLocaleString());

              return true;
            } catch (error) {
              console.error('‚ùå Token refresh failed:', error);

              // Token refresh failed - try to fetch current token from DB
              debugLog('üîÑ Attempting to fetch token from database...');

              try {
                const fetchResponse = await fetch(`${SUPABASE_URL}/functions/v1/gmail-get-token`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
                  },
                  body: JSON.stringify({ userId: 'admin' }),
                });

                if (fetchResponse.ok) {
                  const data = await fetchResponse.json();

                  if (data.success && !data.expired) {
                    gmailAccessToken = data.access_token;
                    gmailTokenExpiry = new Date(data.expires_at).getTime();

                    saveGmailConnection(data.access_token, Math.floor((gmailTokenExpiry - Date.now()) / 1000));
                    debugLog('‚úÖ Token fetched from database');

                    return true;
                  }
                }
              } catch (fetchError) {
                console.error('‚ùå Failed to fetch token from database:', fetchError);
              }

              // Both refresh and fetch failed - need to re-authenticate
              gmailAccessToken = null;
              localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
              localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
              updateGmailButtonState(false);

              showNotification('‚ö†Ô∏è Gmail connection expired. Please reconnect.', 'warning');
              return false;
            }
          }

          return true;
        }

        // Auto-check token validity every 30 minutes (token valid for 1 hour)
        setInterval(
          async () => {
            if (gmailAccessToken) {
              await ensureGmailTokenValid();
            }
          },
          30 * 60 * 1000
        );
        // END PAYMENT RECORDS ORDER & HIGHLIGHT FIX

        async function toggleGmailConnection() {
          if (gmailAccessToken) {
            // Disconnect
            const confirmed = await customConfirm(
              'Disconnect Gmail? This will stop automatic payment email checking.',
              {
                title: 'Disconnect Gmail',
                icon: 'üîå',
                okText: 'Disconnect',
                type: 'danger',
              }
            );

            if (confirmed) {
              localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
              localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
              gmailAccessToken = null;
              updateGmailButtonState(false);
              showNotification('Gmail disconnected', 'info');
            }
          } else {
            // Connect
            initiateGmailAuth();
          }
        }

        function initiateGmailAuth() {
          // Use the exact current origin to match what's in Google Cloud Console
          const redirectUri = window.location.origin;

          // Authorization code flow (supports refresh tokens)
          const authUrl =
            `https://accounts.google.com/o/oauth2/v2/auth?` +
            `client_id=${GMAIL_CLIENT_ID}&` +
            `redirect_uri=${encodeURIComponent(redirectUri)}&` +
            `response_type=code&` + // Changed from 'token' to 'code'
            `scope=${encodeURIComponent(GMAIL_SCOPES)}&` +
            `access_type=offline&` + // Request refresh token
            `prompt=consent`; // Force consent to get refresh token

          debugLog('‚ö†Ô∏è IMPORTANT: Make sure this redirect URI is authorized in Google Cloud Console:');
          debugLog('üîÑ Using authorization code flow with refresh token support');
          window.location.href = authUrl;
        }

        async function handleOAuthCallback() {
          const urlParams = new URLSearchParams(window.location.search);
          const code = urlParams.get('code');
          debugLog('üîç Checking for OAuth callback - code:', code ? 'Found' : 'None');

          if (code) {
            try {
              debugLog('üîÑ Exchanging authorization code for tokens...');

              // Exchange code for tokens via Supabase Edge Function
              const response = await fetch(`${SUPABASE_URL}/functions/v1/gmail-oauth-callback`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
                },
                body: JSON.stringify({
                  code: code,
                  userId: 'admin', // Replace with actual user ID if using auth
                }),
              });

              if (!response.ok) {
                const error = await response.text();
                throw new Error(`Token exchange failed: ${error}`);
              }

              const { access_token, expires_at } = await response.json();

              // Calculate expires_in from expires_at
              const expiresIn = Math.floor((new Date(expires_at).getTime() - Date.now()) / 1000);

              // Save token
              saveGmailConnection(access_token, expiresIn);
              updateGmailButtonState(true);
              showNotification('‚úÖ Gmail connected with refresh token! Auto-renewal enabled.', 'success');

              // Clear code from URL
              window.history.replaceState(null, '', window.location.pathname);

              // Auto-fetch payments
              debugLog('üì• Auto-fetching payments after connection...');
              setTimeout(() => refreshPayments(), 1000);
            } catch (error) {
              console.error('‚ùå OAuth callback error:', error);
              showNotification('‚ùå Failed to connect Gmail: ' + error.message, 'error');
              window.history.replaceState(null, '', window.location.pathname);
            }
          } else if (urlParams.get('error')) {
            // Handle OAuth errors
            const error = urlParams.get('error');
            const errorDesc = urlParams.get('error_description');
            console.error('‚ùå OAuth error:', error, errorDesc);
            showNotification(`Gmail connection failed: ${errorDesc || error}`, 'error');

            // Clear URL
            window.history.replaceState(null, '', window.location.pathname);
          }
        }

        function updateGmailButtonState(connected) {
          const btn = document.getElementById('gmailBtn');
          const text = document.getElementById('gmailBtnText');
          if (!btn || !text) {
            console.error('Gmail button elements not found');
            return;
          }

          if (connected) {
            btn.classList.add('connected');
            text.textContent = 'Gmail';
          } else {
            btn.classList.remove('connected');
            text.textContent = 'Gmail';
          }
        }

        async function refreshPayments() {
          // BEGIN PAYMENT RECORDS ORDER & HIGHLIGHT FIX
          // Check token validity before attempting sync
          const isValid = await ensureGmailTokenValid();
          if (!isValid || !gmailAccessToken) {
            showNotification('‚ö†Ô∏è Please connect Gmail first', 'warning');
            return;
          }
          // END PAYMENT RECORDS ORDER & HIGHLIGHT FIX

          // Show loading notification (no refresh button anymore)
          showNotification('üîç Checking for new payment emails...', 'info');

          try {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const afterDate = Math.floor(today.getTime() / 1000);

            const query = `from:usbank@notifications.usbank.com subject:Zelle after:${afterDate}`;
            const searchUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(query)}&maxResults=100`;

            const searchResponse = await fetch(searchUrl, {
              headers: { Authorization: `Bearer ${gmailAccessToken}` },
            });

            if (!searchResponse.ok) {
              if (searchResponse.status === 401) {
                localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
                localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
                gmailAccessToken = null;
                updateGmailButtonState(false);
                showNotification('üîí Gmail session expired. Please reconnect.', 'error');
                return;
              }
              throw new Error(`Gmail API error: ${searchResponse.status}`);
            }

            const searchData = await searchResponse.json();

            if (!searchData.messages || searchData.messages.length === 0) {
              showNotification('üì≠ No new payment emails found', 'info');
              return;
            }

            const existingPayments = PaymentStore.getAll();
            const existingPaymentsForCheck = [...existingPayments]; // Keep original for duplicate checking

            const payments = [];
            const processedGmailIds = new Set();

            for (const message of searchData.messages) {
              const messageUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages/${message.id}`;
              const messageResponse = await fetch(messageUrl, {
                headers: { Authorization: `Bearer ${gmailAccessToken}` },
              });

              if (messageResponse.ok) {
                const messageData = await messageResponse.json();
                const payment = parseZelleEmail(messageData);
                if (payment) {
                  // Check if already processed in this batch
                  if (processedGmailIds.has(payment.gmailId)) {
                    verboseLog(`‚ö†Ô∏è Skipped duplicate in current batch: ${payment.gmailId}`);
                    continue;
                  }

                  // Use enhanced duplicate detection against existing payments
                  if (isDuplicatePayment(payment.gmailId || payment.emailId, payment, existingPaymentsForCheck)) {
                    continue; // Skip duplicate (already logged in isDuplicatePayment)
                  }

                  payments.push(payment);
                  processedGmailIds.add(payment.gmailId);
                }
              }

              await new Promise(resolve => setTimeout(resolve, TIMING.API_DELAY));
            }

            if (payments.length > 0) {
              // Save new payments combined with existing ones
              const allPayments = [...payments, ...existingPayments];
              await PaymentStore.save(allPayments);

              // Recompute resolutions to populate group information
              await recomputePaymentResolutions();

              // Auto-process overpayments (adds credit, NO email sent automatically)
              await processOverpayments();

              // Log success per developer command

              // Dispatch update event per developer command
              window.dispatchEvent(
                new CustomEvent('payments:updated', {
                  detail: { count: payments.length, source: 'gmail-sync' },
                })
              );

              showNotification(`‚úÖ Added ${payments.length} new payment${payments.length > 1 ? 's' : ''}!`, 'success');
              renderPaymentEmailsView();
            } else {
              showNotification('‚úÖ All payments already synced', 'success');
            }
          } catch (error) {
            console.error('Error refreshing payments:', error);

            // Check if it's a network error
            if (error.message === 'Load failed' || error.message.includes('Failed to fetch')) {
              console.error('Network error details:', {
                message: error.message,
                tokenExists: !!gmailAccessToken,
                tokenExpiry: localStorage.getItem(STORAGE_KEYS.GMAIL_EXPIRY),
              });
              showNotification('‚ùå Network error. Check your internet connection and Gmail token.', 'error');
            } else {
              showNotification('‚ùå Error: ' + error.message, 'error');
            }
          }
          // Note: No button cleanup needed - refresh button removed from navbar
        }

        async function fetchTodaysEmails() {
          // Check token validity before attempting sync
          const isValid = await ensureGmailTokenValid();
          if (!isValid || !gmailAccessToken) {
            showNotification('‚ö†Ô∏è Please connect Gmail first', 'warning');
            return;
          }

          const btn = document.getElementById('syncBtn');
          if (!btn) {
            console.error('syncBtn element not found');
            return;
          }
          btn.disabled = true;
          const originalText = btn.innerHTML;
          btn.innerHTML = '‚è≥';

          try {
            showNotification("üîç Fetching today's payment emails...", 'info');

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const afterDate = Math.floor(today.getTime() / 1000);

            const query = `from:usbank@notifications.usbank.com subject:Zelle after:${afterDate}`;
            const searchUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(query)}&maxResults=100`;

            const searchResponse = await fetch(searchUrl, {
              headers: { Authorization: `Bearer ${gmailAccessToken}` },
            });

            if (!searchResponse.ok) {
              if (searchResponse.status === 401) {
                localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
                localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
                gmailAccessToken = null;
                updateGmailButtonState(false);
                throw new Error('Gmail session expired. Please reconnect.');
              }
              throw new Error(`Gmail API error: ${searchResponse.status}`);
            }

            const searchData = await searchResponse.json();

            if (!searchData.messages || searchData.messages.length === 0) {
              showNotification('üì≠ No payment emails found today', 'info');
              btn.disabled = false;
              btn.innerHTML = originalText;
              return;
            }

            const existingPayments = PaymentStore.getAll();
            const existingPaymentsForCheck = [...existingPayments]; // Keep original for duplicate checking

            const payments = [];
            const processedGmailIds = new Set();

            for (const message of searchData.messages) {
              const messageUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages/${message.id}`;
              const messageResponse = await fetch(messageUrl, {
                headers: { Authorization: `Bearer ${gmailAccessToken}` },
              });

              if (messageResponse.ok) {
                const messageData = await messageResponse.json();
                const payment = parseZelleEmail(messageData);
                if (payment) {
                  // Check if already processed in this batch
                  if (processedGmailIds.has(payment.gmailId)) {
                    verboseLog(`‚ö†Ô∏è Skipped duplicate in current batch: ${payment.gmailId}`);
                    continue;
                  }

                  // Use enhanced duplicate detection against existing payments
                  if (isDuplicatePayment(payment.gmailId || payment.emailId, payment, existingPaymentsForCheck)) {
                    continue; // Skip duplicate (already logged in isDuplicatePayment)
                  }

                  payments.push(payment);
                  processedGmailIds.add(payment.gmailId);
                }
              }

              await new Promise(resolve => setTimeout(resolve, TIMING.API_DELAY));
            }

            if (payments.length > 0) {
              const allPayments = [...payments, ...existingPayments];
              await PaymentStore.save(allPayments);
              await recomputePaymentResolutions();

              // Auto-process overpayments (adds credit, NO email sent automatically)
              await processOverpayments();

              showNotification(`‚úÖ Added ${payments.length} new payment${payments.length > 1 ? 's' : ''}!`, 'success');
              renderPaymentEmailsView();
            } else {
              showNotification("‚úÖ All today's payments already synced", 'success');
            }
          } catch (error) {
            console.error("Error fetching today's emails:", error);
            showNotification('‚ùå Error: ' + error.message, 'error');
          } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
          }
        }

        function parseZelleEmail(messageData) {
          try {
            const headers = messageData.payload.headers;
            const dateHeader = headers.find(h => h.name === 'Date');
            let emailDate = dateHeader ? new Date(dateHeader.value) : new Date();

            // Apply LA timezone offset correction if enabled
            emailDate = applyLAOffset(emailDate);

            // Extract email body (multiple sources)
            let bodyText = '';
            if (messageData.payload.body && messageData.payload.body.data) {
              bodyText = atob(messageData.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
            } else if (messageData.payload.parts) {
              const textPart = messageData.payload.parts.find(p => p.mimeType === 'text/plain');
              if (textPart && textPart.body && textPart.body.data) {
                bodyText = atob(textPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
              }
            }

            // Fallback to snippet if body is empty (per developer command)
            if (!bodyText && messageData.snippet) {
              bodyText = messageData.snippet;
            }

            if (!bodyText) {
              console.warn('‚ö†Ô∏è No body text or snippet available for email:', messageData.id);
              return null;
            }

            // DEVELOPER COMMAND: Only fetch Zelle emails credited to account 7073
            const bodyTextLower = bodyText.toLowerCase();

            // ‚úÖ Only fetch messages credited to your account (ending in 7073)
            const isCreditedTo7073 = bodyTextLower.includes('credited to account ending in: 7073');

            // ‚ùå Skip all others
            const isSentFrom7073 = bodyTextLower.includes('sent from account ending in: 7073');
            const isGenericDeposit = bodyTextLower.includes('your deposit of');
            const isGenericTransaction = bodyTextLower.includes('your transaction of');

            if (!isCreditedTo7073 || isSentFrom7073 || isGenericDeposit || isGenericTransaction) {
              return null;
            }

            // Parse amount - universal pattern
            const amountMatch = bodyText.match(/\$[\d,]+\.\d{2}/);
            const amount = amountMatch ? parseFloat(amountMatch[0].replace(/[$,]/g, '')) : 0;

            // Parse sender name - try multiple patterns
            let senderName = 'Unknown';

            // Pattern 1: "From: Name" (text/plain format with colon)
            let fromMatch = bodyText.match(/From:\s*([^\n]+)/i);
            if (fromMatch) {
              senderName = fromMatch[1].trim();
            } else {
              // Pattern 2: "from Name was deposited" (HTML format)
              fromMatch = bodyText.match(/from\s+([^\s].*?)(?:\s+was\s+deposited|\n|$)/i);
              if (fromMatch) {
                senderName = fromMatch[1].trim();
              }
            }

            // Parse memo/message - try multiple patterns
            let memo = '';
            let studentNameFromMessage = '';

            // Pattern 1: "Message from [Payer]: [Student Name]" (US Bank specific - extract student name)
            // STOP BEFORE footer text like "The money is ready", "Pay it forward", etc.
            let messageFromMatch = bodyText.match(
              /Message\s+from\s+[^:]+:\s*([A-Za-z\s,'"\-]+?)(?=\s*(?:The money|Pay it forward|If you'd|Thanks|You can add|View transaction|\n\n|$))/i
            );
            if (messageFromMatch) {
              studentNameFromMessage = messageFromMatch[1].trim();

              // Extra safety filter to remove any footer fragments
              studentNameFromMessage = studentNameFromMessage
                .replace(/(The money.*|Pay it forward.*|If you'd.*|Thanks.*|You can add.*|View transaction.*)/i, '')
                .trim();

              memo = studentNameFromMessage; // Use as memo too
              // Removed verbose log - footer extraction is normal operation
            } else {
              // Pattern 2: "Memo:" or "Message:" or "Note:" (text/plain format)
              let memoMatch = bodyText.match(/(?:Memo|Message|Note):\s*([^\n]+)/i);
              if (memoMatch) {
                memo = memoMatch[1].trim();
                // Clean footer from memo as well
                memo = memo
                  .replace(/(The money.*|Pay it forward.*|If you'd.*|Thanks.*|You can add.*|View transaction.*)/i, '')
                  .trim();
              }
            }

            if (!amount || !senderName) return null;

            // Enhanced student matching per developer command
            const students = getCachedStudents();
            let matchedStudent = null;
            let studentEmail = '';
            let groupId = '';

            // Priority 1: Use extracted student name from "Message from [payer]: [student]"
            if (studentNameFromMessage) {
              const searchName = studentNameFromMessage.toLowerCase().trim();

              // Try exact name match
              matchedStudent = students.find(s => s.name.toLowerCase() === searchName);

              // Try alias match if no exact match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  if (!s.aliases || s.aliases.length === 0) return false;
                  return s.aliases.some(alias => alias.toLowerCase().trim() === searchName);
                });
              }

              // Try partial match if still no match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  const nameLower = s.name.toLowerCase();
                  return nameLower.includes(searchName) || searchName.includes(nameLower);
                });
              }

              if (matchedStudent) {
              }
            }

            // Priority 2: If no student name extracted, try memo field
            if (!matchedStudent && memo) {
              const searchText = memo.toLowerCase().trim();

              // Exact name match
              matchedStudent = students.find(s => s.name.toLowerCase() === searchText);

              // Alias match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  if (!s.aliases || s.aliases.length === 0) return false;
                  return s.aliases.some(alias => alias.toLowerCase().trim() === searchText);
                });
              }

              // Partial name match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  const nameLower = s.name.toLowerCase();
                  return nameLower.includes(searchText) || searchText.includes(nameLower);
                });
              }

              if (matchedStudent) {
              }
            }

            // Priority 3: Try matching sender name as last resort
            if (!matchedStudent) {
              const senderLower = senderName.toLowerCase().trim();

              // Exact match
              matchedStudent = students.find(s => s.name.toLowerCase() === senderLower);

              // Alias match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  if (!s.aliases || s.aliases.length === 0) return false;
                  return s.aliases.some(alias => alias.toLowerCase().trim() === senderLower);
                });
              }

              // Partial match
              if (!matchedStudent) {
                matchedStudent = students.find(s => {
                  const nameLower = s.name.toLowerCase();
                  return nameLower.includes(senderLower) || senderLower.includes(nameLower);
                });
              }

              if (matchedStudent) {
              }
            }

            // Extract student email and group if matched
            if (matchedStudent) {
              studentEmail = matchedStudent.email || '';
              groupId = matchedStudent.groupId || '';
            } else {
            }

            // Determine final display names
            const finalStudentName = matchedStudent ? matchedStudent.name : 'Unmatched';
            const finalPayerName = senderName;

            // Final cleanup: If memo contains ONLY footer/generic text, set it to empty string
            let cleanMemo = memo || '';
            if (cleanMemo) {
              // Remove all known footer patterns
              cleanMemo = cleanMemo
                .replace(/\*\s*If\s+you'?d?\s+rather\s+not\s+follow\s+links.*/gi, '')
                .replace(/If\s+you'?d?\s+rather\s+not\s+follow\s+links.*/gi, '')
                .replace(/The\s+money\s+is\s+ready\s+for\s+use.*/gi, '')
                .replace(/Pay\s+it\s+forward.*/gi, '')
                .replace(/Thanks\s+for\s+using\s+Zelle.*/gi, '')
                .replace(/You\s+can\s+add\s+a\s+note.*/gi, '')
                .replace(/View\s+transaction\s+details.*/gi, '')
                .trim();

              // If nothing meaningful remains, set to empty
              if (cleanMemo.length < 3 || /^[*\s\-‚Äî.]+$/.test(cleanMemo)) {
                cleanMemo = '';
              }
            }

            // Create payment object with full resolution metadata
            const payment = {
              id: `payment-${messageData.id}`, // Use Gmail ID to prevent duplicates
              gmailId: messageData.id,
              amount,

              // Raw immutable data from email
              payerNameRaw: senderName,
              payerEmailRaw: null,
              memo: cleanMemo,
              message: cleanMemo,

              // Display fields (computed)
              payerName: finalPayerName,
              senderName: finalPayerName,
              studentName: finalStudentName,
              studentEmail: studentEmail,
              groupId: groupId,

              // Manual linking (not set during parsing - only via UI)
              linkedStudentId: null,
              manuallyLinked: false,

              // Automatic resolution metadata
              derivedStudentId: matchedStudent ? matchedStudent.id : null,
              resolvedStudentName: finalStudentName,
              derivedStudentGroup: matchedStudent ? matchedStudent.group || matchedStudent.groups || '' : '',
              resolutionSource: matchedStudent ? 'memo-match' : 'none',

              // Legacy/compatibility field
              studentId: matchedStudent ? matchedStudent.id : null,

              // Status tracking
              status: matchedStudent ? 'matched' : 'unmatched',
              viewed: false,
              ignoredOnce: false,
              ignorePermanently: false,

              // Timestamps
              emailDate: emailDate.toISOString(),
              date: emailDate.toISOString(),
              createdAt: new Date().toISOString(),
              linkedAt: null,
              dateModifiedAt: null,
            };

            return payment;
          } catch (error) {
            console.error('Error parsing Zelle email:', error);
            return null;
          }
        }

        // ============================================================================
        // ============================================================================
        // CLOUD SYNC (AUTOMATIC VIA SUPABASE)
        // ============================================================================

        // Supabase automatically syncs all data changes - no manual sync needed!
        // PaymentStore.save() now directly writes to Supabase cloud database

        async function syncToCloud() {
          // This function is kept for UI compatibility but sync is automatic
          showNotification('‚úÖ All data auto-syncs to Supabase cloud!', 'success');
        }

        async function loadFromCloud() {
          try {
            const payments = await PaymentStore.fetchAll();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error loading from cloud:', error);
            showNotification('‚ùå Failed to load data from cloud', 'error');
          }
        }

        // ============================================================================
        // PAYMENT ACTIONS POPUP
        // ============================================================================

        let currentPaymentPopupData = null;
        let savedPaymentDataForLinking = null; // PERSISTENT storage for linking operations
        let paymentRenderRAF = null;
        let paymentRenderToken = 0;
        let lastPopupOpenTime = 0; // Debounce double-click

        // BEGIN POPUP BACK & EXIT FIX
        function showPaymentActionsPopup(event, paymentId, payerName, amount, message, studentName, studentId) {
          if (event) event.stopPropagation();

          // Debounce: prevent multiple rapid opens
          const now = Date.now();
          if (now - lastPopupOpenTime < 300) return;
          lastPopupOpenTime = now;

          // Store payment data
          currentPaymentPopupData = {
            paymentId: paymentId,
            payerName: payerName,
            amount: amount,
            message: message,
            studentName: studentName,
            studentId: studentId,
          };

          // Update display with null checks
          const payerNameEl = document.getElementById('popupPayerName');
          const amountEl = document.getElementById('popupPaymentAmount');
          const messageEl = document.getElementById('popupPaymentMessage');
          const popup = document.getElementById('paymentActionsPopup');

          if (!payerNameEl || !amountEl || !messageEl || !popup) {
            console.error('Payment popup elements not found');
            showNotification('‚ùå UI error: Popup elements missing', 'error');
            return;
          }

          payerNameEl.textContent = payerName || '‚Äî';
          amountEl.innerHTML = formatDualCurrencyHTML(amount);
          messageEl.textContent = message || 'No message';

          // Register with PopupManager for Back button and click-outside
          if (window.PopupManager) {
            window.PopupManager.register('paymentActionsPopup', {
              hasBackButton: false, // No back button needed (top-level popup)
              closeOnOutsideClick: true,
              onClose: () => {
                currentPaymentPopupData = null;
                const aliasForm = document.getElementById('createAliasForm');
                const dateForm = document.getElementById('changeDateForm');
                if (aliasForm) aliasForm.style.display = 'none';
                if (dateForm) dateForm.style.display = 'none';
              },
            });
          }

          // Show backdrop and modal with fade-in
          const backdrop = document.getElementById('paymentActionsBackdrop');
          if (backdrop) {
            backdrop.style.display = 'block';
            backdrop.style.opacity = '0';
            backdrop.style.transition = 'opacity 0.25s ease';
            requestAnimationFrame(() => {
              backdrop.style.opacity = '1';
            });
          }

          popup.classList.add('active');
          popup.style.display = 'block';
          popup.style.opacity = '0';
          popup.style.transition = 'opacity 0.25s ease';
          requestAnimationFrame(() => {
            popup.style.opacity = '1';
          });
        }
        // END POPUP BACK & EXIT FIX

        function closePaymentActionsPopup() {
          const popup = document.getElementById('paymentActionsPopup');
          const backdrop = document.getElementById('paymentActionsBackdrop');

          // Fade out
          if (popup) {
            popup.style.opacity = '0';
          }
          if (backdrop) {
            backdrop.style.opacity = '0';
          }

          // Hide after transition
          setTimeout(() => {
            if (popup) {
              popup.classList.remove('active');
              popup.style.display = 'none';
            }
            if (backdrop) {
              backdrop.style.display = 'none';
            }

            currentPaymentPopupData = null;

            // Hide any open forms
            const aliasForm = document.getElementById('createAliasForm');
            const dateForm = document.getElementById('changeDateForm');
            if (aliasForm) aliasForm.style.display = 'none';
            if (dateForm) dateForm.style.display = 'none';
          }, 250);
        }

        async function ignoreThisPayment() {
          if (!currentPaymentPopupData) {
            showNotification('‚ùå No payment selected', 'error');
            return;
          }

          const confirmed = await customConfirm(
            `Ignore this payment from "${currentPaymentPopupData.payerName}"?\n\nIt will be excluded from totals.`,
            {
              title: 'Ignore Payment',
              icon: '‚ö†Ô∏è',
              okText: 'Ignore',
              type: 'danger',
            }
          );

          if (!confirmed) return;

          try {
            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === currentPaymentPopupData.paymentId);

            if (!payment) {
              showNotification('‚ùå Payment not found', 'error');
              return;
            }

            // Mark as ignored
            payment.ignoredOnce = true;
            payment.ignoredAt = new Date().toISOString();

            await PaymentStore.save(payments);

            // Auto-synced to Supabase cloud

            showNotification('üö´ Payment ignored', 'success');
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error ignoring payment:', error);
            showNotification('‚ùå Failed to ignore payment', 'error');
          }
        }

        async function deleteThisPayment() {
          if (!currentPaymentPopupData) {
            showNotification('‚ùå No payment selected', 'error');
            return;
          }

          const confirmed = await customConfirm(
            `Delete this payment from "${currentPaymentPopupData.payerName}"?\n\nAmount: ${formatCurrency(currentPaymentPopupData.amount, '$')}\n\nThis action cannot be undone!`,
            {
              title: 'Delete Payment',
              icon: 'üóëÔ∏è',
              okText: 'Delete',
              type: 'danger',
            }
          );

          if (!confirmed) return;

          try {
            let payments = PaymentStore.getAll();
            const paymentIndex = payments.findIndex(p => p.id === currentPaymentPopupData.paymentId);

            if (paymentIndex === -1) {
              showNotification('‚ùå Payment not found', 'error');
              return;
            }

            // Remove the payment
            payments.splice(paymentIndex, 1);
            await PaymentStore.save(payments);

            // Auto-synced to Supabase cloud

            showNotification('üóëÔ∏è Payment deleted', 'success');
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error deleting payment:', error);
            showNotification('‚ùå Failed to delete payment', 'error');
          }
        }

        function showCreateAliasForm() {
          const form = document.getElementById('createAliasForm');
          const input = document.getElementById('aliasStudentName');
          if (form) form.style.display = 'block';
          if (input) {
            input.value = '';
            input.focus();
          }
        }

        function hideCreateAliasForm() {
          const form = document.getElementById('createAliasForm');
          if (form) form.style.display = 'none';
        }

        async function saveAlias() {
          const studentName = document.getElementById('aliasStudentName').value.trim();
          if (!studentName) {
            showNotification('‚ö†Ô∏è Please enter a student name', 'warning');
            return;
          }

          if (!currentPaymentPopupData) {
            showNotification('‚ùå No payment selected', 'error');
            return;
          }

          try {
            const payerName = currentPaymentPopupData.payerName;

            // Find the student in Student Manager
            const students = getCachedStudents();
            const student = students.find(s => s.name.toLowerCase().trim() === studentName.toLowerCase().trim());

            // BEGIN CRITICAL BUG FIX - saveAlias() Logic Flow
            if (student) {
              // Initialize aliases array if needed
              if (!student.aliases) {
                student.aliases = [];
              }

              // Check if alias already exists
              const aliasExists = student.aliases.some(a => a.toLowerCase().trim() === payerName.toLowerCase().trim());

              if (aliasExists) {
                showNotification('‚ö†Ô∏è Alias already exists for this student', 'warning');
                return;
              }

              // Add new alias
              const originalAliases = Array.isArray(student.aliases) ? [...student.aliases] : [];
              student.aliases.push(payerName);

              // Persist alias change for this student only
              const saved = await saveStudent(student);
              if (!saved) {
                student.aliases = originalAliases;
                showNotification('‚ùå Failed to save alias to Supabase', 'error');
                return;
              }
              Object.assign(student, saved);
              window.dispatchEvent(new CustomEvent('students:updated', { detail: [student] }));
            } else {
              showNotification('‚ùå Student not found', 'error');
              return;
            }
            // END CRITICAL BUG FIX

            // Create alias mapping (for backward compatibility)
            const aliases = JSON.parse(localStorage.getItem('payment-aliases') || '{}');
            const normalizedPayer = payerName.toLowerCase().trim();
            aliases[normalizedPayer] = studentName;
            localStorage.setItem('payment-aliases', JSON.stringify(aliases));

            // Update all payments from this payer
            const payments = PaymentStore.getAll();
            let updatedCount = 0;

            payments.forEach(payment => {
              if (payment.payerName && payment.payerName.toLowerCase().trim() === normalizedPayer) {
                payment.studentName = studentName;
                payment.aliasMatched = true;
                updatedCount++;
              }
            });

            PaymentStore.save(payments);

            // Recompute to update group information
            recomputePaymentResolutions();

            showNotification(
              `‚úÖ Alias created! Updated ${updatedCount} payment${updatedCount > 1 ? 's' : ''}`,
              'success'
            );
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error saving alias:', error);
            showNotification('‚ùå Failed to save alias', 'error');
          }
        }

        function showChangeDateForm() {
          const form = document.getElementById('changeDateForm');
          if (!form) {
            console.error('changeDateForm element not found');
            return;
          }
          form.style.display = 'block';

          if (currentPaymentPopupData) {
            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === currentPaymentPopupData.paymentId);
            if (payment && payment.emailDate) {
              const date = new Date(payment.emailDate);
              const dateInput = document.getElementById('newEmailDate');
              if (dateInput) {
                dateInput.value = date.toISOString().split('T')[0];
              }
            }
          }
        }

        function hideChangeDateForm() {
          const form = document.getElementById('changeDateForm');
          if (form) form.style.display = 'none';
        }

        async function saveNewDate() {
          const newDateStr = document.getElementById('newEmailDate').value;
          if (!newDateStr) {
            showNotification('‚ö†Ô∏è Please select a date', 'warning');
            return;
          }

          if (!currentPaymentPopupData) {
            showNotification('‚ùå No payment selected', 'error');
            return;
          }

          // Validate date is reasonable (not too far in future, not before 2020)
          const newDate = new Date(newDateStr + 'T12:00:00');
          const minDate = new Date('2020-01-01');
          const maxDate = new Date();
          maxDate.setDate(maxDate.getDate() + 365); // Allow up to 1 year in future

          if (newDate < minDate) {
            showNotification('‚ö†Ô∏è Date cannot be before 2020', 'warning');
            return;
          }

          if (newDate > maxDate) {
            showNotification('‚ö†Ô∏è Date cannot be more than 1 year in the future', 'warning');
            return;
          }

          try {
            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === currentPaymentPopupData.paymentId);

            if (!payment) {
              showNotification('‚ùå Payment not found', 'error');
              return;
            }

            // Store original date if not already stored
            if (!payment.originalEmailDate) {
              payment.originalEmailDate = payment.emailDate;
            }

            // Update the email date
            payment.emailDate = newDate.toISOString();
            payment.dateModified = true;
            payment.dateModifiedAt = new Date().toISOString();

            PaymentStore.save(payments);

            showNotification(`‚úÖ Date changed to ${newDate.toLocaleDateString()}`, 'success');
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error changing date:', error);
            showNotification('‚ùå Failed to change date', 'error');
          }
        }

        async function ignoreAllFromPayer() {
          if (!currentPaymentPopupData) {
            showNotification('‚ùå No payment selected', 'error');
            return;
          }

          const payerName = currentPaymentPopupData.payerName;

          const confirmed = await customConfirm(
            `Ignore ALL payments from "${payerName}"?\n\nThis will affect all payments from this payer.`,
            {
              title: 'Ignore All Payments',
              icon: 'üö´',
              okText: 'Ignore All',
              type: 'danger',
            }
          );

          if (!confirmed) return;

          try {
            const payments = PaymentStore.getAll();
            const normalizedPayer = payerName.toLowerCase().trim();
            let ignoredCount = 0;

            payments.forEach(payment => {
              if (payment.payerName && payment.payerName.toLowerCase().trim() === normalizedPayer) {
                payment.ignorePermanently = true;
                payment.ignoredAt = new Date().toISOString();
                ignoredCount++;
              }
            });

            PaymentStore.save(payments);

            showNotification(
              `üö´ Ignored ${ignoredCount} payment${ignoredCount !== 1 ? 's' : ''} from "${payerName}"`,
              'success'
            );
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error ignoring payer:', error);
            showNotification('‚ùå Failed to ignore payments', 'error');
          }
        }

        // BEGIN POPUP BACK & EXIT FIX
        async function linkPaymentToStudent() {
          if (!currentPaymentPopupData) {
            console.error('‚ùå No payment selected in currentPaymentPopupData');
            console.error('‚ùå This means the popup was closed or data was cleared');
            showNotification('‚ùå No payment selected. Please double-click a payment row first.', 'error');
            return;
          }

          // CRITICAL: Save to persistent storage IMMEDIATELY before opening any modals
          savedPaymentDataForLinking = { ...currentPaymentPopupData };

          // Get list of students
          const students = getCachedStudents();

          if (!students || students.length === 0) {
            showNotification('‚ö†Ô∏è No students found. Create students first.', 'warning');
            return;
          }

          // Create student list items for search
          const studentListHTML = students
            .map(s => {
              const escapedId = String(s.id).replace(/'/g, "\\'").replace(/"/g, '&quot;');
              const escapedName = String(s.name).replace(/'/g, "\\'");
              const escapedEmail = String(s.email || '').replace(/'/g, "\\'");
              // Add aliases for search filtering
              const aliases = Array.isArray(s.aliases) ? s.aliases : [];
              const aliasesLower = aliases.map(a => a.toLowerCase()).join('|');
              const aliasesDisplay =
                aliases.length > 0
                  ? `<div style="color: #94a3b8; font-size: 11px; margin-top: 2px;">Also known as: ${aliases.join(', ')}</div>`
                  : '';

              return `<div class="student-search-item" data-student-id="${escapedId}" data-student-name="${s.name.toLowerCase()}" data-student-email="${(s.email || '').toLowerCase()}" data-student-aliases="${aliasesLower}" onclick="event.stopPropagation(); selectStudentFromSearch('${escapedId}')" style="padding: 12px 14px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05); transition: all 0.2s; border-radius: 6px; margin-bottom: 4px; pointer-events: auto;" onmouseover="this.style.background='rgba(138,180,255,0.15)'" onmouseout="this.style.background='transparent'">
          <div style="color: white; font-weight: 600; font-size: 14px;">${s.name}</div>
          ${s.email ? `<div style="color: #94a3b8; font-size: 12px; margin-top: 2px;">${s.email}</div>` : ''}
          ${aliasesDisplay}
        </div>`;
            })
            .join('');

          const modalHTML = `
        <div id="linkStudentModalBackdrop" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 10000; backdrop-filter: blur(6px); cursor: pointer;" onclick="closeLinkStudentModal()"></div>
        <div id="linkStudentModal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%); border: 2px solid rgba(138,180,255,.3); border-radius: 16px; padding: 24px; min-width: 400px; max-width: 500px; z-index: 10001; box-shadow: 0 20px 60px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.25s ease;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; position: relative;">
            <button onclick="closeLinkStudentModal()" style="background: none; border: none; color: #94a3b8; opacity: 0.8; font-size: 14px; font-weight: 600; cursor: pointer; padding: 8px 12px; margin-right: auto; transition: all 0.2s ease; pointer-events: auto; position: absolute; left: 0; top: 0;" onmouseover="this.style.opacity='1'; this.style.textShadow='0 0 8px rgba(148,163,184,0.6)'" onmouseout="this.style.opacity='0.8'; this.style.textShadow='none'">‚Üê Back</button>
            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 700; flex: 1; text-align: center;">Link to Student</h3>
            <button onclick="closeLinkStudentModal()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; opacity: 0.7; transition: opacity 0.2s; pointer-events: auto;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">&times;</button>
          </div>
          <p style="margin: 0 0 12px 0; color: #94a3b8; font-size: 14px;">Search and select a student to link this payment to:</p>

          <input type="text" id="linkStudentSearchInput" placeholder="Search by name, email, or payment alias..." style="width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 14px; margin-bottom: 16px; outline: none; pointer-events: auto;" oninput="debouncedFilterStudentSearch()" onkeydown="if(event.key==='Escape'){closeLinkStudentModal();}" autofocus>

          <div id="studentSearchResults" style="max-height: 320px; overflow-y: auto; margin-bottom: 16px; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
            ${studentListHTML}
          </div>

          <div style="display: flex; gap: 10px;">
            <button onclick="closeLinkStudentModal()" style="flex: 1; padding: 12px; background: rgba(255,255,255,0.1); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: all 0.2s; pointer-events: auto;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">Cancel</button>
          </div>
        </div>
      `;

          // Remove any existing modal
          const existingModal = document.getElementById('linkStudentModal');
          const existingBackdrop = document.getElementById('linkStudentModalBackdrop');
          if (existingModal) existingModal.remove();
          if (existingBackdrop) existingBackdrop.remove();

          // Add modal to page
          document.body.insertAdjacentHTML('beforeend', modalHTML);

          // Register with PopupManager
          if (window.PopupManager) {
            window.PopupManager.register('linkStudentModal', {
              hasBackButton: false, // We have our own back button in the HTML
              closeOnOutsideClick: true,
              onBack: closeLinkStudentModal,
              parent: 'paymentActionsPopup',
            });
          }

          // Fade in
          requestAnimationFrame(() => {
            const modal = document.getElementById('linkStudentModal');
            const backdrop = document.getElementById('linkStudentModalBackdrop');
            if (backdrop) {
              backdrop.style.display = 'block';
              backdrop.style.opacity = '0';
              requestAnimationFrame(() => {
                backdrop.style.opacity = '1';
              });
            }
            if (modal) {
              modal.style.opacity = '1';
            }
          });

          // Focus search input
          setTimeout(() => {
            const input = document.getElementById('linkStudentSearchInput');
            if (input) input.focus();
          }, 100);
        }
        // END POPUP BACK & EXIT FIX

        // BEGIN SEARCH FIX - Search by name, email, AND aliases
        function filterStudentSearch() {
          const input = document.getElementById('linkStudentSearchInput');
          const filter = input ? input.value.toLowerCase().trim() : '';
          const items = document.querySelectorAll('.student-search-item');

          let visibleCount = 0;
          items.forEach(item => {
            const studentName = item.getAttribute('data-student-name') || '';
            const studentEmail = item.getAttribute('data-student-email') || '';
            const studentAliases = item.getAttribute('data-student-aliases') || '';
            const textContent = item.textContent.toLowerCase();

            // Search in name, email, aliases, or visible text
            const matches =
              !filter ||
              studentName.includes(filter) ||
              studentEmail.includes(filter) ||
              studentAliases.includes(filter) ||
              textContent.includes(filter);

            if (matches) {
              item.style.display = 'block';
              visibleCount++;
            } else {
              item.style.display = 'none';
            }
          });

          // Show message if no results
          const resultsContainer = document.getElementById('studentSearchResults');
          if (resultsContainer && visibleCount === 0 && filter) {
            if (!document.getElementById('noStudentsMessage')) {
              resultsContainer.insertAdjacentHTML(
                'beforeend',
                '<div id="noStudentsMessage" style="padding: 20px; text-align: center; color: #94a3b8; font-size: 14px;">No students match your search</div>'
              );
            }
          } else {
            const noMsg = document.getElementById('noStudentsMessage');
            if (noMsg) noMsg.remove();
          }
        }
        // END SEARCH FIX

        function selectStudentFromSearch(studentId) {
          confirmLinkStudent(studentId);
        }

        function closeLinkStudentModal() {
          const modal = document.getElementById('linkStudentModal');
          const backdrop = document.getElementById('linkStudentModalBackdrop');

          if (modal && backdrop) {
            // BEGIN POPUP BACK & EXIT FIX
            // Fade out before removing
            modal.style.opacity = '0';
            backdrop.style.opacity = '0';

            setTimeout(() => {
              modal.remove();
              backdrop.remove();
              window.PopupManager?.activePopups?.delete('linkStudentModal');
            }, 250);
            // END POPUP BACK & EXIT FIX
          }
        }

        // ============================================================
        // SEND ALIAS ADDED EMAIL TO STUDENT
        // ============================================================
        async function sendAliasAddedEmail(student, aliasAdded) {
          try {
            verboseLog('[AliasEmail] üìß Sending alias added email to:', student.name, 'Alias:', aliasAdded);

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.error('[AliasEmail] ‚ùå Email system iframe not found');
              return { success: false, error: 'Email system not loaded' };
            }

            // Send message to email system iframe
            emailFrame.contentWindow.postMessage(
              {
                action: 'sendAliasAddedEmail',
                student: {
                  name: student.name,
                  email: student.email,
                  id: student.id,
                },
                aliasAdded: aliasAdded,
                timestamp: new Date().toISOString(),
              },
              '*'
            );

            verboseLog('[AliasEmail] ‚úÖ Message sent to email system iframe');

            // Wait for response from email system
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Email timeout'));
              }, 30000); // 30 second timeout

              const handler = event => {
                if (event.data.action === 'aliasEmailSent') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  verboseLog('[AliasEmail] ‚úÖ Received confirmation from email system');
                  resolve({ success: true, data: event.data });
                } else if (event.data.action === 'aliasEmailError') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  console.error('[AliasEmail] ‚ùå Email error:', event.data.error);
                  resolve({ success: false, error: event.data.error });
                }
              };

              window.addEventListener('message', handler);
            });
          } catch (error) {
            console.error('[AliasEmail] ‚ùå Error sending alias email:', error);
            return { success: false, error: error.message };
          }
        }
        // ============================================================

        // ============================================================
        // EMAIL CONFIRMATION MODAL - REQUIRED FOR ALL EMAILS
        // ============================================================
        async function confirmEmailSend(emailType, recipientName, recipientEmail, preview) {
          return new Promise(resolve => {
            const modal = document.createElement('div');
            modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 99999;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
          `;

            modal.innerHTML = `
            <div style="background: linear-gradient(135deg, #1a1f35 0%, #0f1629 100%);
              border: 2px solid #3b82f6; border-radius: 16px;
              padding: 32px; width: 800px; height: 85vh; display: flex; flex-direction: column;
              box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
              <h2 style="color: #fff; margin: 0 0 16px 0; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 28px;">üìß</span>
                <span>Confirm Email Send</span>
              </h2>
              <div style="background: rgba(59,130,246,0.15); padding: 16px; border-radius: 8px;
                margin-bottom: 20px; border: 1px solid rgba(59,130,246,0.3); flex-shrink: 0;">
                <div style="color: #93c5fd; font-size: 14px; margin-bottom: 8px;">
                  <strong>Type:</strong> ${emailType}
                </div>
                <div style="color: #93c5fd; font-size: 14px; margin-bottom: 8px;">
                  <strong>To:</strong> ${recipientName}
                </div>
                <div style="color: #60a5fa; font-size: 13px;">
                  <strong>Email:</strong> ${recipientEmail}
                </div>
              </div>
              <div style="background: rgba(255,255,255,0.05); padding: 16px; border-radius: 8px;
                overflow-y: auto; margin-bottom: 20px; font-size: 13px; flex: 1;
                color: #cbd5e1; border: 1px solid rgba(255,255,255,0.1);">
                ${preview}
              </div>
              <div style="display: flex; gap: 12px; justify-content: flex-end; flex-shrink: 0;">
                <button id="cancelEmailBtn" style="padding: 12px 24px; background: rgba(239, 68, 68, 0.2);
                  border: 1px solid #ef4444; border-radius: 8px; color: #fca5a5;
                  font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  ‚ùå Cancel
                </button>
                <button id="sendEmailBtn" style="padding: 12px 24px; background: #3b82f6;
                  border: none; border-radius: 8px; color: #fff; font-weight: 600; cursor: pointer;
                  transition: all 0.2s; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);">
                  ‚úÖ Send Email
                </button>
              </div>
            </div>
          `;

            document.body.appendChild(modal);

            const cancelBtn = document.getElementById('cancelEmailBtn');
            const sendBtn = document.getElementById('sendEmailBtn');

            cancelBtn.onmouseenter = () => (cancelBtn.style.background = 'rgba(239, 68, 68, 0.3)');
            cancelBtn.onmouseleave = () => (cancelBtn.style.background = 'rgba(239, 68, 68, 0.2)');

            sendBtn.onmouseenter = () => {
              sendBtn.style.background = '#2563eb';
              sendBtn.style.transform = 'translateY(-1px)';
            };
            sendBtn.onmouseleave = () => {
              sendBtn.style.background = '#3b82f6';
              sendBtn.style.transform = 'translateY(0)';
            };

            cancelBtn.onclick = () => {
              modal.remove();
              verboseLog('[EmailConfirmation] ‚ùå User cancelled email send');
              resolve(false);
            };

            sendBtn.onclick = () => {
              modal.remove();
              verboseLog('[EmailConfirmation] ‚úÖ User confirmed email send');
              resolve(true);
            };
          });
        }

        // ============================================================
        // SEND CREDIT ADDED EMAIL TO STUDENT
        // ============================================================
        async function sendCreditAddedEmail(student, creditAmount, newBalance, reason = 'Extra payment received') {
          try {
            verboseLog('[CreditEmail] üìß Sending credit added email to:', student.name, 'Amount:', creditAmount);

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.error('[CreditEmail] ‚ùå Email system iframe not found');
              return { success: false, error: 'Email system not loaded' };
            }

            // Send message to email system iframe
            emailFrame.contentWindow.postMessage(
              {
                action: 'sendCreditAddedEmail',
                student: {
                  name: student.name,
                  email: student.email,
                  id: student.id,
                },
                creditAmount: creditAmount,
                newBalance: newBalance,
                reason: reason,
                timestamp: new Date().toISOString(),
              },
              '*'
            );

            verboseLog('[CreditEmail] ‚úÖ Message sent to email system iframe');

            // Wait for response from email system
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Email timeout'));
              }, 30000); // 30 second timeout

              const handler = event => {
                if (event.data.action === 'creditAddedEmailSent') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  verboseLog('[CreditEmail] ‚úÖ Received confirmation from email system');
                  resolve({ success: true, data: event.data });
                } else if (event.data.action === 'creditAddedEmailError') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  console.error('[CreditEmail] ‚ùå Email error:', event.data.error);
                  resolve({ success: false, error: event.data.error });
                }
              };

              window.addEventListener('message', handler);
            });
          } catch (error) {
            console.error('[CreditEmail] ‚ùå Error sending credit added email:', error);
            return { success: false, error: error.message };
          }
        }

        // ============================================================
        // SEND CREDIT APPLIED EMAIL TO STUDENT
        // ============================================================
        async function sendCreditAppliedEmail(student, classDate, amountDeducted, newBalance) {
          try {
            verboseLog('[CreditEmail] üìß Sending credit applied email to:', student.name, 'Class:', classDate);

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.error('[CreditEmail] ‚ùå Email system iframe not found');
              return { success: false, error: 'Email system not loaded' };
            }

            // Send message to email system iframe
            emailFrame.contentWindow.postMessage(
              {
                action: 'sendCreditAppliedEmail',
                student: {
                  name: student.name,
                  email: student.email,
                  id: student.id,
                },
                classDate: classDate,
                amountDeducted: amountDeducted,
                newBalance: newBalance,
                timestamp: new Date().toISOString(),
              },
              '*'
            );

            verboseLog('[CreditEmail] ‚úÖ Message sent to email system iframe');

            // Wait for response from email system
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Email timeout'));
              }, 30000); // 30 second timeout

              const handler = event => {
                if (event.data.action === 'creditAppliedEmailSent') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  verboseLog('[CreditEmail] ‚úÖ Received confirmation from email system');
                  resolve({ success: true, data: event.data });
                } else if (event.data.action === 'creditAppliedEmailError') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  console.error('[CreditEmail] ‚ùå Email error:', event.data.error);
                  resolve({ success: false, error: event.data.error });
                }
              };

              window.addEventListener('message', handler);
            });
          } catch (error) {
            console.error('[CreditEmail] ‚ùå Error sending credit applied email:', error);
            return { success: false, error: error.message };
          }
        }

        // ============================================================
        // SEND MANUAL CREDIT EDIT EMAIL TO STUDENT
        // ============================================================
        async function sendCreditManualEditEmail(student, oldBalance, newBalance) {
          try {
            verboseLog('[CreditEmail] üìß Sending manual credit edit email to:', student.name);

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.error('[CreditEmail] ‚ùå Email system iframe not found');
              return { success: false, error: 'Email system not loaded' };
            }

            // Send message to email system iframe
            emailFrame.contentWindow.postMessage(
              {
                action: 'sendCreditManualEditEmail',
                student: {
                  name: student.name,
                  email: student.email,
                  id: student.id,
                },
                oldBalance: oldBalance,
                newBalance: newBalance,
                timestamp: new Date().toISOString(),
              },
              '*'
            );

            verboseLog('[CreditEmail] ‚úÖ Message sent to email system iframe');

            // Wait for response from email system
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Email timeout'));
              }, 30000); // 30 second timeout

              const handler = event => {
                if (event.data.action === 'creditManualEditEmailSent') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  verboseLog('[CreditEmail] ‚úÖ Received confirmation from email system');
                  resolve({ success: true, data: event.data });
                } else if (event.data.action === 'creditManualEditEmailError') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  console.error('[CreditEmail] ‚ùå Email error:', event.data.error);
                  resolve({ success: false, error: event.data.error });
                }
              };

              window.addEventListener('message', handler);
            });
          } catch (error) {
            console.error('[CreditEmail] ‚ùå Error sending manual credit edit email:', error);
            return { success: false, error: error.message };
          }
        }
        // ============================================================

        async function confirmLinkStudent(studentId) {
          if (!studentId) {
            showNotification('‚ö†Ô∏è Please select a student', 'warning');
            return;
          }

          // CRITICAL FIX: Try multiple sources for payment data
          // 1. First try current popup data
          // 2. Fall back to persistent saved data
          // 3. If both are null, fail gracefully
          let paymentDataSnapshot = currentPaymentPopupData ? { ...currentPaymentPopupData } : null;

          if (!paymentDataSnapshot && savedPaymentDataForLinking) {
            debugLog('‚ö†Ô∏è currentPaymentPopupData was null, using savedPaymentDataForLinking');
            paymentDataSnapshot = { ...savedPaymentDataForLinking };
          }

          if (!paymentDataSnapshot) {
            console.error('‚ùå No payment data available from any source');
            console.error('   - currentPaymentPopupData:', currentPaymentPopupData);
            console.error('   - savedPaymentDataForLinking:', savedPaymentDataForLinking);
            showNotification('‚ùå No payment selected', 'error');
            closeLinkStudentModal();
            return;
          }

          try {
            const students = getCachedStudents();

            // Convert studentId to number for comparison (it comes from HTML as string)
            const studentIdNum = parseInt(studentId, 10);

            const student = students.find(s => s.id === studentIdNum);

            if (!student) {
              console.error(
                '‚ùå Student not found. ID:',
                studentIdNum,
                'Available:',
                students.map(s => ({ id: s.id, name: s.name }))
              );
              showNotification('‚ùå Student not found', 'error');
              return;
            }

            // BEGIN CRITICAL BUG FIX - Payment ‚Üî Student Linking Logic
            // Update payment with student link using correct field names:
            // - linkedStudentId: for manual linking (checked first by resolver)
            // - manuallyLinked: flag to trigger manual resolution path
            // - linkedAt: timestamp for audit trail
            const payments = PaymentStore.getAll();
            const payment = payments.find(p => p.id === paymentDataSnapshot.paymentId);

            if (!payment) {
              showNotification('‚ùå Payment not found', 'error');
              return;
            }

            payment.linkedStudentId = student.id; // ‚úÖ Correct field for manual linking
            payment.manuallyLinked = true;
            payment.linkedAt = new Date().toISOString();
            payment.resolutionSource = 'manual';

            // Add payer name to student's alias if not already there
            const payerName = payment.payerName || payment.fromName || '';
            let aliasWasAdded = false;
            let addedAlias = '';

            if (payerName && payerName.trim()) {
              const currentAliases = student.aliases || [];
              const normalizedPayerName = payerName.trim().toLowerCase();
              const normalizedStudentName = student.name.toLowerCase();

              debugLog('üîç Normalized payer:', normalizedPayerName);

              // Only add if payer name is different from student name and not already in aliases
              const aliasExists = currentAliases.some(alias => alias.toLowerCase() === normalizedPayerName);

              if (normalizedPayerName !== normalizedStudentName && !aliasExists) {
                const originalAliases = Array.isArray(currentAliases) ? [...currentAliases] : [];
                student.aliases = [...originalAliases, payerName.trim()];

                const savedAliasUpdate = await saveStudent(student);
                if (!savedAliasUpdate) {
                  student.aliases = originalAliases;
                  showNotification('‚ùå Failed to save alias to Supabase', 'error');
                } else {
                  Object.assign(student, savedAliasUpdate);
                  window.dispatchEvent(new CustomEvent('students:updated', { detail: [student] }));
                  aliasWasAdded = true;
                  addedAlias = payerName.trim();
                  debugLog('‚úÖ Alias added successfully:', addedAlias);
                }
              } else {
                debugLog('‚è≠Ô∏è Skipped adding alias (already exists or same as student name)');
              }
            } else {
            }

            // Compute derived fields immediately (before saving)
            const resolution = resolvePaymentToStudent(payment, students);
            payment.derivedStudentId = resolution.studentId;
            payment.resolvedStudentName = resolution.studentName;
            payment.derivedStudentGroup = resolution.studentGroup;
            payment.studentName = student.name; // Set studentName for calendar lookup

            PaymentStore.save(payments);
            // END CRITICAL BUG FIX

            // ============================================================
            // CHECK FOR EXTRA PAYMENT ‚Üí CREATE CREDIT
            // ============================================================
            let creditWasAdded = false;
            let creditAddedAmount = 0;

            const paymentAmount = parseFloat(payment.amount) || 0;
            const pricePerClass = parseFloat(student.pricePerClass) || 0;

            verboseLog('[Credit] üí∞ Payment amount:', paymentAmount, 'Price per class:', pricePerClass);

            // Calculate unpaid classes for this student
            const allClasses = (student.attendance || []).filter(a => a.attended);
            const studentPayments = payments.filter(p => {
              const resolution = resolvePaymentToStudent(p, students);
              return resolution.studentId === student.id;
            });

            // Count how many classes are already paid (by payment records or credit)
            let unpaidClassCount = 0;
            for (const cls of allClasses) {
              const dateStr = cls.date;
              const isPaidByPayment = studentPayments.some(p => {
                const pDate = new Date(p.emailDate || p.transactionDate || p.createdAt);
                const pDateStr = pDate.toISOString().split('T')[0];
                return pDateStr === dateStr;
              });
              const isPaidByCredit = window.CreditPaymentManager?.getCreditPayment(student.id, dateStr);

              if (!isPaidByPayment && !isPaidByCredit) {
                unpaidClassCount++;
              }
            }

            verboseLog('[Credit] üìä Unpaid classes:', unpaidClassCount);

            // DISABLED: Auto-credit feature removed per user request
            // If payment amount > price per class AND no unpaid classes, add excess to credit
            if (false && paymentAmount > pricePerClass && unpaidClassCount === 0) {
              creditAddedAmount = paymentAmount;
              const oldBalance = parseFloat(student.balance) || 0;
              const newBalance = oldBalance + creditAddedAmount;

              student.balance = newBalance;

              console.log(
                '[Credit] üí≥ Adding to credit:',
                creditAddedAmount,
                'Old balance:',
                oldBalance,
                'New balance:',
                newBalance
              );

              // Save updated balance to Supabase
              const savedStudent = await saveStudent(student);
              if (savedStudent) {
                Object.assign(student, savedStudent);
                window.dispatchEvent(new CustomEvent('students:updated', { detail: [student] }));
                creditWasAdded = true;

                // Send credit added email
                if (student.email) {
                  verboseLog('[Credit] üìß Sending credit added email...');
                  const emailResult = await sendCreditAddedEmail(
                    student,
                    creditAddedAmount,
                    newBalance,
                    'Extra payment received - no unpaid classes'
                  );

                  if (emailResult.success) {
                    showNotification(
                      `üí≥ $${creditAddedAmount.toFixed(2)} added to credit for ${student.name}`,
                      'success'
                    );
                    showNotification(`üìß Credit notification sent to ${student.email}`, 'success');
                    verboseLog('[Credit] ‚úÖ Credit email sent successfully');
                  } else {
                    showNotification(
                      `üí≥ $${creditAddedAmount.toFixed(2)} added to credit for ${student.name}`,
                      'success'
                    );
                    showNotification(`‚ö†Ô∏è Credit added but email failed: ${emailResult.error}`, 'warning');
                    console.error('[Credit] ‚ùå Email failed:', emailResult.error);
                  }
                } else {
                  showNotification(
                    `üí≥ $${creditAddedAmount.toFixed(2)} added to credit for ${student.name}`,
                    'success'
                  );
                }
              } else {
                showNotification('‚ùå Failed to save credit balance', 'error');
                student.balance = oldBalance; // Revert
              }
            }
            // ============================================================

            // Recompute payment resolutions
            recomputePaymentResolutions();

            // Fire payments:updated event so calendar refreshes
            window.dispatchEvent(
              new CustomEvent('payments:updated', {
                detail: payments,
              })
            );

            // Send email and show notifications if alias was added
            if (aliasWasAdded && addedAlias && student.email) {
              showNotification(`‚úÖ Alias added for ${student.name} (payer: ${addedAlias})`, 'success');

              // Send email notification to student
              verboseLog('[AliasLink] üìß Sending alias added email...');
              const emailResult = await sendAliasAddedEmail(student, addedAlias);

              if (emailResult.success) {
                showNotification(`üìß Email sent to ${student.email}`, 'success');
                verboseLog('[AliasLink] ‚úÖ Email sent successfully');
              } else {
                showNotification(`‚ö†Ô∏è Alias added but email failed: ${emailResult.error}`, 'warning');
                console.error('[AliasLink] ‚ùå Email failed:', emailResult.error);
              }
            } else {
              // No alias was added (already existed or same as student name)
              showNotification(`‚úÖ Payment linked to ${student.name}`, 'success');
            }

            // ============================================================
            // SEND PAYMENT RECEIPT EMAIL
            // ============================================================
            if (student.email) {
              verboseLog('[PaymentReceipt] üìß Sending payment receipt email...');
              const paymentAmount = parseFloat(payment.amount) || 0;
              const paymentDate = payment.emailDate || payment.transactionDate || payment.createdAt;
              const currentBalance = parseFloat(student.balance) || 0;

              const emailResult = await sendPaymentReceiptEmail(student, paymentAmount, paymentDate, currentBalance);

              if (emailResult.success) {
                showNotification(`üìß Payment receipt sent to ${student.email}`, 'success');
                verboseLog('[PaymentReceipt] ‚úÖ Email sent successfully');
              } else {
                showNotification(`‚ö†Ô∏è Payment linked but receipt email failed: ${emailResult.error}`, 'warning');
                console.error('[PaymentReceipt] ‚ùå Email failed:', emailResult.error);
              }
            }
            // ============================================================

            // Clear persistent storage after successful link
            savedPaymentDataForLinking = null;
            debugLog('üßπ Cleared savedPaymentDataForLinking after successful link');

            closeLinkStudentModal();
            closePaymentActionsPopup();
            renderPaymentEmailsView();
          } catch (error) {
            console.error('Error linking payment:', error);
            showNotification('‚ùå Failed to link payment', 'error');
            // Clear persistent storage on error too
            savedPaymentDataForLinking = null;
          }
        }

        // Open student edit from payment record click
        function openStudentEditFromPayment(studentId) {
          if (!studentId) return;

          // Open Student Manager modal
          openStudentManager();

          // Wait for modal to render, then trigger edit
          setTimeout(() => {
            const studentCard = document.querySelector(`[data-student-id="${studentId}"]`);
            if (studentCard) {
              // Scroll into view
              studentCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

              // Highlight the card briefly
              studentCard.style.transition = 'all 0.3s ease';
              studentCard.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.5)';
              studentCard.style.transform = 'scale(1.02)';

              // Toggle into edit mode
              setTimeout(() => {
                toggleInlineEdit(studentId);

                // Remove highlight after edit opens
                setTimeout(() => {
                  studentCard.style.boxShadow = '';
                  studentCard.style.transform = '';
                }, 500);
              }, 300);
            } else {
              showNotification('‚ö†Ô∏è Student not found', 'warning');
            }
          }, 300);
        }

        // Close popup when clicking outside
        document.addEventListener('click', function (event) {
          const popup = document.getElementById('paymentActionsPopup');
          if (popup && popup.classList.contains('active') && !popup.contains(event.target)) {
            closePaymentActionsPopup();
          }

          // Note: fullSyncModal has its own close buttons, no need for click-outside-to-close
        });

        // ============================================================================
        // FULL SYNC FUNCTIONALITY
        // ============================================================================

        function openFullSyncDatePicker() {
          const modal = document.getElementById('fullSyncModal');
          if (!modal) {
            console.error('fullSyncModal element not found');
            showNotification('‚ùå UI error: Modal not found', 'error');
            return;
          }

          // BEGIN POPUP BACK & EXIT FIX
          // Register with PopupManager
          window.PopupManager.register('fullSyncModal', {
            hasBackButton: false, // Top-level modal
            closeOnOutsideClick: true,
            onClose: closeFullSyncDatePicker,
          });

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'block';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX

          // Set default dates
          const today = new Date();
          const toDateInput = document.getElementById('fullSyncToDate');
          if (toDateInput) {
            toDateInput.value = today.toISOString().split('T')[0];
          }

          // Default from date is July 1, 2024 (already set in HTML)
        }

        function setFullSyncThisWeek() {
          const today = new Date();
          const dayOfWeek = today.getDay();
          const monday = new Date(today);
          monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));

          document.getElementById('fullSyncFromDate').value = monday.toISOString().split('T')[0];
          document.getElementById('fullSyncToDate').value = today.toISOString().split('T')[0];
        }

        function setFullSyncThisMonth() {
          const today = new Date();
          const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);

          document.getElementById('fullSyncFromDate').value = firstDay.toISOString().split('T')[0];
          document.getElementById('fullSyncToDate').value = today.toISOString().split('T')[0];
        }

        function setFullSyncLastMonth() {
          const today = new Date();
          const firstDayLastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
          const lastDayLastMonth = new Date(today.getFullYear(), today.getMonth(), 0);

          document.getElementById('fullSyncFromDate').value = firstDayLastMonth.toISOString().split('T')[0];
          document.getElementById('fullSyncToDate').value = lastDayLastMonth.toISOString().split('T')[0];
        }

        function closeFullSyncDatePicker() {
          const modal = document.getElementById('fullSyncModal');
          if (!modal) return;

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('fullSyncModal');
          }, 250);
          // END POPUP BACK & EXIT FIX
        }

        async function performFullSync() {
          const fromDateInput = document.getElementById('fullSyncFromDate');
          const toDateInput = document.getElementById('fullSyncToDate');

          if (!fromDateInput || !toDateInput) {
            console.error('Date input elements not found');
            showNotification('‚ùå UI error: Date inputs missing', 'error');
            return;
          }

          let fromDateStr = fromDateInput.value;
          let toDateStr = toDateInput.value;

          // DEFENSIVE FIX: Ensure inputs have values with smart defaults
          if (!fromDateStr || !toDateStr) {
            // If toDate is missing, default to today
            if (!toDateStr) {
              toDateStr = new Date().toISOString().split('T')[0];
              toDateInput.value = toDateStr;
            }
            // If fromDate is missing, default to one month ago
            if (!fromDateStr) {
              const defaultFrom = new Date();
              defaultFrom.setMonth(defaultFrom.getMonth() - 1);
              fromDateStr = defaultFrom.toISOString().split('T')[0];
              fromDateInput.value = fromDateStr;
            }
            debugLog('üìÖ Applied default dates - From:', fromDateStr, 'To:', toDateStr);
          }

          if (!fromDateStr || !toDateStr) {
            showNotification('‚ö†Ô∏è Please select both dates', 'warning');
            return;
          }

          // Check token validity before attempting full sync
          const isValid = await ensureGmailTokenValid();
          if (!isValid || !gmailAccessToken) {
            showNotification('‚ö†Ô∏è Please connect Gmail first', 'warning');
            closeFullSyncDatePicker();
            return;
          }

          const fromDate = new Date(fromDateStr);
          const toDate = new Date(toDateStr);

          if (fromDate > toDate) {
            showNotification('‚ö†Ô∏è From date must be before To date', 'warning');
            return;
          }

          closeFullSyncDatePicker();

          const btn = document.getElementById('fullSyncBtn');
          const text = document.getElementById('fullSyncBtnText');

          if (!btn || !text) {
            console.error('Full sync button elements not found');
            showNotification('‚ùå UI error: Button elements missing', 'error');
            return;
          }

          btn.disabled = true;
          text.textContent = 'Syncing...';

          try {
            // REDESIGNED DATE RANGE LOGIC
            // Gmail's after: is INCLUSIVE (gets emails from this date forward)
            // Gmail's before: is EXCLUSIVE (gets emails up to but not including this date)
            // Solution: Use after:YYYY/MM/DD and before:NEXT_DAY to include the end date

            const formatGmailDate = date => {
              const year = date.getFullYear();
              const month = String(date.getMonth() + 1).padStart(2, '0');
              const day = String(date.getDate()).padStart(2, '0');
              return `${year}/${month}/${day}`;
            };

            const afterDate = formatGmailDate(fromDate);

            // Add 1 day to toDate for exclusive 'before:' parameter
            const beforeDate = new Date(toDate);
            beforeDate.setDate(beforeDate.getDate() + 1);
            const beforeDateStr = formatGmailDate(beforeDate);

            console.log('ÔøΩ FULL SYNC - Date Range:');

            showNotification(
              `üîç Syncing ${fromDate.toLocaleDateString()} to ${toDate.toLocaleDateString()}...`,
              'info'
            );

            // Build Gmail search query
            const query = `from:usbank@notifications.usbank.com subject:Zelle after:${afterDate} before:${beforeDateStr}`;

            // Fetch all messages with pagination
            let allMessages = [];
            let pageToken = null;

            do {
              const searchUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(query)}&maxResults=500${pageToken ? `&pageToken=${pageToken}` : ''}`;

              const searchResponse = await fetch(searchUrl, {
                headers: { Authorization: `Bearer ${gmailAccessToken}` },
              });

              if (!searchResponse.ok) {
                if (searchResponse.status === 401) {
                  localStorage.removeItem(STORAGE_KEYS.GMAIL_TOKEN);
                  localStorage.removeItem(STORAGE_KEYS.GMAIL_EXPIRY);
                  gmailAccessToken = null;
                  updateGmailButtonState(false);
                  throw new Error('Gmail session expired. Please reconnect.');
                }
                throw new Error(`Gmail API error: ${searchResponse.status}`);
              }

              const searchData = await searchResponse.json();

              if (searchData.messages) {
                allMessages = allMessages.concat(searchData.messages);
                text.textContent = `Found ${allMessages.length}...`;
              }

              pageToken = searchData.nextPageToken;
            } while (pageToken);

            if (allMessages.length === 0) {
              showNotification('üì≠ No Zelle emails found in this date range', 'info');
              btn.disabled = false;
              text.textContent = 'Full Sync';
              return;
            }

            // Process messages and remove duplicates
            text.textContent = `Processing ${allMessages.length} emails...`;

            const existingPayments = PaymentStore.getAll();
            const existingGmailIds = new Set(existingPayments.map(p => p.gmailId).filter(Boolean));

            const newPayments = [];
            const skippedDuplicates = [];
            const processedInBatch = new Set();
            let invalidEmails = 0;

            for (let i = 0; i < allMessages.length; i++) {
              const message = allMessages[i];

              if (i % 10 === 0 || i === allMessages.length - 1) {
                text.textContent = `Processing ${i + 1}/${allMessages.length}...`;
              }

              try {
                const messageUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages/${message.id}`;
                const messageResponse = await fetch(messageUrl, {
                  headers: { Authorization: `Bearer ${gmailAccessToken}` },
                });

                if (!messageResponse.ok) {
                  console.warn(`‚ö†Ô∏è Failed to fetch message ${message.id}: ${messageResponse.status}`);
                  invalidEmails++;
                  continue;
                }

                const messageData = await messageResponse.json();
                const payment = parseZelleEmail(messageData);

                if (!payment) {
                  // Email didn't match Zelle criteria (wrong account, outgoing, etc.)
                  invalidEmails++;
                  continue;
                }

                // Check if Gmail ID already exists in database
                if (existingGmailIds.has(payment.gmailId)) {
                  skippedDuplicates.push(payment.gmailId);
                  continue;
                }

                // Check if Gmail ID was already processed in this batch
                if (processedInBatch.has(payment.gmailId)) {
                  console.warn(`‚ö†Ô∏è Duplicate in batch: ${payment.gmailId}`);
                  skippedDuplicates.push(payment.gmailId);
                  continue;
                }

                // Valid new payment
                newPayments.push(payment);
                processedInBatch.add(payment.gmailId);
              } catch (error) {
                console.error(`‚ùå Error processing message ${message.id}:`, error);
                invalidEmails++;
              }

              // Rate limiting
              if (i < allMessages.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 50));
              }
            }

            // Summary

            if (newPayments.length > 0) {
              // Debug: Log all new payment Gmail IDs before saving
              newPayments.forEach((p, idx) => {});

              // Save new payments
              const allPayments = [...existingPayments, ...newPayments];

              // Debug: Check for Gmail ID duplicates in the combined array
              const gmailIdCounts = {};
              allPayments.forEach(p => {
                if (p.gmailId) {
                  gmailIdCounts[p.gmailId] = (gmailIdCounts[p.gmailId] || 0) + 1;
                }
              });

              const duplicateGmailIds = Object.entries(gmailIdCounts).filter(([_, count]) => count > 1);
              if (duplicateGmailIds.length > 0) {
                console.error('‚ùå DUPLICATE GMAIL IDs DETECTED BEFORE SAVE:');
                duplicateGmailIds.forEach(([gmailId, count]) => {
                  console.error(`   Gmail ID ${gmailId} appears ${count} times`);
                  const dupes = allPayments.filter(p => p.gmailId === gmailId);
                  dupes.forEach((p, idx) => {
                    console.error(`     ${idx + 1}. ${p.payerName} ($${p.amount}) - Payment ID: ${p.id}`);
                  });
                });
              }

              await PaymentStore.save(allPayments);

              // Recompute resolutions
              await recomputePaymentResolutions();

              const totalAmount = newPayments.reduce((sum, p) => sum + p.amount, 0);
              showNotification(
                `‚úÖ Added ${newPayments.length} payment${newPayments.length > 1 ? 's' : ''}! Total: ${formatCurrency(totalAmount, '$')}`,
                'success'
              );
              renderPaymentEmailsView();
            } else {
              showNotification('‚úÖ All payments already synced', 'success');
            }
          } catch (error) {
            console.error('‚ùå Full sync error:', error);
            showNotification(`‚ùå Sync failed: ${error.message}`, 'error');
          } finally {
            btn.disabled = false;
            text.textContent = 'Full Sync';
          }
        }

        // ============================================================================
        // AUTO-REFRESH FUNCTIONALITY
        // ============================================================================

        let autoRefreshInterval = null;
        let autoRefreshEnabled = localStorage.getItem('paymentEmailAutoRefresh') === 'true';

        function toggleAutoRefresh() {
          autoRefreshEnabled = !autoRefreshEnabled;
          localStorage.setItem('paymentEmailAutoRefresh', autoRefreshEnabled.toString());

          const toggleBtn = document.getElementById('autoRefreshToggle');
          if (!toggleBtn) {
            console.error('autoRefreshToggle button not found');
            return;
          }

          if (autoRefreshEnabled) {
            toggleBtn.classList.add('auto-refresh-active');
            toggleBtn.title = 'Auto-refresh ON (every 30s) - Click to disable';
            startAutoRefresh();
            showNotification('‚úÖ Auto-refresh enabled (every 30 seconds)', 'success');
          } else {
            toggleBtn.classList.remove('auto-refresh-active');
            toggleBtn.title = 'Auto-refresh OFF - Click to enable';
            stopAutoRefresh();
            showNotification('‚è∏Ô∏è Auto-refresh disabled', 'info');
          }
        }

        function startAutoRefresh() {
          stopAutoRefresh();
          autoRefreshInterval = setInterval(() => {
            // Don't auto-refresh if Gmail is not connected
            if (!getGmailConnection()) {
              debugLog('‚è∏Ô∏è Skipping auto-refresh - Gmail not connected');
              return;
            }
            debugLog('üîÑ Auto-refreshing payments...');
            refreshPayments();
          }, TIMING.AUTO_REFRESH_INTERVAL);
        }

        function stopAutoRefresh() {
          if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
          }
        }

        // ============================================================================
        // NOTIFICATIONS SYSTEM
        // ============================================================================

        // Global notification system (toast notifications)
        function showNotification(message, type = 'info') {
          // DISABLED - Notifications removed per user request
          return;
        }

        // ============================================================================
        // SETTINGS MENU
        // ============================================================================

        function toggleSettingsMenu() {
          const menu = document.getElementById('settingsMenu');
          if (!menu) return;
          menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function (e) {
          const settingsBtn = document.getElementById('settingsBtn');
          const menu = document.getElementById('settingsMenu');

          if (settingsBtn && menu && !settingsBtn.contains(e.target) && !menu.contains(e.target)) {
            menu.style.display = 'none';
          }
        });

        // Open Email System in modal
        function openEmailSystem() {
          // Close settings menu
          const menu = document.getElementById('settingsMenu');
          if (menu) menu.style.display = 'none';

          // Create modal backdrop
          const backdrop = document.createElement('div');
          backdrop.id = 'emailSystemBackdrop';
          backdrop.style.cssText =
            'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; padding: 20px;';

          // Create modal container
          const modal = document.createElement('div');
          modal.id = 'emailSystemModal';
          modal.style.cssText =
            'background: white; border-radius: 16px; width: 100%; max-width: 1400px; height: 90vh; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.5); position: relative;';

          // Create close button
          const closeBtn = document.createElement('button');
          closeBtn.innerHTML = '‚úï';
          closeBtn.style.cssText =
            'position: absolute; top: 16px; right: 16px; z-index: 10001; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;';
          closeBtn.onmouseover = () => (closeBtn.style.background = 'rgba(0,0,0,0.7)');
          closeBtn.onmouseout = () => (closeBtn.style.background = 'rgba(0,0,0,0.5)');
          closeBtn.onclick = closeEmailSystem;

          // Create iframe to load email system
          const iframe = document.createElement('iframe');
          iframe.src = 'email-system-complete.html?v=' + Date.now();
          iframe.style.cssText = 'width: 100%; height: 100%; border: none; border-radius: 16px;';

          // Assemble modal
          modal.appendChild(closeBtn);
          modal.appendChild(iframe);
          backdrop.appendChild(modal);
          document.body.appendChild(backdrop);

          // Close on backdrop click
          backdrop.addEventListener('click', function (e) {
            if (e.target === backdrop) {
              closeEmailSystem();
            }
          });

          // Close on ESC key
          document.addEventListener('keydown', handleEmailSystemEscape);
        }

        function closeEmailSystem() {
          const backdrop = document.getElementById('emailSystemBackdrop');
          if (backdrop) {
            backdrop.style.opacity = '0';
            setTimeout(() => backdrop.remove(), 200);
          }
          document.removeEventListener('keydown', handleEmailSystemEscape);
        }

        function handleEmailSystemEscape(e) {
          if (e.key === 'Escape') {
            closeEmailSystem();
          }
        }

        // ============================================================================
        // LA TIMEZONE OFFSET CORRECTION
        // ============================================================================

        let isUpdatingLAOffset = false;
        let userPreferencesCache = null; // Cache for user preferences

        // ============================================================================
        // CLOUD-SYNCED USER PREFERENCES - Timezone settings sync across all devices
        // ============================================================================

        // Load user preferences from Supabase (cloud-synced)
        async function loadUserPreferences() {
          try {
            const {
              data: { user },
            } = await supabase.auth.getUser();
            if (!user) {
              console.warn('‚ö†Ô∏è No authenticated user - cannot load preferences');
              return null;
            }

            const { data, error } = await supabase.from('user_preferences').select('*').eq('user_id', user.id).single();

            if (error && error.code !== 'PGRST116') {
              // PGRST116 = no rows found (first time user)
              console.error('‚ùå Error loading preferences:', error);
              return null;
            }

            if (!data) {
              // First time user - create default preferences
              const { data: newPrefs, error: insertError } = await supabase
                .from('user_preferences')
                .insert({
                  user_id: user.id,
                  timezone_offset_winter: false,
                  timezone_offset_summer: false,
                })
                .select()
                .single();

              if (insertError) {
                console.error('‚ùå Error creating preferences:', insertError);
                return null;
              }

              userPreferencesCache = newPrefs;
              return newPrefs;
            }

            userPreferencesCache = data;
            debugLog('‚úÖ Loaded user preferences from cloud:', data);
            return data;
          } catch (error) {
            console.error('‚ùå Failed to load user preferences:', error);
            return null;
          }
        }

        // Save timezone preference to Supabase (syncs across all devices)
        async function saveTimezonePreference(winter, summer) {
          try {
            const {
              data: { user },
            } = await supabase.auth.getUser();
            if (!user) {
              console.warn('‚ö†Ô∏è No authenticated user - cannot save preferences');
              return false;
            }

            const { data, error } = await supabase
              .from('user_preferences')
              .upsert(
                {
                  user_id: user.id,
                  timezone_offset_winter: winter,
                  timezone_offset_summer: summer,
                  updated_at: new Date().toISOString(),
                },
                {
                  onConflict: 'user_id',
                }
              )
              .select()
              .single();

            if (error) {
              console.error('‚ùå Error saving timezone preference:', error);
              return false;
            }

            userPreferencesCache = data;
            debugLog('‚úÖ Timezone preference saved to cloud:', { winter, summer });

            // Also save to localStorage as fallback
            localStorage.setItem('la-offset-12', winter.toString());
            localStorage.setItem('la-offset-11', summer.toString());

            return true;
          } catch (error) {
            console.error('‚ùå Failed to save timezone preference:', error);
            return false;
          }
        }

        // Load saved offset settings (cloud-first, localStorage fallback)
        async function getLAOffsetSettings() {
          // Try to load from cloud first
          const prefs = await loadUserPreferences();
          if (prefs) {
            return {
              offset12: prefs.timezone_offset_winter || false,
              offset11: prefs.timezone_offset_summer || false,
            };
          }

          // Fallback to localStorage
          const offset12 = localStorage.getItem('la-offset-12') === 'true';
          const offset11 = localStorage.getItem('la-offset-11') === 'true';
          return { offset12, offset11 };
        }

        // Get settings synchronously from cache (for fast access)
        function getLAOffsetSettingsSync() {
          if (userPreferencesCache) {
            return {
              offset12: userPreferencesCache.timezone_offset_winter || false,
              offset11: userPreferencesCache.timezone_offset_summer || false,
            };
          }

          // Fallback to localStorage if cache not loaded yet
          const offset12 = localStorage.getItem('la-offset-12') === 'true';
          const offset11 = localStorage.getItem('la-offset-11') === 'true';
          return { offset12, offset11 };
        }

        // Toggle LA offset (only one can be active) - NOW CLOUD-SYNCED
        async function setLAOffset(hours, isEnabled, { silent = false } = {}) {
          const toggle12 = document.getElementById('laOffset12Toggle');
          const toggle11 = document.getElementById('laOffset11Toggle');

          if (hours === 12 && toggle12) {
            toggle12.checked = isEnabled;
            updateToggleStyle(toggle12, isEnabled);

            if (isEnabled && toggle11) {
              toggle11.checked = false;
              updateToggleStyle(toggle11, false);
            }

            // Save to cloud (syncs across all devices)
            await saveTimezonePreference(isEnabled, false);

            if (!silent) {
              showNotification(
                isEnabled
                  ? '‚ùÑÔ∏è Winter offset enabled: ‚Äì12 hours (synced to cloud)'
                  : '‚úÖ Winter offset disabled (synced to cloud)',
                'success'
              );
            }
          } else if (hours === 11 && toggle11) {
            toggle11.checked = isEnabled;
            updateToggleStyle(toggle11, isEnabled);

            if (isEnabled && toggle12) {
              toggle12.checked = false;
              updateToggleStyle(toggle12, false);
            }

            // Save to cloud (syncs across all devices)
            await saveTimezonePreference(false, isEnabled);

            if (!silent) {
              showNotification(
                isEnabled
                  ? '‚òÄÔ∏è Summer offset enabled: ‚Äì11 hours (synced to cloud)'
                  : '‚úÖ Summer offset disabled (synced to cloud)',
                'success'
              );
            }
          }
        }

        // Update toggle visual styling
        function updateToggleStyle(toggleElement, isActive) {
          if (!toggleElement) {
            console.warn('‚ö†Ô∏è updateToggleStyle: toggleElement is null');
            return;
          }

          const label = toggleElement.parentElement;
          const slider = label ? label.querySelector('.toggle-slider') : null;
          const knob = label ? label.querySelector('.toggle-knob') : null;

          verboseLog('üé® Updating toggle style:', {
            toggleId: toggleElement.id,
            isActive,
            hasSlider: !!slider,
            hasKnob: !!knob,
          });

          if (slider) {
            slider.style.background = isActive ? 'rgba(34, 197, 94, 0.6)' : 'rgba(100,116,139,0.4)';
          } else {
            console.warn('‚ö†Ô∏è Slider not found for', toggleElement.id);
          }

          if (knob) {
            knob.style.transform = isActive ? 'translateX(20px)' : 'translateX(0)';
          } else {
            console.warn('‚ö†Ô∏è Knob not found for', toggleElement.id);
          }
        }

        // Apply LA offset to a Date object
        function applyLAOffset(date) {
          const settings = getLAOffsetSettingsSync(); // Use sync version for performance
          const adjustedDate = new Date(date);

          if (settings.offset12) {
            adjustedDate.setHours(adjustedDate.getHours() - 12);
          } else if (settings.offset11) {
            adjustedDate.setHours(adjustedDate.getHours() - 11);
          }

          return adjustedDate;
        }

        // Update settings button color based on timezone offset status
        function updateSettingsButtonColor() {
          const settingsBtn = document.getElementById('settingsBtn');
          if (!settingsBtn) return;

          const settings = getLAOffsetSettingsSync();
          const isActive = settings.offset12 || settings.offset11;

          if (isActive) {
            // Add green glowing effect when timezone offset is active
            settingsBtn.classList.add('settings-active');
          } else {
            // Remove glow when both toggles are OFF
            settingsBtn.classList.remove('settings-active');
          }
        }

        // Initialize toggle states on page load - NOW LOADS FROM CLOUD
        async function initializeLAOffsetToggles() {
          try {
            const settings = await getLAOffsetSettings(); // Load from cloud
            const toggle12 = document.getElementById('laOffset12Toggle');
            const toggle11 = document.getElementById('laOffset11Toggle');

            if (!toggle12 || !toggle11) {
              console.warn('‚ö†Ô∏è Toggle elements not found');
              return;
            }

            const enable12 = Boolean(settings.offset12);
            const enable11 = !enable12 && Boolean(settings.offset11);

            verboseLog('üîß Initializing toggles:', { enable12, enable11, settings });

            isUpdatingLAOffset = true;

            // Set UI state first
            toggle12.checked = enable12;
            toggle11.checked = enable11;
            updateToggleStyle(toggle12, enable12);
            updateToggleStyle(toggle11, enable11);

            // Update settings button color
            updateSettingsButtonColor();

            isUpdatingLAOffset = false;

            // Add event listeners
            toggle12.addEventListener('change', async event => {
              if (isUpdatingLAOffset) return;
              isUpdatingLAOffset = true;
              await setLAOffset(12, event.target.checked);
              updateSettingsButtonColor(); // Update settings button color
              isUpdatingLAOffset = false;
            });

            toggle11.addEventListener('change', async event => {
              if (isUpdatingLAOffset) return;
              isUpdatingLAOffset = true;
              await setLAOffset(11, event.target.checked);
              updateSettingsButtonColor(); // Update settings button color
              isUpdatingLAOffset = false;
            });

            verboseLog('‚úÖ LA offset toggles initialized:', { winter: enable12, summer: enable11 });
          } catch (error) {
            console.error('‚ùå Failed to initialize LA offset toggles:', error);
          }
        }

        // Subscribe to real-time preference changes (syncs instantly across all devices)
        function subscribeToPreferenceChanges() {
          supabase
            .channel('user_preferences_changes')
            .on(
              'postgres_changes',
              {
                event: '*', // Listen to INSERT, UPDATE, DELETE
                schema: 'public',
                table: 'user_preferences',
              },
              async payload => {
                debugLog('üîî Real-time preference update received:', payload);

                if (payload.eventType === 'UPDATE' || payload.eventType === 'INSERT') {
                  const newPrefs = payload.new;

                  // Update cache
                  userPreferencesCache = newPrefs;

                  // Update toggle UI without triggering save (to prevent infinite loop)
                  const toggle12 = document.getElementById('laOffset12Toggle');
                  const toggle11 = document.getElementById('laOffset11Toggle');

                  if (toggle12 && toggle11) {
                    isUpdatingLAOffset = true;

                    const winter = newPrefs.timezone_offset_winter || false;
                    const summer = newPrefs.timezone_offset_summer || false;

                    toggle12.checked = winter;
                    toggle11.checked = summer;

                    updateToggleStyle(toggle12, winter);
                    updateToggleStyle(toggle11, summer);

                    // Update settings button color
                    updateSettingsButtonColor();

                    isUpdatingLAOffset = false;

                    // Show notification that settings synced from another device
                    if (winter) {
                      showNotification('üîÑ Synced from another device: Winter offset (‚Äì12h) enabled', 'info');
                    } else if (summer) {
                      showNotification('üîÑ Synced from another device: Summer offset (‚Äì11h) enabled', 'info');
                    } else {
                      showNotification('üîÑ Synced from another device: All offsets disabled', 'info');
                    }
                  }
                }
              }
            )
            .subscribe(status => {
              if (status === 'SUBSCRIBED') {
                debugLog('‚úÖ Subscribed to real-time preference sync');
              } else if (status === 'CHANNEL_ERROR') {
                console.error('‚ùå Real-time preference sync error');
              }
            });
        }

        // ============================================================================
        // BACKUP & RESTORE SYSTEM
        // ============================================================================

        /**
         * Export Full Backup
         * Creates a comprehensive JSON backup of all app data
         */
        function exportFullBackup() {
          try {
            // Close settings menu
            const menu = document.getElementById('settingsMenu');
            if (menu) menu.style.display = 'none';

            // Gather all data from localStorage
            const backup = {
              version: '2.0',
              timestamp: new Date().toISOString(),
              students: JSON.parse(localStorage.getItem('students:v2') || '[]'),
              groups: JSON.parse(localStorage.getItem('group-manager:v2') || '[]'),
              payments: JSON.parse(localStorage.getItem('payments:v2') || '[]'),
              waitingList: JSON.parse(localStorage.getItem('waiting-list:v2') || '[]'),
              settings: JSON.parse(localStorage.getItem('settings:v2') || '{}'),
              gmailConnection: JSON.parse(localStorage.getItem('gmail-connection') || 'null'),
              exchangeRate: localStorage.getItem('exchangeRate') || '400',
              lastSync: localStorage.getItem('lastSyncTime') || null,
            };

            // Convert to JSON string with formatting
            const jsonString = JSON.stringify(backup, null, 2);

            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // Create filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
            a.download = `ARNOMA_Backup_${timestamp}.json`;

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Create auto-backup in localStorage (keep last 5)
            createAutoBackup(backup);

            showNotificationSimple('‚úÖ Backup exported successfully', 'success');
          } catch (error) {
            console.error('Error exporting backup:', error);
            showNotificationSimple('‚ùå Failed to export backup', 'error');
          }
        }

        /**
         * Trigger Import Backup
         * Opens file selector for backup restoration
         */
        function triggerImportBackup() {
          try {
            // Close settings menu
            const menu = document.getElementById('settingsMenu');
            if (menu) menu.style.display = 'none';

            const fileInput = document.getElementById('backupFileInput');
            if (!fileInput) {
              showNotificationSimple('‚ùå File input not found', 'error');
              return;
            }

            // Set up file input handler
            fileInput.onchange = async e => {
              const file = e.target.files[0];
              if (!file) return;

              try {
                const text = await file.text();
                await importFullBackup(text);
              } catch (error) {
                console.error('Error reading backup file:', error);
                showNotificationSimple('‚ùå Failed to read backup file', 'error');
              }

              // Reset file input
              fileInput.value = '';
            };

            // Trigger file selection
            fileInput.click();
          } catch (error) {
            console.error('Error triggering import:', error);
            showNotificationSimple('‚ùå Failed to open file selector', 'error');
          }
        }

        /**
         * Import Full Backup
         * Restores all app data from a backup file
         */
        async function importFullBackup(jsonData) {
          try {
            // Confirm before overwriting
            const confirmed = await customConfirm(
              'Restoring a backup will overwrite all current data.\n\nThis action cannot be undone.\n\nContinue?',
              {
                title: 'Restore Backup',
                icon: '‚ö†Ô∏è',
                okText: 'Restore',
                type: 'danger',
              }
            );

            if (!confirmed) return;

            // Parse JSON
            let data;
            try {
              data = JSON.parse(jsonData);
            } catch (parseError) {
              showNotificationSimple('‚ùå Invalid backup file format', 'error');
              return;
            }

            // Validate backup structure
            if (!data.version || !data.timestamp) {
              showNotificationSimple('‚ùå Invalid backup file: missing version info', 'error');
              return;
            }

            if (!data.students && !data.groups && !data.payments) {
              showNotificationSimple('‚ùå Invalid backup file: no data found', 'error');
              return;
            }

            // Create automatic backup of current state before restore
            const currentBackup = {
              version: '2.0',
              timestamp: new Date().toISOString(),
              students: JSON.parse(localStorage.getItem('students:v2') || '[]'),
              groups: JSON.parse(localStorage.getItem('group-manager:v2') || '[]'),
              payments: JSON.parse(localStorage.getItem('payments:v2') || '[]'),
              waitingList: JSON.parse(localStorage.getItem('waiting-list:v2') || '[]'),
              settings: JSON.parse(localStorage.getItem('settings:v2') || '{}'),
            };
            localStorage.setItem('lastAutoBackup:v2', JSON.stringify(currentBackup));

            // Restore data to localStorage
            if (data.students) {
              localStorage.setItem('students:v2', JSON.stringify(data.students));
            }

            if (data.groups) {
              localStorage.setItem('group-manager:v2', JSON.stringify(data.groups));
            }

            if (data.payments) {
              localStorage.setItem('payments:v2', JSON.stringify(data.payments));
              PaymentStore.save(data.payments); // Update PaymentStore
            }

            if (data.waitingList) {
              localStorage.setItem('waiting-list:v2', JSON.stringify(data.waitingList));
            }

            if (data.settings) {
              localStorage.setItem('settings:v2', JSON.stringify(data.settings));
            }

            if (data.gmailConnection !== undefined) {
              localStorage.setItem('gmail-connection', JSON.stringify(data.gmailConnection));
            }

            if (data.exchangeRate) {
              localStorage.setItem('exchangeRate', data.exchangeRate);
            }

            if (data.lastSync) {
              localStorage.setItem('lastSyncTime', data.lastSync);
            }

            // Dispatch update events
            window.dispatchEvent(new CustomEvent('students:updated', { detail: data.students || [] }));
            window.dispatchEvent(new CustomEvent('groups:updated', { detail: data.groups || [] }));
            window.dispatchEvent(new CustomEvent('payments:updated', { detail: data.payments || [] }));

            // Reload all views
            if (typeof loadStudents === 'function') {
              students = getCachedStudents();
            }

            if (typeof loadGroups === 'function') {
              groups = loadGroups();
            }

            if (typeof loadWaitingList === 'function') {
              waitingList = loadWaitingList();
            }

            // Re-render all views
            if (typeof renderPaymentEmailsView === 'function') {
              renderPaymentEmailsView();
            }

            if (typeof renderStudents === 'function') {
              renderStudents();
            }

            if (typeof renderGroups === 'function') {
              renderGroups();
            }

            // Update month selector and totals
            if (typeof populateMonthSelector === 'function') {
              populateMonthSelector();
            }

            if (typeof updateMonthTotals === 'function') {
              updateMonthTotals();
            }

            // Show success message
            showNotificationSimple('‚úÖ Backup restored successfully! All data reloaded.', 'success');

            // Optional: Reload page after a short delay for clean state
            setTimeout(() => {
              if (confirm('Reload page to ensure all components are properly initialized?')) {
                window.location.reload();
              }
            }, 1500);
          } catch (error) {
            console.error('Error importing backup:', error);
            showNotificationSimple('‚ùå Failed to restore backup: ' + error.message, 'error');
          }
        }

        /**
         * Create Auto Backup
         * Stores automatic backups in localStorage (keeps last 5)
         */
        /**
         * Create Auto Backup
         * All data is already in Supabase, so this just logs the backup event
         */
        async function createAutoBackup(backupData) {
          try {
            // Store backup metadata in localStorage for quick access
            localStorage.setItem('lastAutoBackup:v2', JSON.stringify(backupData));

            debugLog('‚úÖ Auto-backup completed');
          } catch (error) {
            console.error('Error creating auto-backup metadata:', error);
          }
        }

        /**
         * Restore from Cloud
         * Reloads all data from Supabase
         */
        async function restoreFromCloud() {
          try {
            showNotification('üîÑ Loading data from Supabase...', 'info');

            const confirmed = await customConfirm(
              'Reload all data from Supabase cloud?\n\n' +
                'This will refresh your local view with the latest cloud data.',
              {
                title: 'Restore from Cloud',
                icon: '‚òÅÔ∏è',
                okText: 'Reload',
                type: 'info',
              }
            );

            if (!confirmed) return;

            // Reload data from Supabase
            const students = await loadStudents();
            const payments = await PaymentStore.fetchAll();

            showNotification(
              `‚úÖ Loaded ${students.length} students and ${payments.length} payments from cloud`,
              'success'
            );

            // Refresh UI
            window.location.reload();
          } catch (error) {
            console.error('Error restoring from cloud:', error);
            showNotification('‚ùå Failed to restore from cloud', 'error');
          }
        }

        /**
         * Restore Last Auto Backup
         * Restores the most recent automatic backup
         */
        async function restoreLastAutoBackup() {
          try {
            // Close settings menu
            const menu = document.getElementById('settingsMenu');
            if (menu) menu.style.display = 'none';

            // Get last auto backup
            const lastBackupRaw = localStorage.getItem('lastAutoBackup:v2');

            if (!lastBackupRaw) {
              showNotificationSimple('‚ùå No auto backup found', 'error');
              return;
            }

            const lastBackup = JSON.parse(lastBackupRaw);

            // Show backup info
            const backupDate = new Date(lastBackup.timestamp).toLocaleString('en-US', {
              month: 'short',
              day: 'numeric',
              year: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
            });
            const confirmed = await customConfirm(
              `Restore automatic backup from:\n${backupDate}\n\nThis will overwrite all current data.\n\nContinue?`,
              {
                title: 'Restore Auto Backup',
                icon: '‚èÆÔ∏è',
                okText: 'Restore',
                type: 'danger',
              }
            );

            if (!confirmed) return;

            // Use the import function to restore
            await importFullBackup(JSON.stringify(lastBackup));
          } catch (error) {
            console.error('Error restoring auto backup:', error);
            showNotificationSimple('‚ùå Failed to restore auto backup', 'error');
          }
        }

        /**
         * Initialize Daily Auto Backup
         * Automatically creates backups once per day
         */
        function initializeDailyAutoBackup() {
          try {
            // Check last auto backup date
            const lastAutoBackupDate = localStorage.getItem('lastAutoBackupDate');
            const today = getTodayLA(); // YYYY-MM-DD in LA timezone

            // If no backup today, create one
            if (lastAutoBackupDate !== today) {
              performDailyAutoBackup();
            }

            // Set up interval to check daily (every hour)
            setInterval(
              () => {
                const currentDate = new Date().toISOString().slice(0, 10);
                const lastBackupDate = localStorage.getItem('lastAutoBackupDate');

                if (lastBackupDate !== currentDate) {
                  performDailyAutoBackup();
                }
              },
              60 * 60 * 1000
            ); // Check every hour
          } catch (error) {
            console.error('Error initializing daily auto backup:', error);
          }
        }

        /**
         * Perform Daily Auto Backup
         * Creates a silent backup in localStorage
         */
        function performDailyAutoBackup() {
          try {
            // Gather all data
            const backup = {
              version: '2.0',
              timestamp: new Date().toISOString(),
              students: JSON.parse(localStorage.getItem('students:v2') || '[]'),
              groups: JSON.parse(localStorage.getItem('group-manager:v2') || '[]'),
              payments: JSON.parse(localStorage.getItem('payments:v2') || '[]'),
              waitingList: JSON.parse(localStorage.getItem('waiting-list:v2') || '[]'),
              settings: JSON.parse(localStorage.getItem('settings:v2') || '{}'),
              gmailConnection: JSON.parse(localStorage.getItem('gmail-connection') || 'null'),
              exchangeRate: localStorage.getItem('exchangeRate') || '400',
              lastSync: localStorage.getItem('lastSyncTime') || null,
            };

            // Store auto backup
            createAutoBackup(backup);

            // Update last backup date
            const today = getTodayLA();
            localStorage.setItem('lastAutoBackupDate', today);
          } catch (error) {
            console.error('Error performing daily auto backup:', error);
          }
        }

        // ============================================================================
        // CUSTOM DIALOG SYSTEM (Replaces browser confirm/alert/prompt)
        // ============================================================================

        // Custom Confirm Dialog
        function customConfirm(message, options = {}) {
          return new Promise(resolve => {
            const modal = document.getElementById('customConfirmModal');
            const messageEl = document.getElementById('confirmMessage');
            const titleEl = document.getElementById('confirmTitle');
            const iconEl = document.getElementById('confirmIcon');
            const okBtn = document.getElementById('confirmOkBtn');
            const cancelBtn = document.getElementById('confirmCancelBtn');

            // Set content
            messageEl.textContent = message;
            titleEl.textContent = options.title || 'Confirm Action';
            iconEl.textContent = options.icon || '‚ö†Ô∏è';
            okBtn.textContent = options.okText || 'Confirm';
            cancelBtn.textContent = options.cancelText || 'Cancel';

            // Style OK button based on type
            if (options.type === 'danger') {
              okBtn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
              okBtn.style.boxShadow = '0 4px 12px rgba(239, 68, 68, 0.4)';
            } else {
              okBtn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
              okBtn.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.4)';
            }

            // Show modal
            modal.style.display = 'flex';

            // Handle button clicks
            const handleOk = () => {
              modal.style.display = 'none';
              cleanup();
              resolve(true);
            };

            const handleCancel = () => {
              modal.style.display = 'none';
              cleanup();
              resolve(false);
            };

            const cleanup = () => {
              okBtn.removeEventListener('click', handleOk);
              cancelBtn.removeEventListener('click', handleCancel);
            };

            okBtn.addEventListener('click', handleOk);
            cancelBtn.addEventListener('click', handleCancel);

            // ESC key support
            const handleEsc = e => {
              if (e.key === 'Escape') {
                handleCancel();
                document.removeEventListener('keydown', handleEsc);
              }
            };
            document.addEventListener('keydown', handleEsc);
          });
        }

        // Custom Alert Dialog
        function customAlert(message, options = {}) {
          return new Promise(resolve => {
            const modal = document.getElementById('customAlertModal');
            const messageEl = document.getElementById('alertMessage');
            const titleEl = document.getElementById('alertTitle');
            const iconEl = document.getElementById('alertIcon');
            const okBtn = document.getElementById('alertOkBtn');

            // Set content
            messageEl.textContent = message;
            titleEl.textContent = options.title || 'Notice';
            iconEl.textContent = options.icon || '‚ÑπÔ∏è';
            okBtn.textContent = options.okText || 'OK';

            // Show modal
            modal.style.display = 'flex';

            // Handle button click
            const handleOk = () => {
              modal.style.display = 'none';
              okBtn.removeEventListener('click', handleOk);
              resolve();
            };

            okBtn.addEventListener('click', handleOk);

            // ESC key support
            const handleEsc = e => {
              if (e.key === 'Escape') {
                handleOk();
                document.removeEventListener('keydown', handleEsc);
              }
            };
            document.addEventListener('keydown', handleEsc);
          });
        }

        // Custom Prompt Dialog
        function customPrompt(message, defaultValue = '', options = {}) {
          return new Promise(resolve => {
            const modal = document.getElementById('customPromptModal');
            const messageEl = document.getElementById('promptMessage');
            const titleEl = document.getElementById('promptTitle');
            const inputEl = document.getElementById('promptInput');
            const okBtn = document.getElementById('promptOkBtn');
            const cancelBtn = document.getElementById('promptCancelBtn');

            // Set content
            messageEl.textContent = message;
            titleEl.textContent = options.title || 'Input Required';
            inputEl.value = defaultValue;
            inputEl.placeholder = options.placeholder || 'Enter value...';
            okBtn.textContent = options.okText || 'Submit';
            cancelBtn.textContent = options.cancelText || 'Cancel';

            // Show modal and focus input
            modal.style.display = 'flex';
            setTimeout(() => inputEl.focus(), 100);

            // Handle button clicks
            const handleOk = () => {
              const value = inputEl.value.trim();
              modal.style.display = 'none';
              cleanup();
              resolve(value || null);
            };

            const handleCancel = () => {
              modal.style.display = 'none';
              cleanup();
              resolve(null);
            };

            const cleanup = () => {
              okBtn.removeEventListener('click', handleOk);
              cancelBtn.removeEventListener('click', handleCancel);
              inputEl.removeEventListener('keypress', handleEnter);
            };

            const handleEnter = e => {
              if (e.key === 'Enter') handleOk();
            };

            okBtn.addEventListener('click', handleOk);
            cancelBtn.addEventListener('click', handleCancel);
            inputEl.addEventListener('keypress', handleEnter);

            // ESC key support
            const handleEsc = e => {
              if (e.key === 'Escape') {
                handleCancel();
                document.removeEventListener('keydown', handleEsc);
              }
            };
            document.addEventListener('keydown', handleEsc);
          });
        }

        // Override browser dialogs (optional - for consistency)
        window.confirm = customConfirm;
        window.alert = customAlert;
        window.prompt = customPrompt;

        // ============================================================================
        // üë©‚Äç‚öïÔ∏è STUDENT MANAGER - ENHANCED VERSION WITH ALL FEATURES
        // ============================================================================

        const STORAGE_KEY = 'students:v2';
        const WAITING_LIST_KEY = 'waiting-list';
        const STUDENT_STATUSES = {
          ACTIVE: 'active',
          PAUSED: 'paused',
          GRADUATED: 'graduated',
        };

        // Students will be loaded from Supabase on initialization
        let students = [];
        let waitingList = JSON.parse(localStorage.getItem(WAITING_LIST_KEY) || '[]');
        let selectedStudent = null;
        let editingStudentId = null;

        // FILTER PERSISTENCE: Store current filter state to maintain filters across student updates
        let currentFilters = {
          search: '',
          group: '',
          status: '',
          payment: '',
          sort: '',
        };

        // Student data is loaded during core initialization. Render only when manager opens.

        // ===== UTILITY FUNCTIONS =====
        function generateId() {
          return 'student_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function showNotificationSimple(message, type = 'info') {
          // Notification toast removed - only log to console
          const icon = { success: '‚úÖ', error: '‚ùå', warning: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' }[type] || '‚ÑπÔ∏è';
        }

        function normalizeStatus(status) {
          const normalized = normalizeStudentStatusValue(status);
          switch (normalized) {
            case 'paused':
              return STUDENT_STATUSES.PAUSED;
            case 'graduated':
              return STUDENT_STATUSES.GRADUATED;
            default:
              return STUDENT_STATUSES.ACTIVE;
          }
        }

        function getStatusDetails(status) {
          const normalized = normalizeStatus(status);
          switch (normalized) {
            case STUDENT_STATUSES.PAUSED:
              return { label: 'Paused', color: '#fbbf24', bg: 'rgba(251,191,36,.15)', border: 'rgba(251,191,36,.4)' };
            case STUDENT_STATUSES.GRADUATED:
              return {
                label: 'Graduated',
                color: '#a78bfa',
                bg: 'rgba(167,139,250,.15)',
                border: 'rgba(167,139,250,.4)',
              };
            default:
              return { label: 'Active', color: '#4caf50', bg: 'rgba(76,175,80,.15)', border: 'rgba(76,175,80,.4)' };
          }
        }

        // ===== SAVE/LOAD FUNCTIONS =====
        async function saveStudents() {
          try {
            // Save all students to Supabase
            for (const student of students) {
              await saveStudent(student);
            }

            // Update global cache
            window.studentsCache = students;

            // Dispatch event for cross-module communication
            window.dispatchEvent(new CustomEvent('students:updated', { detail: students }));

            // Auto-backup on every student save
            try {
              const payments = await PaymentStore.fetchAll();
              const backupData = {
                timestamp: new Date().toISOString(),
                students: students,
                payments: payments,
                student_count: students.length,
                payment_count: payments.length,
                source: 'student-save',
              };
              await createAutoBackup(backupData);
            } catch (error) {
              console.error('Auto-backup from student save failed:', error);
            }
          } catch (e) {
            console.error('Error saving students:', e);
          }
        }

        function saveWaitingList() {
          try {
            localStorage.setItem(WAITING_LIST_KEY, JSON.stringify(waitingList));
          } catch (e) {
            console.error('Error saving waiting list:', e);
          }
        }

        async function loadStudentsFromDB() {
          try {
            const loadedStudents = await loadStudents();
            students = loadedStudents;
            return students;
          } catch (error) {
            console.error('Error loading students:', error);
            return [];
          }
        }

        // ===== CLOUD SYNC (AUTOMATIC VIA SUPABASE) =====
        async function syncWithCloud() {
          // Find the sync button and add spinning animation
          const syncButton = document.getElementById('syncCloudBtn');
          if (syncButton) {
            syncButton.classList.add('spinning');
          }

          try {
            showNotificationSimple('Syncing with Supabase...');

            // Save all students to Supabase cloud database
            await saveStudents();

            // Reload all cloud-synced data
            if (window.SkipClassManager) {
              await window.SkipClassManager.reloadFromSupabase();
            }
            if (window.AbsentManager) {
              await window.AbsentManager.reloadFromSupabase();
            }
            if (window.CreditPaymentManager) {
              await window.CreditPaymentManager.reloadFromSupabase();
            }

            // Refresh calendar to show updated data
            renderCalendar();

            showNotificationSimple('‚úÖ Synced with Supabase', 'success');
          } catch (error) {
            console.error('Supabase sync error:', error);
            showNotificationSimple('Sync failed', 'error');
          } finally {
            // Remove spinning animation
            if (syncButton) {
              syncButton.classList.remove('spinning');
            }
          }
        }

        // ===== OPEN/CLOSE STUDENT MANAGER =====
        function openStudentManager() {
          const menu = document.getElementById('settingsMenu');
          if (menu) menu.style.display = 'none';

          const modal = document.getElementById('studentManagerModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Register with PopupManager
          window.PopupManager.register('studentManagerModal', {
            hasBackButton: false, // Top-level modal
            closeOnOutsideClick: true,
            onClose: closeStudentManager,
          });

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'block';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX

          // ‚ö° PERFORMANCE: Lazy load student manager on first open
          if (typeof lazyLoadStudentManager === 'function') {
            lazyLoadStudentManager();
          }

          loadGroupsForStudentManager();
          renderStudents();
        }

        function closeStudentManager() {
          const modal = document.getElementById('studentManagerModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('studentManagerModal');
          }, 250);
          // END POPUP BACK & EXIT FIX

          // Close any open editing cards
          document.querySelectorAll('.student-item.editing').forEach(card => {
            card.classList.remove('editing');
          });
        }

        function closeStudentManagerOnOutsideClick(event) {
          if (event.target.id === 'studentManagerModal') {
            closeStudentManager();
          }
        }

        // ===== LOAD GROUPS FROM GROUP MANAGER =====
        function loadGroupsForStudentManager() {
          // Request groups from Group Manager
          window.dispatchEvent(new CustomEvent('groups:request'));

          // Load from Supabase cache
          const storedGroups = window.groupsCache || window.globalData?.groups || [];
          if (storedGroups.length > 0) {
            groups = storedGroups;
          }
        }

        // ===== RENDER STUDENTS =====
        function renderStudents() {
          const grid = document.getElementById('studentGrid');
          if (!grid) return;

          // Always use the most current data from cache
          students = window.studentsCache || students || [];

          grid.innerHTML = '';
          const activeStudents = students.filter(s => s.isActive !== false);

          // Populate group filter dropdown - only show active groups
          const activeGroups = window.groupsCache?.filter(g => g.active !== false) || [];
          const uniqueGroups = [...new Set(activeStudents.map(s => s.group).filter(g => g))].sort();
          // Filter to only include groups that are active
          const visibleUniqueGroups = uniqueGroups.filter(groupName => activeGroups.some(g => g.name === groupName));
          const groupFilter = document.getElementById('filterGroup');
          if (groupFilter) {
            groupFilter.innerHTML =
              '<option value="">All Groups</option>' +
              '<option value="no-group">No Group</option>' +
              visibleUniqueGroups.map(g => `<option value="${escapeHtml(g)}">Group ${escapeHtml(g)}</option>`).join('');
          }

          // Sort students
          activeStudents.sort((a, b) => {
            if (a.group !== b.group) return (a.group || '').localeCompare(b.group || '');
            return (a.name || '').localeCompare(b.name || '');
          });

          if (activeStudents.length === 0) {
            grid.innerHTML =
              '<div style="grid-column: 1/-1; text-align: center; padding: 60px; color: #6b7280; font-size: 18px;">No students found. Click "+ Add Student" to get started.</div>';
            return;
          }

          const fragment = document.createDocumentFragment();
          activeStudents.forEach(student => {
            try {
              fragment.appendChild(createStudentCard(student));
            } catch (error) {
              console.error('Error creating card for student:', student.name, error);
            }
          });

          grid.appendChild(fragment);

          // Add click-outside-to-cancel-edit listener
          setupClickOutsideEditListener();

          // FILTER PERSISTENCE: Restore and reapply saved filter state
          const searchInput = document.getElementById('studentSearchInput');
          const groupFilterEl = document.getElementById('filterGroup');
          const statusFilterEl = document.getElementById('filterStatus');
          const paymentFilterEl = document.getElementById('filterPayment');
          const sortPriceEl = document.getElementById('sortPrice');

          if (searchInput) searchInput.value = currentFilters.search;
          if (groupFilterEl) groupFilterEl.value = currentFilters.group;
          if (statusFilterEl) statusFilterEl.value = currentFilters.status;
          if (paymentFilterEl) paymentFilterEl.value = currentFilters.payment;
          if (sortPriceEl) sortPriceEl.value = currentFilters.sort;

          // Reapply filters if any are active
          if (
            currentFilters.search ||
            currentFilters.group ||
            currentFilters.status ||
            currentFilters.payment ||
            currentFilters.sort
          ) {
            filterStudents();
          }
        }

        // ===== CLICK OUTSIDE TO CANCEL EDIT =====
        function setupClickOutsideEditListener() {
          // Remove existing listener if any
          if (window._studentEditClickListener) {
            document.removeEventListener('click', window._studentEditClickListener);
          }

          // Create new listener
          window._studentEditClickListener = function (event) {
            const editingCards = document.querySelectorAll('.student-item.editing');
            if (editingCards.length === 0) return;

            // Check if click is inside any editing card
            const clickedInsideCard = Array.from(editingCards).some(card => card.contains(event.target));

            // Check if clicked on any interactive element (button, input, select, etc.)
            const clickedInteractive = event.target.closest(
              'button, input, textarea, select, a, label, .status-pill-single, .mini-toggle, .group-btn'
            );

            // If clicked outside all editing cards and not on an interactive element, cancel all edits
            if (!clickedInsideCard && !clickedInteractive) {
              editingCards.forEach(card => {
                // Extract student ID from card ID (format: card-student_123_abc)
                const studentId = card.id.replace('card-', '');
                // Call cancelInlineEdit to properly exit edit mode
                cancelInlineEdit(studentId);
              });
            }
          };

          // Attach listener with capture phase to catch events before stopPropagation
          document.addEventListener('click', window._studentEditClickListener, true);
        }

        // ===== CREATE STUDENT CARD =====
        function createStudentCard(student) {
          const card = document.createElement('div');
          card.className = 'student-item';
          card.id = `card-${student.id}`;

          // Set data attributes for filtering
          card.setAttribute('data-student-id', student.id);
          card.setAttribute('data-name', (student.name || '').toLowerCase());
          card.setAttribute('data-group', (student.group || '').toLowerCase());
          card.setAttribute('data-phone', (student.phone || '').toLowerCase());
          card.setAttribute('data-email', (student.email || '').toLowerCase());
          card.setAttribute('data-notes', (student.notes || '').toLowerCase());
          card.setAttribute('data-status', normalizeStatus(student.status));
          card.setAttribute('data-pay', student.payPerClass || 0);
          card.setAttribute('data-balance', student.balance || 0);

          const statusDetails = getStatusDetails(student.status);
          // Respect the exact saved value - default to true only if undefined/null (legacy records)
          const showInGrid = student.showInGrid ?? true;
          const aliases =
            student.aliases && typeof student.aliases === 'string'
              ? student.aliases
                  .split(',')
                  .map(a => a.trim())
                  .filter(a => a)
              : Array.isArray(student.aliases)
                ? student.aliases
                : [];

          card.innerHTML = `
        <!-- VIEW MODE -->
        <div class="student-view" onclick="toggleInlineEdit('${student.id}', event)">
          <!-- Header with Status and Toggle -->
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); background: linear-gradient(135deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1));">
            <span class="status-pill-single status-${normalizeStatus(student.status)}"
                  onclick="event.stopPropagation(); cycleStatus('${student.id}')"
                  title="Click to cycle: Active ‚Üí Paused ‚Üí Graduated"
                  style="cursor: pointer; user-select: none; transition: all 0.2s;">
              ${statusDetails.label}
            </span>
            <label class="mini-toggle" title="${showInGrid ? 'Shown in calendar' : 'Hidden from calendar'}" onclick="event.stopPropagation()">
              <input type="checkbox" ${showInGrid ? 'checked' : ''} onchange="toggleVisibility('${student.id}', this.checked)">
              <span class="slider"></span>
            </label>
          </div>

          <!-- Student Name -->
          <div class="student-name">${escapeHtml(student.name || 'N/A')}</div>

          <!-- Main Info Grid -->
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1px; background: rgba(255, 255, 255, 0.03); margin: 0; border-bottom: 1px solid rgba(255, 255, 255, 0.05);">
            <div style="padding: 14px 20px; background: rgba(0, 0, 0, 0.2); text-align: center;">
              <div style="font-size: 10px; color: rgba(96, 165, 250, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Group</div>
              <div style="font-size: 18px; color: #60a5fa; font-weight: 800; letter-spacing: -0.5px;">${escapeHtml(student.group || 'N/A')}</div>
            </div>
            <div style="padding: 14px 20px; background: rgba(0, 0, 0, 0.25); text-align: center;">
              <div style="font-size: 10px; color: rgba(74, 222, 128, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Pay/Class</div>
              <div style="font-size: 18px; color: #4ade80; font-weight: 800; letter-spacing: -0.5px;">${formatCurrency(student.payPerClass || 0, '$')}</div>
            </div>
            <div style="padding: 14px 20px; background: rgba(0, 0, 0, 0.25); text-align: center;">
              <div style="font-size: 10px; color: rgba(251, 191, 36, 0.6); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Credit</div>
              <div style="font-size: 18px; color: #fbbf24; font-weight: 800; letter-spacing: -0.5px;">${formatCurrency(student.balance || 0, '$')}</div>
            </div>
            <div style="padding: 14px 20px; background: rgba(0, 0, 0, 0.2); text-align: center;">
              <div style="font-size: 10px; color: rgba(192, 132, 252, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Phone</div>
              <div style="font-size: 13px; color: #c084fc; font-weight: 600;">${escapeHtml(student.phone || 'N/A')}</div>
            </div>
          </div>

          <!-- Group Switcher -->
          <div style="padding: 16px 20px; background: linear-gradient(135deg, rgba(200, 181, 255, 0.08), rgba(180, 158, 255, 0.12)); border-bottom: 1px solid rgba(200, 181, 255, 0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <span style="font-size: 11px; color: rgba(200, 181, 255, 0.8); font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">Switch Group</span>
              <span style="font-size: 10px; color: rgba(200, 181, 255, 0.5); font-weight: 600;">Current: ${escapeHtml(student.group || 'N/A')}</span>
            </div>
            <div class="group-buttons" onclick="event.stopPropagation()" style="display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
              ${(() => {
                const activeGroups = (window.groupsCache || []).filter(g => g.active !== false).map(g => g.name);
                return ['A', 'B', 'C', 'D', 'E', 'F']
                  .filter(g => activeGroups.includes(g))
                  .map(
                    g =>
                      `<div class="btn-wrapper group-${g}">
                        <button class="btn ${(student.group || '').toUpperCase() === g ? 'active' : ''}" onclick="changeStudentGroup('${student.id}', '${g}')" title="Switch to Group ${g}">
                          <span class="btn-txt">${g}</span>
                        </button>
                      </div>`
                  )
                  .join('');
              })()}
            </div>
          </div>

          <!-- Amount Switcher -->
          <div style="padding: 16px 20px; background: linear-gradient(135deg, rgba(174, 203, 250, 0.08), rgba(174, 203, 250, 0.12)); border-bottom: 1px solid rgba(174, 203, 250, 0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <span style="font-size: 11px; color: rgba(174, 203, 250, 0.8); font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">Set Pay Amount</span>
              <span style="font-size: 10px; color: rgba(174, 203, 250, 0.5); font-weight: 600;">Current: ${formatCurrency(student.payPerClass || 0, '$')}</span>
            </div>
            <div class="group-buttons" onclick="event.stopPropagation()" style="display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
              ${[25, 50, 75, 100]
                .map(
                  amount =>
                    `<div class="btn-wrapper amount">
                      <button class="btn ${Number(student.payPerClass) === amount ? 'active' : ''}" onclick="changeStudentPayAmount('${student.id}', ${amount})" title="Set pay to $${amount}">
                        <span class="btn-txt small">$${amount}</span>
                      </button>
                    </div>`
                )
                .join('')}
            </div>
          </div>

          ${
            student.email || aliases.length > 0
              ? `
          <!-- Additional Info -->
          <div style="padding: 16px 20px; background: rgba(0, 0, 0, 0.15); border-bottom: 1px solid rgba(255, 255, 255, 0.03);">
            ${
              student.email
                ? `
              <div style="margin-bottom: ${aliases.length > 0 ? '12px' : '0'};">
                <div style="font-size: 10px; color: rgba(148, 163, 184, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Email</div>
                <div style="font-size: 12px; color: #cbd5e1; font-weight: 500; word-break: break-all;">${escapeHtml(student.email)}</div>
              </div>
            `
                : ''
            }
            ${
              aliases.length > 0
                ? `
              <div>
                <div style="font-size: 10px; color: rgba(148, 163, 184, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Aliases</div>
                <div class="aliases-container">
                  ${(Array.isArray(aliases) ? aliases : aliases ? String(aliases).split(',') : [])
                    .map(alias => `<span class="alias-badge">${escapeHtml(alias.trim())}</span>`)
                    .join('')}
                </div>
              </div>
            `
                : ''
            }
          </div>
          `
              : ''
          }

          <!-- Footer -->
          <div style="text-align: center; padding: 12px; color: rgba(138, 180, 255, 0.35); font-size: 11px; font-style: italic; background: rgba(0, 0, 0, 0.1);">
          </div>
        </div>

        <!-- EDIT MODE -->
        <div class="student-edit">
          <div class="student-header">
            <div style="display: flex; gap: 8px; align-items: center;">
              <span class="status-pill-single status-${normalizeStatus(student.status)}" onclick="cycleStatus('${student.id}')">
                ${statusDetails.label}
              </span>
            </div>
            <label class="mini-toggle" title="${showInGrid ? 'Shown in calendar' : 'Hidden from calendar'}">
              <input type="checkbox" ${showInGrid ? 'checked' : ''} onchange="toggleVisibility('${student.id}', this.checked)">
              <span class="slider"></span>
            </label>
          </div>

          <div class="inline-form-group">
            <label>Student Name *</label>
            <input type="text" id="inline-name-${student.id}" value="${escapeHtml(student.name || '')}" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label>Group(s)</label>
            <input type="text" id="inline-group-${student.id}" value="${escapeHtml(student.group || '')}" placeholder="A, B, C (optional)" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label>Pay Per Class</label>
            <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px;">
              <button class="pay-select-btn-inline" onclick="event.preventDefault(); selectInlinePayAmount(this, '${student.id}', 25)" style="padding: 6px 12px; background: ${Number(student.payPerClass) === 25 ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'rgba(255,255,255,.05)'}; color: ${Number(student.payPerClass) === 25 ? 'white' : '#6b7280'}; border: 2px solid ${Number(student.payPerClass) === 25 ? '#22c55e' : 'rgba(255,255,255,.2)'}; border-radius: 6px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-size: 12px;">$25</button>
              <button class="pay-select-btn-inline" onclick="event.preventDefault(); selectInlinePayAmount(this, '${student.id}', 50)" style="padding: 6px 12px; background: ${Number(student.payPerClass) === 50 ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'rgba(255,255,255,.05)'}; color: ${Number(student.payPerClass) === 50 ? 'white' : '#6b7280'}; border: 2px solid ${Number(student.payPerClass) === 50 ? '#22c55e' : 'rgba(255,255,255,.2)'}; border-radius: 6px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-size: 12px;}">$50</button>
              <button class="pay-select-btn-inline" onclick="event.preventDefault(); selectInlinePayAmount(this, '${student.id}', 75)" style="padding: 6px 12px; background: ${Number(student.payPerClass) === 75 ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'rgba(255,255,255,.05)'}; color: ${Number(student.payPerClass) === 75 ? 'white' : '#6b7280'}; border: 2px solid ${Number(student.payPerClass) === 75 ? '#22c55e' : 'rgba(255,255,255,.2)'}; border-radius: 6px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-size: 12px;">$75</button>
              <button class="pay-select-btn-inline" onclick="event.preventDefault(); selectInlinePayAmount(this, '${student.id}', 100)" style="padding: 6px 12px; background: ${Number(student.payPerClass) === 100 ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'rgba(255,255,255,.05)'}; color: ${Number(student.payPerClass) === 100 ? 'white' : '#6b7280'}; border: 2px solid ${Number(student.payPerClass) === 100 ? '#22c55e' : 'rgba(255,255,255,.2)'}; border-radius: 6px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-size: 12px;">$100</button>
            </div>
            <input type="number" id="inline-pay-${student.id}" value="${student.payPerClass || 0}" placeholder="Custom amount" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label style="color: #eab308; font-weight: 700;">üí∞ Credit Balance</label>
            <div style="margin-bottom: 6px; font-size: 11px; color: #94a3b8;">Auto-applies to upcoming classes</div>
            <div style="position: relative;">
              <span style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: #eab308; font-weight: 700;">$</span>
              <input type="number" id="inline-balance-${student.id}" value="${student.balance || 0}" placeholder="0.00" step="0.01" min="0" style="padding-left: 28px; background: rgba(234,179,8,.1); border: 2px solid rgba(234,179,8,.3); color: #eab308; font-weight: 700;" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
            </div>
          </div>

          <div class="inline-form-group">
            <label>Phone</label>
            <input type="tel" id="inline-phone-${student.id}" value="${escapeHtml(student.phone || '')}" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label>Email</label>
            <input type="email" id="inline-email-${student.id}" value="${escapeHtml(student.email || '')}" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label>Aliases (comma-separated)</label>
            <input type="text" id="inline-aliases-${student.id}" value="${escapeHtml(aliases.join(', '))}" onkeydown="if(event.key==='Enter'){event.preventDefault();saveInlineEdit('${student.id}');}">
          </div>

          <div class="inline-form-group">
            <label>Notes (Ctrl+Enter to save)</label>
            <textarea id="inline-notes-${student.id}" onkeydown="if(event.key==='Enter'&&event.ctrlKey){event.preventDefault();saveInlineEdit('${student.id}');}">${escapeHtml(student.notes || '')}</textarea>
          </div>

          <div class="inline-actions">
            <button class="action-btn edit-btn" onclick="saveInlineEdit('${student.id}')" style="flex: 2;">
              Save
            </button>
            <button class="action-btn waiting-btn" onclick="moveToWaitingList('${student.id}')">
              Waiting
            </button>
            <button class="action-btn delete-btn" onclick="deleteStudent('${student.id}')">
              Delete
            </button>
          </div>
          <button class="btn btn-secondary" onclick="cancelInlineEdit('${student.id}')" style="width: 100%; margin-top: 8px; padding: 10px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; color: white; font-weight: 600; cursor: pointer;">
            Cancel
          </button>
        </div>
      `;

          return card;
        }

        // ===== FILTER STUDENTS =====
        function filterStudents() {
          const searchTerm = (document.getElementById('studentSearchInput')?.value || '').toLowerCase().trim();
          const groupFilter = document.getElementById('filterGroup')?.value || '';
          const statusFilter = document.getElementById('filterStatus')?.value || '';
          const paymentFilter = document.getElementById('filterPayment')?.value || '';
          const sortPrice = document.getElementById('sortPrice')?.value || '';

          // FILTER PERSISTENCE: Save current filter state
          currentFilters.search = searchTerm;
          currentFilters.group = groupFilter;
          currentFilters.status = statusFilter;
          currentFilters.payment = paymentFilter;
          currentFilters.sort = sortPrice;

          let cards = Array.from(document.querySelectorAll('.student-item'));
          let visibleCount = 0;

          // Filter cards
          cards.forEach(card => {
            const name = card.getAttribute('data-name') || '';
            const group = card.getAttribute('data-group') || '';
            const phone = card.getAttribute('data-phone') || '';
            const email = card.getAttribute('data-email') || '';
            const notes = card.getAttribute('data-notes') || '';
            const status = card.getAttribute('data-status') || '';

            const searchMatch =
              searchTerm === '' ||
              name.includes(searchTerm) ||
              group.includes(searchTerm) ||
              phone.includes(searchTerm) ||
              email.includes(searchTerm) ||
              notes.includes(searchTerm);

            // Group filter
            let groupMatch = !groupFilter;
            if (groupFilter === 'no-group') {
              groupMatch = !group || group === 'n/a' || group.trim() === '';
            } else if (groupFilter) {
              groupMatch = group === groupFilter.toLowerCase();
            } else {
              groupMatch = true;
            }

            // Status filter
            const statusMatch = !statusFilter || status === statusFilter;

            // Payment filter - check for credit balance
            let paymentMatch = !paymentFilter;
            if (paymentFilter === 'credit') {
              const balance = parseFloat(card.getAttribute('data-balance') || '0');
              paymentMatch = balance > 0;
            } else if (paymentFilter === 'unpaid') {
              // Unpaid logic would require calendar data integration
              paymentMatch = true;
            } else {
              paymentMatch = true;
            }

            if (searchMatch && groupMatch && statusMatch && paymentMatch) {
              card.style.display = 'flex';
              visibleCount++;
            } else {
              card.style.display = 'none';
            }
          });

          // Sort visible cards by price
          if (sortPrice) {
            const grid = document.getElementById('studentGrid');
            const visibleCards = cards.filter(card => card.style.display === 'flex');

            visibleCards.sort((a, b) => {
              const priceA = parseInt(a.getAttribute('data-pay') || '0');
              const priceB = parseInt(b.getAttribute('data-pay') || '0');

              if (sortPrice === 'highest') {
                return priceB - priceA;
              } else if (sortPrice === 'lowest') {
                return priceA - priceB;
              }
              return 0;
            });

            // Reorder DOM elements
            visibleCards.forEach(card => {
              grid.appendChild(card);
            });
          }
        }

        function clearFilters() {
          const searchInput = document.getElementById('studentSearchInput');
          const filterGroup = document.getElementById('filterGroup');
          const filterStatus = document.getElementById('filterStatus');
          const filterPayment = document.getElementById('filterPayment');
          const sortPrice = document.getElementById('sortPrice');

          if (searchInput) searchInput.value = '';
          if (filterGroup) filterGroup.value = '';
          if (filterStatus) filterStatus.value = '';
          if (filterPayment) filterPayment.value = '';
          if (sortPrice) sortPrice.value = '';

          // FILTER PERSISTENCE: Clear saved filter state
          currentFilters.search = '';
          currentFilters.group = '';
          currentFilters.status = '';
          currentFilters.payment = '';
          currentFilters.sort = '';

          filterStudents();
        }

        // ===== INLINE EDITING =====
        // BEGIN FEATURE 2 - Instant Group Switch Function

        // Helper function to update a single student card's display without re-sorting
        function updateStudentCardDisplay(student) {
          const card = document.getElementById(`card-${student.id}`);
          if (!card) {
            console.warn('Card not found for student:', student.id);
            return;
          }

          // Update group display
          const groupDisplay = card.querySelector('.student-group');
          if (groupDisplay) {
            groupDisplay.textContent = `Group ${student.group || 'N/A'}`;
          }

          // Update pay display - find the correct info-value for PAY/CLASS
          const infoRows = card.querySelectorAll('.info-row');
          infoRows.forEach(row => {
            const label = row.querySelector('.info-label');
            if (label && label.textContent === 'PAY/CLASS') {
              const payDisplay = row.querySelector('.info-value');
              if (payDisplay) {
                payDisplay.textContent = formatCurrency(student.payPerClass || 0, '$');
              }
            }
          });

          // Update group button active states (buttons A-F)
          const allButtonContainers = card.querySelectorAll('.group-buttons');
          allButtonContainers.forEach(container => {
            const buttons = container.querySelectorAll('.btn');
            buttons.forEach(btn => {
              const btnText = btn.querySelector('.btn-txt')?.textContent.trim() || btn.textContent.trim();

              // Check if this is a group button (single letter A-F)
              if (btnText.length === 1 && /[A-F]/.test(btnText)) {
                if ((student.group || '').toUpperCase() === btnText) {
                  btn.classList.add('active');
                } else {
                  btn.classList.remove('active');
                }
              }

              // Check if this is a payment button (starts with $)
              if (btnText.startsWith('$')) {
                const btnAmount = parseInt(btnText.replace('$', ''));
                if (Number(student.payPerClass) === btnAmount) {
                  btn.classList.add('active');
                } else {
                  btn.classList.remove('active');
                }
              }
            });
          });
        }

        async function changeStudentGroup(studentId, newGroup) {
          // Prevent event bubbling
          event.stopPropagation();

          // Find student in both local array and cache
          const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));
          if (!student) {
            console.error('Student not found:', studentId);
            return;
          }

          // Check if already in this group
          if ((student.group || '').toUpperCase() === newGroup.toUpperCase()) {
            return; // Already in this group, no action needed
          }

          const oldGroup = student.group || 'No Group';

          // Update student group
          student.group = newGroup;

          // Save only this student to Supabase
          await saveStudent(student);

          // Update cache
          window.studentsCache = students;

          // Show success feedback
          showNotification(`‚úÖ ${student.name} moved to Group ${newGroup}`, 'success');

          // Log to notification center
          if (window.NotificationCenter) {
            await window.NotificationCenter.add(
              window.NotificationCenter.NotificationType.GROUP_CHANGE,
              `Group Changed: ${oldGroup} ‚Üí ${newGroup}`,
              `${student.name} was moved from ${oldGroup} to ${newGroup}`,
              {
                studentName: student.name,
                groupName: newGroup,
                metadata: {
                  oldGroup: oldGroup,
                  newGroup: newGroup,
                  timestamp: new Date().toISOString(),
                },
              }
            );
          }

          // Update the card's display without re-sorting
          updateStudentCardDisplay(student);
        }

        async function changeStudentPayAmount(studentId, newAmount) {
          // Prevent event bubbling
          event.stopPropagation();

          // Find student in local array
          const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));
          if (!student) {
            console.error('Student not found:', studentId);
            return;
          }

          // Check if already this amount (compare as numbers)
          if (Number(student.payPerClass) === Number(newAmount)) {
            return; // Already this amount, no action needed
          }

          // Update student pay amount
          student.payPerClass = Number(newAmount);

          // Save only this student to Supabase
          await saveStudent(student);

          // Update cache
          window.studentsCache = students;

          // Show success feedback
          showNotification(`‚úÖ ${student.name} pay/class set to $${newAmount}`, 'success');

          // Update the card's display without re-sorting
          updateStudentCardDisplay(student);
        }
        // END FEATURE 2

        function toggleInlineEdit(studentId, event) {
          // Don't open edit if clicking on status badge, toggle, or group buttons
          if (
            event &&
            (event.target.closest('.status-pill-single') ||
              event.target.closest('.mini-toggle') ||
              event.target.closest('.group-btn') ||
              event.target.closest('.group-buttons'))
          ) {
            return;
          }

          const card = document.getElementById(`card-${studentId}`);
          if (!card) return;

          // Toggle edit mode
          if (card.classList.contains('editing')) {
            card.classList.remove('editing');
            return;
          }

          // Close any other open edit cards
          document.querySelectorAll('.student-item.editing').forEach(item => {
            if (item.id !== `card-${studentId}`) {
              item.classList.remove('editing');
            }
          });

          card.classList.add('editing');
        }

        function cancelInlineEdit(studentId) {
          const card = document.getElementById(`card-${studentId}`);
          if (card) {
            card.classList.remove('editing');
          }
        }

        async function saveInlineEdit(studentId) {
          debugLog('üöÄ saveInlineEdit() called for studentId:', studentId);

          // Convert to number for comparison (passed as string from onclick)
          const numericId = parseInt(studentId);
          const student = students.find(s => s.id === numericId);
          if (!student) {
            console.error('‚ùå Student not found:', studentId);
            return;
          }

          const nameInput = document.getElementById(`inline-name-${studentId}`);
          const groupInput = document.getElementById(`inline-group-${studentId}`);
          const payInput = document.getElementById(`inline-pay-${studentId}`);
          const balanceInput = document.getElementById(`inline-balance-${studentId}`);
          const phoneInput = document.getElementById(`inline-phone-${studentId}`);
          const emailInput = document.getElementById(`inline-email-${studentId}`);
          const aliasesInputEl = document.getElementById(`inline-aliases-${studentId}`);
          const notesInput = document.getElementById(`inline-notes-${studentId}`);

          if (!nameInput) {
            console.error('‚ùå Input elements not found for student:', studentId);
            return;
          }

          const name = nameInput.value.trim();
          const group = groupInput.value.trim();
          const payPerClass = parseFloat(payInput.value) || 0;
          const balance = parseFloat(balanceInput.value) || 0;
          const phone = phoneInput.value.trim();
          const email = emailInput.value.trim();
          const aliasesInput = aliasesInputEl.value.trim();
          const aliases = aliasesInput
            ? aliasesInput
                .split(',')
                .map(a => a.trim())
                .filter(a => a)
            : [];
          const notes = notesInput.value.trim();

          if (!name) {
            showNotificationSimple('Please enter student name', 'warning');
            nameInput.focus();
            return;
          }

          // Track changes for email notification
          let changes = [];
          // Check for profile changes (inline edit)
          verboseLog('Old student:', JSON.parse(JSON.stringify(student))); // Deep copy for logging

          // Compare and track changes BEFORE modifying the student object
          if (student.name !== name) {
            changes.push({ field: 'Name', old: student.name, new: name });
            verboseLog('üë§ Name changed:', student.name, '‚Üí', name);
          }
          if (student.email !== email && email) {
            changes.push({ field: 'Email', old: student.email || 'Not set', new: email });
            verboseLog('‚úâÔ∏è Email changed:', student.email, '‚Üí', email);
          }
          if (student.phone !== phone && phone) {
            changes.push({ field: 'Phone Number', old: student.phone || 'Not set', new: phone });
            verboseLog('üì± Phone changed:', student.phone, '‚Üí', phone);
          }
          if (student.group !== group) {
            changes.push({ field: 'Group/Schedule', old: student.group || 'Not set', new: group });
            verboseLog('üë• Group changed:', student.group, '‚Üí', group);
          }
          if (student.payPerClass !== payPerClass) {
            changes.push({ field: 'Amount per Class', old: `$${student.payPerClass || 0}`, new: `$${payPerClass}` });
            verboseLog('üíµ Amount per class changed:', student.payPerClass, '‚Üí', payPerClass);
          }
          if (student.balance !== balance) {
            changes.push({ field: 'Balance', old: `$${student.balance || 0}`, new: `$${balance}` });
            debugLog('üí∞ Balance changed:', student.balance, '‚Üí', balance);
          }

          // Track if balance changed for manual credit edit email
          const balanceChanged = student.balance !== balance;
          const oldBalance = student.balance || 0;

          // Compare aliases arrays
          const oldAliasesArray = student.aliases || [];
          const newAliasesArray = aliases || [];
          const oldAliases = oldAliasesArray.join(', ');
          const newAliases = newAliasesArray.join(', ');

          if (oldAliases !== newAliases) {
            changes.push({ field: 'Aliases', old: oldAliases || 'None', new: newAliases || 'None' });
            verboseLog('üè∑Ô∏è Aliases changed:', `"${oldAliases}"`, '‚Üí', `"${newAliases}"`);
          }

          console.log('üìù Total changes detected:', changes.length, changes);

          student.name = name;
          student.group = group;
          student.payPerClass = payPerClass;
          student.balance = balance;
          student.phone = phone;
          student.email = email;
          student.aliases = aliases;
          student.notes = notes;

          // Save only this student to Supabase
          const savedRecord = await saveStudent(student);

          if (!savedRecord) {
            showNotificationSimple('Error saving student', 'error');
            return;
          }

          verboseLog('üíæ Student saved successfully (inline):', savedRecord.name);
          debugLog('üìß Student email:', savedRecord.email);
          debugLog('üîÑ Changes to notify:', changes);

          // Send profile update email if there are changes and student has email
          // If balance was changed manually, ask user if they want to send an email
          if (balanceChanged && savedRecord.email && savedRecord.email.trim() !== '') {
            verboseLog('üí≥ Credit balance changed - asking user about email notification');

            // Ask user if they want to send the email
            const sendEmail = confirm(
              `Do you want to send the credit change email to this student?\n\nStudent: ${savedRecord.name}\nEmail: ${savedRecord.email}\n\nPrevious Balance: $${oldBalance.toFixed(2)}\nNew Balance: $${balance.toFixed(2)}`
            );

            if (sendEmail) {
              verboseLog('üí≥ User confirmed - sending credit manual edit email');
              const emailResult = await sendCreditManualEditEmail(savedRecord, oldBalance, balance);

              if (emailResult.success) {
                showNotificationSimple(`üí≥ Credit balance updated for ${savedRecord.name}`, 'success');
                showNotificationSimple(`üìß Email sent to ${savedRecord.email}`, 'success');
                verboseLog('[Credit] ‚úÖ Manual edit email sent successfully');
              } else {
                showNotificationSimple(`üí≥ Credit balance updated for ${savedRecord.name}`, 'success');
                showNotificationSimple(`‚ö†Ô∏è Balance updated but email failed: ${emailResult.error}`, 'warning');
                console.error('[Credit] ‚ùå Email failed:', emailResult.error);
              }
            } else {
              verboseLog('üí≥ User declined - credit updated without email');
              showNotificationSimple(`üí≥ Credit balance updated for ${savedRecord.name}`, 'success');
            }

            // Remove balance from changes list since we handled it separately
            changes = changes.filter(c => c.field !== 'Balance');
          }

          // Send profile update email for other changes (if any remain)
          if (changes.length > 0 && savedRecord.email && savedRecord.email.trim() !== '') {
            debugLog('‚úÖ Sending profile update email for', changes.length, 'changes');
            sendProfileUpdateEmail(savedRecord, changes);
          } else {
            verboseLog('‚è≠Ô∏è Skipping profile update email');
            if (changes.length === 0) debugLog('   Reason: No changes detected');
            if (!savedRecord.email) debugLog('   Reason: No email address');
          }

          // No longer need localStorage for balance - it's in Supabase now

          // Update cache
          window.studentsCache = students;

          renderStudents();
          showNotificationSimple('Student updated', 'success');
        }

        // ===== STATUS MANAGEMENT =====
        async function cycleStatus(studentId) {
          // Handle both string and numeric IDs from Supabase
          const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));
          if (!student) {
            console.error(
              '‚ùå Student not found:',
              studentId,
              'Available IDs:',
              students.map(s => s.id)
            );
            return;
          }

          // Define status cycle: Active ‚Üí Paused ‚Üí Graduated ‚Üí Active
          const statusCycle = {
            [STUDENT_STATUSES.ACTIVE]: STUDENT_STATUSES.PAUSED,
            [STUDENT_STATUSES.PAUSED]: STUDENT_STATUSES.GRADUATED,
            [STUDENT_STATUSES.GRADUATED]: STUDENT_STATUSES.ACTIVE,
          };

          const oldStatus = normalizeStatus(student.status);
          const newStatus = statusCycle[oldStatus] || STUDENT_STATUSES.ACTIVE;

          student.status = newStatus;

          // Record timestamp when status changes to paused or graduated
          if (newStatus === STUDENT_STATUSES.PAUSED || newStatus === STUDENT_STATUSES.GRADUATED) {
            student.statusChangedDate = new Date().toISOString();
          } else {
            // Clear timestamp when returning to active
            student.statusChangedDate = null;
          }

          // Save only this student to Supabase
          const saved = await saveStudent(student);

          if (!saved) {
            showNotificationSimple('‚ùå Failed to update status', 'error');
            return;
          }

          // Update cache with saved record
          Object.assign(student, saved);
          window.studentsCache = students;

          // Update only the status badge on the card
          const card = document.getElementById(`card-${student.id}`);
          if (card) {
            const statusBadge = card.querySelector('.status-pill-single');
            if (statusBadge) {
              const statusDetails = getStatusDetails(newStatus);
              statusBadge.className = `status-pill-single status-${newStatus}`;
              statusBadge.textContent = statusDetails.label;

              // Add a quick animation to show the change
              statusBadge.style.transform = 'scale(1.1)';
              setTimeout(() => {
                statusBadge.style.transform = 'scale(1)';
              }, 200);
            }

            // Update data attribute for filtering
            card.setAttribute('data-status', newStatus);
          }

          // Show status-specific notification
          const statusMessages = {
            [STUDENT_STATUSES.ACTIVE]: '‚úÖ Student is now active',
            [STUDENT_STATUSES.PAUSED]: '‚è∏Ô∏è Student is now paused',
            [STUDENT_STATUSES.GRADUATED]: 'üéì Student has graduated',
          };

          showNotificationSimple(statusMessages[newStatus] || 'Status updated', 'success');

          // Log to notification center
          if (window.NotificationCenter) {
            const statusLabels = {
              [STUDENT_STATUSES.ACTIVE]: 'Active',
              [STUDENT_STATUSES.PAUSED]: 'Paused',
              [STUDENT_STATUSES.GRADUATED]: 'Graduated',
            };

            await window.NotificationCenter.add(
              window.NotificationCenter.NotificationType.STATUS_CHANGE,
              `Status Changed: ${statusLabels[oldStatus]} ‚Üí ${statusLabels[newStatus]}`,
              `${student.name}'s status changed from ${statusLabels[oldStatus]} to ${statusLabels[newStatus]}`,
              {
                studentName: student.name,
                groupName: student.group,
                metadata: {
                  oldStatus: statusLabels[oldStatus],
                  newStatus: statusLabels[newStatus],
                  timestamp: new Date().toISOString(),
                },
              }
            );
          }

          // Send status change email (MANUAL CONFIRMATION REQUIRED)
          if (student.email && student.group) {
            // Determine which email to send based on transition
            if (oldStatus === STUDENT_STATUSES.ACTIVE && newStatus === STUDENT_STATUSES.PAUSED) {
              await sendStatusChangeToPausedEmail(student, student.group);
            } else if (oldStatus === STUDENT_STATUSES.PAUSED && newStatus === STUDENT_STATUSES.ACTIVE) {
              await sendStatusChangeToActiveEmail(student, student.group);
            } else if (newStatus === STUDENT_STATUSES.GRADUATED) {
              await sendStatusChangeToGraduatedEmail(student, student.group);
            }
          }

          // Trigger forecast update if forecast modal is open
          const forecastModal = document.getElementById('earningsForecastModal');
          if (forecastModal && forecastModal.style.opacity === '1') {
            updateForecastData();
          }
        }

        async function toggleVisibility(studentId, visible) {
          console.log('üîÑ toggleVisibility called:', { studentId, visible });

          // Handle both string and numeric IDs from Supabase
          const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));
          if (!student) {
            console.error('‚ùå Student not found:', studentId);
            return;
          }

          console.log('üìù Before update:', { id: student.id, name: student.name, showInGrid: student.showInGrid });

          student.showInGrid = visible;

          console.log('üìù After update:', { id: student.id, name: student.name, showInGrid: student.showInGrid });

          // Save to Supabase
          const result = await saveStudent(student);

          if (!result) {
            console.error('‚ùå Failed to save student visibility');
            showNotificationSimple('Failed to update visibility', 'error');
            return;
          }

          console.log('‚úÖ Saved to Supabase:', result);

          // Update cache and invalidate TTL
          window.studentsCache = students;
          window.studentsCacheTimestamp = Date.now();

          // Dispatch event for calendar refresh
          window.dispatchEvent(
            new CustomEvent('students:updated', {
              detail: { source: 'toggle-visibility' },
            })
          );

          showNotificationSimple(visible ? 'Student shown in calendar' : 'Student hidden from calendar', 'success');
        }

        // ===== ADD/EDIT STUDENT MODAL =====
        function openAddStudent() {
          editingStudentId = null;
          document.getElementById('modalTitle').textContent = 'Add New Student';
          document.getElementById('studentName').value = '';
          document.getElementById('customGroups').value = '';
          document.getElementById('studentPay').value = '';
          document.getElementById('studentBalance').value = '';
          document.getElementById('studentPhone').value = '';
          document.getElementById('studentEmail').value = '';
          document.getElementById('studentAliases').value = '';
          document.getElementById('studentNotes').value = '';
          document.getElementById('currentBalanceDisplay').textContent = '';

          // Clear group selections
          document.querySelectorAll('.group-select-btn').forEach(btn => btn.classList.remove('selected'));

          // Hide inactive group buttons
          const activeGroups = (window.groupsCache || []).filter(g => g.active !== false);
          document.querySelectorAll('.group-select-btn').forEach(btn => {
            const groupLetter = btn.textContent.trim();
            const isActive = activeGroups.some(g => g.name === groupLetter);
            btn.style.display = isActive ? 'inline-block' : 'none';
          });

          // Clear pay amount selections
          document.querySelectorAll('.pay-select-btn').forEach(btn => {
            btn.classList.remove('selected');
            btn.style.background = 'rgba(255,255,255,.05)';
            btn.style.color = '#6b7280';
            btn.style.borderColor = 'rgba(255,255,255,.2)';
          });

          const modal = document.getElementById('studentModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Register with PopupManager
          window.PopupManager.register('studentModal', {
            hasBackButton: true, // Sub-modal of studentManagerModal
            closeOnOutsideClick: true,
            onBack: closeStudentModal,
            parent: 'studentManagerModal',
          });

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'flex';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX
        }

        function closeStudentModal() {
          const modal = document.getElementById('studentModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('studentModal');
          }, 250);
          // END POPUP BACK & EXIT FIX

          editingStudentId = null;
        }

        function toggleGroup(btn, group) {
          btn.classList.toggle('selected');
        }

        function selectPayAmount(btn, amount) {
          // Remove selected class from all pay buttons
          document.querySelectorAll('.pay-select-btn').forEach(b => {
            b.classList.remove('selected');
            b.style.background = 'rgba(255,255,255,.05)';
            b.style.color = '#6b7280';
            b.style.borderColor = 'rgba(255,255,255,.2)';
          });

          // Add selected class to clicked button
          btn.classList.add('selected');
          btn.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
          btn.style.color = 'white';
          btn.style.borderColor = '#22c55e';

          // Set the amount in the input field
          document.getElementById('studentPay').value = amount;
        }

        function selectInlinePayAmount(btn, studentId, amount) {
          // Get all buttons for this student's inline editor
          const container = btn.parentElement;
          container.querySelectorAll('.pay-select-btn-inline').forEach(b => {
            b.style.background = 'rgba(255,255,255,.05)';
            b.style.color = '#6b7280';
            b.style.borderColor = 'rgba(255,255,255,.2)';
          });

          // Highlight selected button
          btn.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
          btn.style.color = 'white';
          btn.style.borderColor = '#22c55e';

          // Set the amount in the input field
          document.getElementById(`inline-pay-${studentId}`).value = amount;
        }

        async function saveStudentFromModal() {
          debugLog('üöÄ saveStudentFromModal() called');
          debugLog('   - editingStudentId:', editingStudentId);

          const name = document.getElementById('studentName').value.trim();
          const payPerClass = parseFloat(document.getElementById('studentPay').value) || 0;
          const balance = parseFloat(document.getElementById('studentBalance').value) || 0;
          const phone = document.getElementById('studentPhone').value.trim();
          const email = document.getElementById('studentEmail').value.trim();
          const notes = document.getElementById('studentNotes').value.trim();
          const aliasesInput = document.getElementById('studentAliases').value.trim();
          const aliases = aliasesInput
            ? aliasesInput
                .split(',')
                .map(a => a.trim())
                .filter(a => a)
            : [];

          // Get selected groups
          const selectedGroups = Array.from(document.querySelectorAll('.group-select-btn.selected')).map(btn =>
            btn.textContent.trim()
          );
          const customGroups = document.getElementById('customGroups').value.trim();
          const allGroups = customGroups
            ? customGroups
                .split(',')
                .map(g => g.trim())
                .filter(g => g)
            : selectedGroups;
          const group = allGroups.join(', ');

          if (!name) {
            await customAlert('Please enter student name', {
              title: 'Missing Information',
              icon: '‚ö†Ô∏è',
            });
            return;
          }

          // Track changes for email notification
          let changes = [];
          let oldStudent = null;

          if (editingStudentId) {
            oldStudent = students.find(s => s.id === editingStudentId);
            if (oldStudent) {
              debugLog('üîç Checking for profile changes...');
              verboseLog('Old student:', JSON.parse(JSON.stringify(oldStudent))); // Deep copy for logging

              // Compare and track changes BEFORE modifying the student object
              if (oldStudent.name !== name) {
                changes.push({ field: 'Name', old: oldStudent.name, new: name });
                verboseLog('üë§ Name changed:', oldStudent.name, '‚Üí', name);
              }
              if (oldStudent.email !== email && email) {
                changes.push({ field: 'Email', old: oldStudent.email || 'Not set', new: email });
                verboseLog('‚úâÔ∏è Email changed:', oldStudent.email, '‚Üí', email);
              }
              if (oldStudent.phone !== phone && phone) {
                changes.push({ field: 'Phone Number', old: oldStudent.phone || 'Not set', new: phone });
                verboseLog('üì± Phone changed:', oldStudent.phone, '‚Üí', phone);
              }
              if (oldStudent.group !== group) {
                changes.push({ field: 'Group/Schedule', old: oldStudent.group || 'Not set', new: group });
                verboseLog('üë• Group changed:', oldStudent.group, '‚Üí', group);
              }
              if (oldStudent.payPerClass !== payPerClass) {
                changes.push({
                  field: 'Amount per Class',
                  old: `$${oldStudent.payPerClass || 0}`,
                  new: `$${payPerClass}`,
                });
                verboseLog('üíµ Amount per class changed:', oldStudent.payPerClass, '‚Üí', payPerClass);
              }
              if (oldStudent.balance !== balance) {
                changes.push({ field: 'Balance', old: `$${oldStudent.balance || 0}`, new: `$${balance}` });
                debugLog('üí∞ Balance changed:', oldStudent.balance, '‚Üí', balance);
              }

              // Compare aliases arrays
              const oldAliasesArray = oldStudent.aliases || [];
              const newAliasesArray = aliases || [];
              const oldAliases = oldAliasesArray.join(', ');
              const newAliases = newAliasesArray.join(', ');

              if (oldAliases !== newAliases) {
                changes.push({ field: 'Aliases', old: oldAliases || 'None', new: newAliases || 'None' });
                verboseLog('üè∑Ô∏è Aliases changed:', `"${oldAliases}"`, '‚Üí', `"${newAliases}"`);
              }

              console.log('üìù Total changes detected:', changes.length, changes);
            }
          }

          let savedStudent;

          if (editingStudentId) {
            const student = students.find(s => s.id === editingStudentId);
            if (student) {
              student.name = name;
              student.group = group;
              student.payPerClass = payPerClass;
              student.balance = balance;
              student.phone = phone;
              student.email = email;
              student.aliases = aliases;
              student.notes = notes;
              savedStudent = student;
            }
          } else {
            // For new students, create without ID - let Supabase generate it
            const newStudent = {
              name,
              group,
              payPerClass,
              balance,
              phone,
              email,
              aliases,
              notes,
              status: STUDENT_STATUSES.ACTIVE,
              showInGrid: true,
              isActive: true,
              createdAt: new Date().toISOString(),
            };
            savedStudent = newStudent;
          }

          const savedRecord = await saveStudent(savedStudent);

          if (!savedRecord) {
            showNotificationSimple('Error saving student', 'error');
            return;
          }

          verboseLog('üíæ Student saved successfully:', savedRecord.name);
          debugLog('üìß Student email:', savedRecord.email);
          debugLog('üîÑ Changes to notify:', changes);

          // Check if we should send welcome email
          const isNewStudent = !editingStudentId;
          const hadNoEmail = editingStudentId && !students.find(s => s.id === editingStudentId)?.email;
          const nowHasEmail = savedRecord.email && savedRecord.email.trim() !== '';

          // Send welcome email if: new student with email OR existing student just got email added
          if (nowHasEmail && (isNewStudent || hadNoEmail)) {
            verboseLog('üì® Sending welcome email...');
            sendWelcomeEmail(savedRecord);
          }

          // Send profile update email if there are changes and student has email
          debugLog('üîç Checking if should send profile update email...');
          debugLog('   - Changes count:', changes.length);
          debugLog('   - Has email:', savedRecord.email ? 'Yes' : 'No');
          debugLog('   - Email not empty:', savedRecord.email && savedRecord.email.trim() !== '' ? 'Yes' : 'No');

          if (changes.length > 0 && savedRecord.email && savedRecord.email.trim() !== '') {
            debugLog('‚úÖ Sending profile update email for', changes.length, 'changes');
            sendProfileUpdateEmail(savedRecord, changes);
          } else {
            verboseLog('‚è≠Ô∏è Skipping profile update email');
            if (changes.length === 0) debugLog('   Reason: No changes detected');
            if (!savedRecord.email) debugLog('   Reason: No email address');
          }

          // No longer need to save balance to localStorage - it's in Supabase now
          // Remove localStorage balance management code

          if (!editingStudentId) {
            students.push(savedRecord);
          } else if (savedStudent) {
            Object.assign(savedStudent, savedRecord);
          }

          // Update global cache
          window.studentsCache = students;

          // Dispatch event
          window.dispatchEvent(new CustomEvent('students:updated', { detail: students }));

          renderStudents();
          closeStudentModal();
          showNotificationSimple(editingStudentId ? 'Student updated' : 'Student added', 'success');
        }

        // Send welcome email to new students
        async function sendWelcomeEmail(student) {
          if (!student.email) {
            debugLog('‚ö†Ô∏è Cannot send welcome email - student has no email address');
            return;
          }

          try {
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.error('‚ùå Email system iframe not found');
              return;
            }

            // Get group schedule from groups array
            const groupNames = student.group ? student.group.split(',').map(g => g.trim()) : [];
            let groupSchedule = 'Not assigned';

            if (groupNames.length > 0 && window.groupsCache) {
              const groupSchedules = groupNames.map(groupName => {
                const group = window.groupsCache.find(g => g.name === groupName);
                return group?.schedule || groupName;
              });
              groupSchedule = groupSchedules.join(', ');
            }

            // Send message to email system iframe
            emailFrame.contentWindow.postMessage(
              {
                action: 'sendWelcomeEmail',
                student: {
                  name: student.name,
                  email: student.email,
                  group: student.group || 'Not assigned',
                  groupSchedule: groupSchedule,
                  payPerClass: student.payPerClass || 0,
                },
              },
              '*'
            );

            debugLog('üìß Welcome email sent to:', student.name, student.email);
            showNotificationSimple('üìß Welcome email sent to ' + student.name, 'success');
          } catch (error) {
            console.error('‚ùå Error sending welcome email:', error);
          }
        }

        // Send profile update email when student information changes
        async function sendProfileUpdateEmail(student, changes) {
          if (changes.length === 0) {
            return;
          }

          try {
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              console.warn('‚ö†Ô∏è Email iframe not found');
              return;
            }

            // Get group schedule
            const groupNames = student.group ? student.group.split(',').map(g => g.trim()) : [];
            let groupSchedule = 'Not assigned';

            if (groupNames.length > 0 && window.groupsCache) {
              const groupSchedules = groupNames.map(groupName => {
                const group = window.groupsCache.find(g => g.name === groupName);
                return group?.schedule || groupName;
              });
              groupSchedule = groupSchedules.join(', ');
            }

            // Check if email was changed
            const emailChange = changes.find(c => c.field === 'Email');
            const oldEmail = emailChange ? emailChange.old : null;
            const newEmail = student.email;

            // Determine which emails to send to
            const emailsToNotify = [];

            if (emailChange) {
              // Email was changed - send to both old and new
              if (oldEmail && oldEmail !== 'Not set') {
                // Send to old email with special message
                emailsToNotify.push({
                  email: oldEmail,
                  type: 'old',
                  message:
                    'Your email address has been updated. This is a confirmation to your previous email address.',
                });
              }

              if (newEmail && newEmail.trim() !== '') {
                // Send to new email
                emailsToNotify.push({
                  email: newEmail,
                  type: 'new',
                  message: null,
                });
              }
            } else {
              // Email was NOT changed - send only to current email (ONCE)
              if (newEmail && newEmail.trim() !== '') {
                emailsToNotify.push({
                  email: newEmail,
                  type: 'current',
                  message: null,
                });
              }
            }

            // Send emails
            for (const recipient of emailsToNotify) {
              emailFrame.contentWindow.postMessage(
                {
                  action: 'sendProfileUpdateEmail',
                  student: {
                    name: student.name,
                    email: recipient.email,
                    group: student.group || 'Not assigned',
                    groupSchedule: groupSchedule,
                    phone: student.phone || 'Not set',
                    aliases: (student.aliases || []).join(', ') || 'None',
                  },
                  changes: changes,
                  specialMessage: recipient.message,
                  emailType: recipient.type,
                },
                '*'
              );

              verboseLog(`üìß Profile update email sent to (${recipient.type}):`, student.name, recipient.email);
            }

            verboseLog('üìù Changes notified:', changes.map(c => c.field).join(', '));

            const notificationMessage = emailChange
              ? `üìß Profile update emails sent to old and new addresses`
              : `üìß Profile update email sent to ${student.name}`;

            showNotificationSimple(notificationMessage, 'success');
          } catch (error) {
            console.error('‚ùå Error sending profile update email:', error);
          }
        }

        // ============================================================
        // NEW STATUS CHANGE & NOTIFICATION EMAIL FUNCTIONS
        // ============================================================

        // 1. STATUS CHANGE: Active ‚Üí Paused
        async function sendStatusChangeToPausedEmail(student, groupName) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            // Show confirmation modal
            const confirmed = await confirmEmailSend(
              'Status Change: Active ‚Üí Paused',
              student.name,
              student.email,
              `Status updated to <strong>Paused</strong> for Group <strong>${groupName}</strong>`
            );

            if (!confirmed) {
              return { success: false, error: 'User cancelled' };
            }

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendStatusChangeToPausedEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'statusChangeToPausedEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 2. STATUS CHANGE: Paused ‚Üí Active
        async function sendStatusChangeToActiveEmail(student, groupName) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            const confirmed = await confirmEmailSend(
              'Status Change: Paused ‚Üí Active',
              student.name,
              student.email,
              `Welcome back! Status updated to <strong>Active</strong> for Group <strong>${groupName}</strong>`
            );

            if (!confirmed) {
              return { success: false, error: 'User cancelled' };
            }

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendStatusChangeToActiveEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'statusChangeToActiveEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 3. STATUS CHANGE: Active ‚Üí Graduated
        async function sendStatusChangeToGraduatedEmail(student, groupName) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            const confirmed = await confirmEmailSend(
              'Status Change: Active ‚Üí Graduated',
              student.name,
              student.email,
              `Congratulations! Status updated to <strong>Graduated</strong> for Group <strong>${groupName}</strong>`
            );

            if (!confirmed) {
              return { success: false, error: 'User cancelled' };
            }

            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendStatusChangeToGraduatedEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'statusChangeToGraduatedEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 4. STUDENT MARKED ABSENT (AUTO-SEND)
        async function sendAbsenceNotificationEmail(student, groupName, classDate) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            // AUTO-SEND: No confirmation required
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendAbsenceNotificationEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
                classDate: classDate,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'absenceNotificationEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 5. CLASS SCHEDULE CHANGE (AUTO-SEND)
        async function sendScheduleChangeEmail(student, groupName, oldSchedule, newSchedule) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            // AUTO-SEND: No confirmation required
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendScheduleChangeEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
                oldSchedule: oldSchedule,
                newSchedule: newSchedule,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'scheduleChangeEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 6. NEW GROUP ENROLLMENT (AUTO-SEND)
        async function sendGroupEnrollmentEmail(student, groupName, groupSchedule) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            // AUTO-SEND: No confirmation required
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendGroupEnrollmentEmail',
                student: { name: student.name, email: student.email, id: student.id },
                groupName: groupName,
                groupSchedule: groupSchedule,
                payPerClass: student.payPerClass || 0,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'groupEnrollmentEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // 7. PAYMENT RECEIPT (AUTO-SEND)
        async function sendPaymentReceiptEmail(student, paymentAmount, paymentDate, newBalance) {
          try {
            if (!student || !student.email) {
              return { success: false, error: 'No email address' };
            }

            // AUTO-SEND: No confirmation required
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!emailFrame) {
              return { success: false, error: 'Email system not loaded' };
            }

            emailFrame.contentWindow.postMessage(
              {
                action: 'sendPaymentReceiptEmail',
                student: { name: student.name, email: student.email, id: student.id },
                paymentAmount: paymentAmount,
                paymentDate: paymentDate,
                newBalance: newBalance,
              },
              '*'
            );

            return new Promise(resolve => {
              const handler = event => {
                if (event.data.action === 'paymentReceiptEmailSent') {
                  window.removeEventListener('message', handler);
                  resolve({ success: true });
                }
              };
              window.addEventListener('message', handler);
              setTimeout(() => resolve({ success: false, error: 'Timeout' }), 30000);
            });
          } catch (error) {
            return { success: false, error: error.message };
          }
        }

        // ============================================================
        // END NEW EMAIL FUNCTIONS
        // ============================================================

        async function deleteStudent(studentId) {
          verboseLog('üóëÔ∏è deleteStudent called with ID:', studentId, 'Type:', typeof studentId);

          // Ensure numeric ID
          const numericId = parseInt(studentId);

          // Load students from cache, or from Supabase if cache is empty
          let students = getCachedStudents();
          debugLog('üìã Students in cache:', students.length);

          if (!students || students.length === 0) {
            verboseLog('üì• Cache empty, loading students from Supabase...');
            students = await loadStudents();
            debugLog('‚úÖ Loaded', students.length, 'students from Supabase');
          }

          const student = students.find(s => s.id === numericId);
          if (!student) {
            console.error(
              '‚ùå Student not found:',
              numericId,
              'Available IDs:',
              students.map(s => s.id)
            );
            showNotificationSimple('Student not found', 'error');
            return;
          }

          verboseLog('üë§ Attempting to delete student:', student.name);

          const confirmed = await customConfirm(
            `Delete ${student.name}?\n\nThis will permanently remove all records.`,
            {
              title: 'Delete Student',
              icon: 'üóëÔ∏è',
              okText: 'Delete',
              type: 'danger',
            }
          );

          debugLog('‚úÖ User confirmation:', confirmed);

          if (!confirmed) return;

          const deleted = await deleteStudentRecord(studentId);
          if (!deleted) {
            showNotificationSimple('Failed to delete student', 'error');
            return;
          }

          const updatedStudents = students.filter(s => s.id !== numericId);
          window.studentsCache = updatedStudents;
          window.dispatchEvent(new CustomEvent('students:updated', { detail: updatedStudents }));

          try {
            const payments = await PaymentStore.fetchAll();
            const backupData = {
              timestamp: new Date().toISOString(),
              students: updatedStudents,
              payments,
              student_count: updatedStudents.length,
              payment_count: payments.length,
              source: 'student-delete',
            };
            await createAutoBackup(backupData);
          } catch (error) {
            console.error('Auto-backup after student delete failed:', error);
          }

          renderStudents();
          showNotificationSimple('Student deleted', 'success');
        }

        // BEGIN BULK ADD STUDENTS FEATURE
        // ===== BULK ADD STUDENTS =====
        function openBulkAddStudents() {
          const modal = document.getElementById('bulkAddStudentsModal');
          const input = document.getElementById('bulkStudentInput');
          const validationMsg = document.getElementById('bulkAddValidationMessage');

          if (!modal || !input) {
            console.error('Bulk add students modal elements not found');
            return;
          }

          // Reset state
          input.value = '';
          validationMsg.style.display = 'none';
          validationMsg.textContent = '';

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'flex';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });

          // Focus input after modal opens
          setTimeout(() => input.focus(), 100);
        }

        function closeBulkAddStudents() {
          const modal = document.getElementById('bulkAddStudentsModal');
          if (!modal) return;

          // Fade out animation
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
          }, 250);
        }

        function parseBulkStudentLine(line) {
          try {
            // BEGIN BULK ADD STUDENTS FEATURE - FLEXIBLE PARSING
            // Support multiple formats:
            // Format 1: Name - John Doe (Alias), Email - john@example.com, Phone N - 123-456-7890, Group N - A, Pay per class - $100
            // Format 2: John Doe, john@example.com, 123-456-7890, A, $100
            // Format 3: John Doe (Alias), john@example.com, (123)456-7890, A, $100

            line = line.trim();
            if (!line) return { error: 'Empty line' };

            // Try labeled format first
            const labeledNameMatch = line.match(/Name\s*-\s*([^(,]+?)(?:\s*\(([^)]+)\))?(?:,|$)/i);
            const labeledEmailMatch = line.match(/Email\s*-\s*([^,]+)/i);
            const labeledPhoneMatch = line.match(/Phone\s*N?\s*-\s*([^,]+)/i);
            const labeledGroupMatch = line.match(/Group\s*N?\s*-\s*([^,]+)/i);
            const labeledPayMatch = line.match(/Pay\s*per\s*class\s*-\s*\$?([0-9.]+)/i);

            if (labeledNameMatch) {
              // Labeled format detected
              const name = labeledNameMatch[1].trim();
              const alias = labeledNameMatch[2] ? labeledNameMatch[2].trim() : '';
              const email = labeledEmailMatch ? labeledEmailMatch[1].trim() : '';
              const phone = labeledPhoneMatch ? labeledPhoneMatch[1].trim() : '';
              const group = labeledGroupMatch ? labeledGroupMatch[1].trim() : '';
              const payPerClass = labeledPayMatch ? parseFloat(labeledPayMatch[1]) : 0;

              return { name, alias, email, phone, group, payPerClass, valid: true };
            }

            // Try comma-separated format (more flexible)
            const parts = line.split(',').map(p => p.trim());

            if (parts.length < 2) {
              return { error: 'Insufficient data - need at least name and one other field' };
            }

            // Extract name (first part, may contain alias in parentheses)
            let name = parts[0];
            let alias = '';

            const aliasMatch = name.match(/^([^(]+?)\s*\(([^)]+)\)$/);
            if (aliasMatch) {
              name = aliasMatch[1].trim();
              alias = aliasMatch[2].trim();
            }

            if (!name) {
              return { error: 'Missing name' };
            }

            // Identify remaining parts by pattern matching
            let email = '';
            let phone = '';
            let group = '';
            let payPerClass = 0;

            for (let i = 1; i < parts.length; i++) {
              const part = parts[i];

              // Check if it's an email (contains @ and .)
              if (part.includes('@') && part.includes('.')) {
                email = part;
                continue;
              }

              // Check if it's a price (contains $ or is just a number > 10)
              const priceMatch = part.match(/\$?([0-9.]+)/);
              if (priceMatch) {
                const numValue = parseFloat(priceMatch[1]);
                if (part.includes('$') || numValue >= 10) {
                  payPerClass = numValue;
                  continue;
                }
              }

              // Check if it's a phone number (contains digits and ()-. or is numeric)
              if (/[\d\-\(\)\.]{7,}/.test(part) || /^\+?\d+$/.test(part.replace(/[\s\-\(\)\.]/g, ''))) {
                phone = part;
                continue;
              }

              // Check if it's a single letter or short string (likely a group)
              if (part.length <= 3 && /^[A-Za-z0-9]+$/.test(part)) {
                group = part;
                continue;
              }

              // If nothing else matched and it's short, assume it's a group
              if (part.length <= 10) {
                group = part;
              }
            }

            return {
              name,
              alias,
              email,
              phone,
              group,
              payPerClass,
              valid: true,
            };
            // END BULK ADD STUDENTS FEATURE - FLEXIBLE PARSING
          } catch (error) {
            console.error('Error parsing line:', error);
            return { error: 'Parse error: ' + error.message };
          }
        }

        function checkDuplicateStudent(newStudent, existingStudents) {
          // Check for duplicates based on name + email + group combination
          return existingStudents.some(existing => {
            const nameMatch = existing.name.toLowerCase() === newStudent.name.toLowerCase();
            const emailMatch =
              existing.email && newStudent.email && existing.email.toLowerCase() === newStudent.email.toLowerCase();
            const groupMatch = existing.group === newStudent.group;

            return nameMatch && (emailMatch || groupMatch);
          });
        }

        async function processBulkAddStudents() {
          const input = document.getElementById('bulkStudentInput');
          const validationMsg = document.getElementById('bulkAddValidationMessage');

          if (!input || !validationMsg) {
            console.error('Bulk add input elements not found');
            return;
          }

          const rawText = input.value.trim();

          if (!rawText) {
            validationMsg.style.display = 'block';
            validationMsg.style.background = 'rgba(239, 68, 68, 0.15)';
            validationMsg.style.border = '1px solid rgba(239, 68, 68, 0.3)';
            validationMsg.style.color = '#ef4444';
            validationMsg.textContent = '‚ö†Ô∏è Please paste student records before clicking Add Students.';
            return;
          }

          try {
            // Split by newlines or semicolons
            const lines = rawText.split(/[\n;]/).filter(line => line.trim());

            if (lines.length === 0) {
              validationMsg.style.display = 'block';
              validationMsg.style.background = 'rgba(239, 68, 68, 0.15)';
              validationMsg.style.border = '1px solid rgba(239, 68, 68, 0.3)';
              validationMsg.style.color = '#ef4444';
              validationMsg.textContent = '‚ö†Ô∏è No valid student records found.';
              return;
            }

            const parsedStudents = [];
            const skippedLines = [];
            const duplicateLines = [];

            // Deep clone existing students array to avoid mutations
            const existingStudents = JSON.parse(JSON.stringify(students));

            lines.forEach((line, index) => {
              const parsed = parseBulkStudentLine(line);

              if (parsed.error || !parsed.valid) {
                skippedLines.push({ line: index + 1, reason: parsed.error || 'Invalid format' });
                return;
              }

              // Check for duplicates
              if (checkDuplicateStudent(parsed, existingStudents)) {
                duplicateLines.push({ line: index + 1, name: parsed.name });
                return;
              }

              // Add to parsed list
              parsedStudents.push(parsed);

              // Add to temporary existing list to check subsequent entries
              existingStudents.push(parsed);
            });

            if (parsedStudents.length === 0) {
              let errorMessage = '‚ö†Ô∏è No students could be added.';
              if (skippedLines.length > 0) {
                errorMessage += ` ${skippedLines.length} lines skipped due to errors.`;
              }
              if (duplicateLines.length > 0) {
                errorMessage += ` ${duplicateLines.length} duplicates found.`;
              }

              validationMsg.style.display = 'block';
              validationMsg.style.background = 'rgba(239, 68, 68, 0.15)';
              validationMsg.style.border = '1px solid rgba(239, 68, 68, 0.3)';
              validationMsg.style.color = '#ef4444';
              validationMsg.textContent = errorMessage;
              return;
            }

            // Atomic batch update - add all students at once
            const newStudents = parsedStudents.map(parsed => ({
              id: generateId(),
              name: parsed.name,
              group: parsed.group,
              payPerClass: parsed.payPerClass,
              phone: parsed.phone,
              email: parsed.email,
              aliases: parsed.alias ? [parsed.alias] : [],
              notes: '',
              status: STUDENT_STATUSES.ACTIVE,
              showInGrid: true,
              isActive: true,
              createdAt: new Date().toISOString(),
            }));

            // Validate array integrity before writing
            if (!Array.isArray(newStudents) || newStudents.some(s => !s.id || !s.name)) {
              throw new Error('Data validation failed - invalid student records');
            }

            // Append to existing students array
            students.push(...newStudents);

            // Save to localStorage
            saveStudents();

            // Refresh UI
            renderStudents();

            // Dispatch custom event for potential external listeners
            window.dispatchEvent(
              new CustomEvent('bulkAddStudents:complete', {
                detail: {
                  added: newStudents.length,
                  skipped: skippedLines.length,
                  duplicates: duplicateLines.length,
                },
              })
            );

            // Show success message
            let successMessage = `‚úÖ Successfully added ${newStudents.length} student${newStudents.length > 1 ? 's' : ''}.`;

            if (skippedLines.length > 0 || duplicateLines.length > 0) {
              successMessage += ' ';
              if (skippedLines.length > 0) {
                successMessage += `${skippedLines.length} skipped. `;
              }
              if (duplicateLines.length > 0) {
                successMessage += `${duplicateLines.length} duplicate${duplicateLines.length > 1 ? 's' : ''} ignored.`;
              }

              validationMsg.style.display = 'block';
              validationMsg.style.background = 'rgba(251, 146, 60, 0.15)';
              validationMsg.style.border = '1px solid rgba(251, 146, 60, 0.3)';
              validationMsg.style.color = '#fb923c';
              validationMsg.textContent = successMessage;
            } else {
              validationMsg.style.display = 'block';
              validationMsg.style.background = 'rgba(34, 197, 94, 0.15)';
              validationMsg.style.border = '1px solid rgba(34, 197, 94, 0.3)';
              validationMsg.style.color = '#22c55e';
              validationMsg.textContent = successMessage;
            }

            showNotificationSimple(`Bulk added ${newStudents.length} students`, 'success');

            // Clear input and close modal after success
            setTimeout(() => {
              closeBulkAddStudents();
            }, 1500);
          } catch (error) {
            console.error('Bulk add students error:', error);

            validationMsg.style.display = 'block';
            validationMsg.style.background = 'rgba(239, 68, 68, 0.15)';
            validationMsg.style.border = '1px solid rgba(239, 68, 68, 0.3)';
            validationMsg.style.color = '#ef4444';
            validationMsg.textContent = `‚ùå Error: ${error.message}. No students were added.`;
          }
        }
        // END BULK ADD STUDENTS FEATURE

        // ===== WAITING LIST =====
        function openWaitingList() {
          const content = document.getElementById('waitingListContent');

          if (waitingList.length === 0) {
            content.innerHTML =
              '<div style="grid-column: 1/-1; text-align: center; padding: 60px; color: #6b7280;">No students on waiting list</div>';
          } else {
            content.innerHTML = waitingList
              .map(
                student => `
          <div class="student-item" style="background: linear-gradient(135deg, rgba(168,85,247,.08), rgba(147,51,234,.08)); border: 2px solid rgba(168,85,247,.3);">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 16px;">
              <div style="font-size: 20px; font-weight: 700; color: #f3f4f6;">${escapeHtml(student.fullName || 'N/A')}</div>
              <button onclick="removeFromWaitingList('${student.id}')" style="background: rgba(244,67,54,.15); border: 2px solid #f44336; color: #f44336; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; font-size: 16px;" title="Remove from waiting list">√ó</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <div class="info-column">
                <span class="info-label">EMAIL</span>
                <span class="info-text">${escapeHtml(student.email || 'N/A')}</span>
              </div>
              <div class="info-column">
                <span class="info-label">PHONE</span>
                <span class="info-text">${escapeHtml(student.phone || 'N/A')}</span>
              </div>
              ${
                student.language
                  ? `
                <div class="info-column">
                  <span class="info-label">LANGUAGE</span>
                  <span class="info-text">${escapeHtml(student.language)}</span>
                </div>
              `
                  : ''
              }
              ${
                student.startDate
                  ? `
                <div class="info-column">
                  <span class="info-label">START DATE</span>
                  <span class="info-text">${new Date(student.startDate).toLocaleDateString()}</span>
                </div>
              `
                  : ''
              }
              ${
                student.notes
                  ? `
                <div class="info-column">
                  <span class="info-label">NOTES</span>
                  <span class="info-text">${escapeHtml(student.notes)}</span>
                </div>
              `
                  : ''
              }
              <div style="font-size: 11px; color: #6b7280; margin-top: 8px;">
                Added: ${new Date(student.addedDate).toLocaleDateString()}
              </div>
            </div>
          </div>
        `
              )
              .join('');
          }

          document.getElementById('waitingListModal').style.display = 'flex';

          // BEGIN POPUP BACK & EXIT FIX
          const modal = document.getElementById('waitingListModal');

          // Register with PopupManager
          window.PopupManager.register('waitingListModal', {
            hasBackButton: false, // Top-level modal
            closeOnOutsideClick: true,
            onClose: closeWaitingList,
          });

          // Fade in animation
          modal.style.opacity = '0';
          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX
        }

        function closeWaitingList() {
          const modal = document.getElementById('waitingListModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('waitingListModal');
          }, 250);
          // END POPUP BACK & EXIT FIX
        }

        function openAddWaitingList() {
          document.getElementById('waitingListModal').style.display = 'none';
          document.getElementById('waitingListFullName').value = '';
          document.getElementById('waitingListEmail').value = '';
          document.getElementById('waitingListPhone').value = '';
          document.getElementById('waitingListLanguage').value = '';
          document.getElementById('waitingListStartDate').value = '';
          document.getElementById('waitingListNotes').value = '';

          const modal = document.getElementById('addWaitingListModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Register with PopupManager
          window.PopupManager.register('addWaitingListModal', {
            hasBackButton: true, // Sub-modal of waitingListModal
            closeOnOutsideClick: true,
            onBack: closeAddWaitingList,
            parent: 'waitingListModal',
          });

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'flex';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX
        }

        function closeAddWaitingList() {
          const modal = document.getElementById('addWaitingListModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('addWaitingListModal');
          }, 250);
          // END POPUP BACK & EXIT FIX
        }

        async function saveWaitingListStudent() {
          const fullName = document.getElementById('waitingListFullName').value.trim();
          const email = document.getElementById('waitingListEmail').value.trim();
          const phone = document.getElementById('waitingListPhone').value.trim();
          const language = document.getElementById('waitingListLanguage').value.trim();
          const startDate = document.getElementById('waitingListStartDate').value;
          const notes = document.getElementById('waitingListNotes').value.trim();

          if (!fullName || !email || !phone) {
            await customAlert('Please fill in all required fields (Name, Email, Phone)', {
              title: 'Missing Information',
              icon: '‚ö†Ô∏è',
            });
            return;
          }

          waitingList.push({
            id: 'waiting-' + Date.now(),
            fullName,
            email,
            phone,
            language,
            startDate,
            notes,
            addedDate: new Date().toISOString(),
          });

          saveWaitingList();
          closeAddWaitingList();
          openWaitingList();
          showNotificationSimple('Student added to waiting list', 'success');
        }

        async function removeFromWaitingList(id) {
          const confirmed = await customConfirm('Remove this student from the waiting list?', {
            title: 'Remove from Waiting List',
            icon: 'üìã',
            okText: 'Remove',
          });

          if (!confirmed) return;

          waitingList = waitingList.filter(s => s.id !== id);
          saveWaitingList();
          openWaitingList();
          showNotificationSimple('Student removed from waiting list', 'success');
        }

        async function moveToWaitingList(studentId) {
          const student = students.find(s => s.id === studentId);
          if (!student) return;

          const confirmed = await customConfirm(
            `Move ${student.name} to waiting list?\n\nThis will set their status to Paused.`,
            {
              title: 'Move to Waiting List',
              icon: 'üìã',
              okText: 'Move',
            }
          );

          if (!confirmed) return;

          student.status = STUDENT_STATUSES.PAUSED;
          student.statusChangedDate = new Date().toISOString();

          waitingList.push({
            id: 'waiting-' + Date.now(),
            fullName: student.name,
            email: student.email || '',
            phone: student.phone || '',
            language: '',
            startDate: '',
            notes: student.notes || '',
            addedDate: new Date().toISOString(),
            originalStudentId: student.id,
          });

          saveStudents();
          saveWaitingList();
          renderStudents();
          showNotificationSimple(`${student.name} moved to waiting list`, 'success');
        }

        // ===== DUPLICATE DETECTION =====
        function findDuplicates() {
          const duplicateGroups = [];
          const processed = new Set();

          students
            .filter(s => s.isActive !== false)
            .forEach((student, index, arr) => {
              if (processed.has(student.id)) return;

              const matches = [];

              arr.forEach((otherStudent, otherIndex) => {
                if (index === otherIndex || processed.has(otherStudent.id)) return;

                const name1 = (student.name || '').toLowerCase().trim().replace(/\s+/g, ' ');
                const name2 = (otherStudent.name || '').toLowerCase().trim().replace(/\s+/g, ' ');
                const email1 = (student.email || '').toLowerCase().trim();
                const email2 = (otherStudent.email || '').toLowerCase().trim();

                const namesMatch =
                  name1 === name2 ||
                  (name1.includes(name2) && name2.length > 3) ||
                  (name2.includes(name1) && name1.length > 3);
                const emailsMatch = email1 && email2 && email1 === email2;

                if (namesMatch || emailsMatch) {
                  matches.push(otherStudent);
                  processed.add(otherStudent.id);
                }
              });

              if (matches.length > 0) {
                processed.add(student.id);
                duplicateGroups.push({
                  primary: student,
                  duplicates: matches,
                });
              }
            });

          displayDuplicates(duplicateGroups);
        }

        function displayDuplicates(duplicateGroups) {
          const content = document.getElementById('duplicatesContent');

          if (duplicateGroups.length === 0) {
            content.innerHTML = `
          <div style="text-align: center; padding: 60px 20px;">
            <h3 style="color: #8ab4ff; margin-bottom: 10px; font-size: 24px;">No Duplicates Found</h3>
            <p style="color: #6b7280;">All student records appear to be unique.</p>
          </div>
        `;
          } else {
            content.innerHTML = `
          <div style="background: linear-gradient(135deg, rgba(251,146,60,.15), rgba(249,115,22,.15)); padding: 20px; border-radius: 12px; border: 2px solid rgba(251,146,60,.3); margin-bottom: 25px;">
            <h3 style="margin: 0 0 6px 0; color: #fb923c; font-size: 18px;">Found ${duplicateGroups.length} Potential Duplicate${duplicateGroups.length > 1 ? 's' : ''}</h3>
            <p style="margin: 0; color: rgba(255,255,255,0.8); font-size: 14px;">Review and merge duplicate student records to keep your data clean.</p>
          </div>
          ${duplicateGroups
            .map(
              (group, groupIndex) => `
            <div style="background: rgba(255,255,255,.04); border: 2px solid rgba(138,180,255,.15); border-radius: 16px; padding: 24px; margin-bottom: 20px;">
              <h3 style="color: #8ab4ff; margin: 0 0 20px 0; font-size: 18px;">
                <span style="background: #8ab4ff; color: white; width: 32px; height: 32px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 700; margin-right: 10px;">${groupIndex + 1}</span>
                Duplicate Group
              </h3>

              ${[group.primary, ...group.duplicates]
                .map((student, index) => {
                  const isPrimary = index === 0;
                  return `
                  <div style="background: ${isPrimary ? 'rgba(138,180,255,.12)' : 'rgba(255,255,255,.03)'}; border: 2px solid ${isPrimary ? '#8ab4ff' : 'rgba(255,255,255,.08)'}; border-radius: 12px; padding: 18px; margin-bottom: 12px; position: relative;">
                    ${isPrimary ? '<div style="position: absolute; top: -10px; left: 20px; background: #8ab4ff; color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 700;">PRIMARY</div>' : ''}

                    <div style="display: flex; justify-content: space-between; align-items: start; margin-top: ${isPrimary ? '10px' : '0'};">
                      <div style="flex: 1;">
                        <div style="font-size: 18px; font-weight: 700; color: white; margin-bottom: 12px;">${escapeHtml(student.name)}</div>

                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                          <div>
                            <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">GROUP</div>
                            <div style="font-size: 14px; color: white;">${student.group || 'N/A'}</div>
                          </div>
                          <div>
                            <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">EMAIL</div>
                            <div style="font-size: 14px; color: white;">${student.email || 'N/A'}</div>
                          </div>
                          <div>
                            <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">PHONE</div>
                            <div style="font-size: 14px; color: white;">${student.phone || 'N/A'}</div>
                          </div>
                          <div>
                            <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">PAY/CLASS</div>
                            <div style="font-size: 14px; color: white;">${formatCurrency(student.payPerClass || 0, '$')}</div>
                          </div>
                        </div>

                        ${
                          student.notes
                            ? `
                          <div style="margin-top: 12px;">
                            <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">NOTES</div>
                            <div style="font-size: 13px; color: rgba(255,255,255,0.8);">${escapeHtml(student.notes)}</div>
                          </div>
                        `
                            : ''
                        }
                      </div>

                      ${
                        !isPrimary
                          ? `
                        <button onclick="mergeDuplicates('${group.primary.id}', '${student.id}')" style="padding: 10px 16px; background: linear-gradient(135deg, #4ade80, #22c55e); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 13px; white-space: nowrap; margin-left: 16px; box-shadow: 0 4px 12px rgba(34,197,94,0.3);">
                          Merge into Primary
                        </button>
                      `
                          : ''
                      }
                    </div>
                  </div>
                `;
                })
                .join('')}
            </div>
          `
            )
            .join('')}
        `;
          }

          document.getElementById('duplicatesModal').style.display = 'flex';
        }

        function closeDuplicatesModal() {
          document.getElementById('duplicatesModal').style.display = 'none';
        }

        async function mergeDuplicates(primaryId, duplicateId) {
          const primary = students.find(s => s.id === primaryId);
          const duplicate = students.find(s => s.id === duplicateId);

          if (!primary || !duplicate) {
            showNotificationSimple('Student not found', 'error');
            return;
          }

          const confirmed = await customConfirm(
            `Merge "${duplicate.name}" into "${primary.name}"?\n\nThis will transfer all information and delete the duplicate entry.\n\nThis action cannot be undone.`,
            {
              title: 'Merge Duplicates',
              icon: '‚ö†Ô∏è',
              okText: 'Merge',
              type: 'danger',
            }
          );

          if (!confirmed) {
            return;
          }

          // Merge missing information
          if (!primary.email && duplicate.email) primary.email = duplicate.email;
          if (!primary.phone && duplicate.phone) primary.phone = duplicate.phone;
          if (!primary.notes && duplicate.notes) {
            primary.notes = duplicate.notes;
          } else if (duplicate.notes && primary.notes !== duplicate.notes) {
            primary.notes += '\n[Merged]: ' + duplicate.notes;
          }

          // Merge groups
          const primaryGroups = new Set(
            (primary.group || '')
              .split(',')
              .map(g => g.trim())
              .filter(g => g)
          );
          const duplicateGroups = (duplicate.group || '')
            .split(',')
            .map(g => g.trim())
            .filter(g => g);
          duplicateGroups.forEach(g => primaryGroups.add(g));
          primary.group = Array.from(primaryGroups).join(', ');

          // Merge aliases
          if (duplicate.aliases && duplicate.aliases.length > 0) {
            if (!primary.aliases) primary.aliases = [];
            duplicate.aliases.forEach(alias => {
              if (!primary.aliases.includes(alias)) {
                primary.aliases.push(alias);
              }
            });
          }

          // Mark duplicate as inactive
          duplicate.isActive = false;

          saveStudents();
          showNotificationSimple(`Merged "${duplicate.name}" into "${primary.name}"`, 'success');

          setTimeout(() => {
            findDuplicates();
          }, 500);
        }

        // ===== EVENT LISTENERS FOR INTEGRATION =====

        // Listen for group updates from Group Manager
        window.addEventListener('groups:updated', function (event) {
          if (event.detail) {
            groups = event.detail;

            // Refresh student display if Student Manager is open
            if (document.getElementById('studentManagerModal')?.style.display === 'block') {
              renderStudents();
            }
          }
        });

        // Listen for payment updates from Payment Records
        window.addEventListener('payments:updated', function (event) {
          // Can be used to update payment indicators in the future
        });

        // Listen for requests to open student manager with specific filter
        window.addEventListener('openStudentManager:withFilter', function (event) {
          openStudentManager();
          if (event.detail?.name) {
            const searchInput = document.getElementById('studentSearchInput');
            if (searchInput) {
              searchInput.value = event.detail.name;
              filterStudents();
            }
          }
        });

        // Click outside to close editing
        document.addEventListener('click', function (event) {
          if (!event.target.closest('.student-item')) {
            document.querySelectorAll('.student-item.editing').forEach(card => {
              card.classList.remove('editing');
            });
          }
        });

        // ===== INITIALIZE GLOBAL DATA =====
        if (!window.globalData) window.globalData = {};
        window.globalData.students = students;

        // ============================================================================
        let selectedGroupDays = [];
        // ============================================================================
        // üìö GROUP MANAGER - EXACT STANDALONE VERSION
        // ============================================================================

        // Groups will be loaded from Supabase on initialization
        let groups = [];
        let countdownTimer;

        // Groups are loaded during core initialization; render lazily when needed.

        // ===== OPEN/CLOSE GROUP MANAGER =====
        function openGroupManager() {
          const modal = document.getElementById('groupManagerModal');
          document.getElementById('settingsMenu').style.display = 'none';

          // BEGIN POPUP BACK & EXIT FIX
          // Register with PopupManager
          window.PopupManager.register('groupManagerModal', {
            hasBackButton: false, // Top-level modal
            closeOnOutsideClick: true,
            onClose: closeGroupManager,
          });

          // Fade in animation
          modal.style.opacity = '0';
          modal.style.display = 'block';

          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
          // END POPUP BACK & EXIT FIX

          renderGroups();
        }

        function closeGroupManager() {
          const modal = document.getElementById('groupManagerModal');

          // BEGIN POPUP BACK & EXIT FIX
          // Fade out before hiding
          modal.style.opacity = '0';

          setTimeout(() => {
            modal.style.display = 'none';
            window.PopupManager?.activePopups?.delete('groupManagerModal');
          }, 250);
          // END POPUP BACK & EXIT FIX

          if (countdownTimer) {
            clearInterval(countdownTimer);
            countdownTimer = null;
          }
        }

        function closeGroupManagerOnOutsideClick(event) {
          if (event.target.id === 'groupManagerModal') {
            closeGroupManager();
          }
        }

        // ===== RENDER GROUP CARDS =====
        function renderGroups() {
          const grid = document.getElementById('groupGrid');
          if (!grid) return;
          groups = window.groupsCache || groups || [];
          grid.innerHTML = '';

          if (groups.length === 0) {
            grid.innerHTML =
              '<div style="text-align:center;padding:60px 20px;color:#94a3b8;grid-column:1/-1;"><div style="font-size:48px;margin-bottom:16px;opacity:0.5;">üìö</div><p style="font-size:16px;">No groups yet. Click "+ Add Group" to get started.</p></div>';
            return;
          }

          // Sort groups alphabetically by name
          const sortedGroups = [...groups].sort((a, b) => {
            const nameA = String(a.name || '').toUpperCase();
            const nameB = String(b.name || '').toUpperCase();
            return nameA.localeCompare(nameB);
          });

          sortedGroups.forEach(group => {
            const card = document.createElement('div');
            card.className = 'group-card';
            const isActive = group.active ?? true;
            card.innerHTML = `
          <div class="group-title" style="display: flex; justify-content: space-between; align-items: center;">
            <span>${escapeHtml(group.name)}</span>
            <label class="mini-toggle" title="${isActive ? 'Group visible' : 'Group hidden'}" onclick="event.stopPropagation()" style="margin: 0;">
              <input type="checkbox" ${isActive ? 'checked' : ''} onchange="toggleGroupVisibility('${escapeHtml(group.name)}', this.checked)">
              <span class="slider"></span>
            </label>
          </div>
          <div class="schedule-display">
            ${group.schedule ? renderScheduleSlots(group.schedule) : '<em style="color:#94a3b8;font-size:0.9rem;">No schedule set</em>'}
          </div>
          <div class="group-actions">
            <button onclick="editGroupSchedule('${escapeHtml(group.name)}')">‚úèÔ∏è Edit Schedule</button>
            <button onclick="deleteGroup('${escapeHtml(group.name)}')">üóëÔ∏è Delete</button>
          </div>
        `;
            grid.appendChild(card);
          });
          updateScheduleItemStates();
        }

        // ===== RENDER SLOT CHIPS =====
        function renderScheduleSlots(scheduleStr) {
          return scheduleStr
            .split(',')
            .map(slot => {
              const parts = slot.trim().split(' ');
              const day = parts[0] || '';
              const time = parts.slice(1).join(' ') || '';
              return `<div class="schedule-item" data-day="${day}" data-time="${time}">
          <div>${slot.trim()}</div>
        </div>`;
            })
            .join('');
        }

        // ===== ADD GROUP =====
        async function addNewGroup() {
          const name = await customPrompt('Enter group name:', '', {
            title: 'Add Group',
            icon: '‚ûï',
            okText: 'Add Group',
          });

          if (!name) return;

          if (groups.some(g => g.name === name)) {
            await customAlert('Group name already exists!', {
              title: 'Duplicate Group',
              icon: '‚ö†Ô∏è',
            });
            return;
          }
          // Persist only the new group to Supabase to get an id
          const saved = await saveGroup({ name, schedule: '' });
          if (saved && saved.id) {
            groups.push({ id: saved.id, name: saved.group_name || name, schedule: saved.schedule || '' });
            // Update cache and notify
            window.groupsCache = groups;
            window.dispatchEvent(new CustomEvent('groups:updated', { detail: groups }));
            window.dispatchEvent(new CustomEvent('schedules:updated', { detail: groups }));
            showToast('‚úÖ Group Added');
            renderGroups();
          } else {
            await customAlert('Could not save group. Please try again.');
          }
        }

        // ===== DELETE GROUP =====
        async function deleteGroup(name) {
          const confirmed = await customConfirm(`Delete group "${name}"?\n\nThis action cannot be undone.`, {
            title: 'Delete Group',
            icon: 'üóëÔ∏è',
            okText: 'Delete',
            type: 'danger',
          });

          if (!confirmed) return;
          // Collect ids of matching groups to delete exact rows
          const idsToDelete = groups.filter(g => g.name === name && g.id).map(g => g.id);
          try {
            if (idsToDelete.length > 0) {
              const { error } = await supabase.from('groups').delete().in('id', idsToDelete);
              if (error) console.error('‚ùå Error deleting groups by id:', error);
            } else {
              // Fallback: delete by group_name
              const { error } = await supabase.from('groups').delete().eq('group_name', name);
              if (error) console.error('‚ùå Error deleting groups by name:', error);
            }
          } catch (e) {
            console.error('‚ùå Delete operation failed:', e);
          }
          // Update local state
          groups = groups.filter(g => g.name !== name);
          window.groupsCache = groups;
          window.dispatchEvent(new CustomEvent('groups:updated', { detail: groups }));
          window.dispatchEvent(new CustomEvent('schedules:updated', { detail: groups }));
          showToast('üóëÔ∏è Group Deleted');
          renderGroups();
        }

        // ===== TOGGLE GROUP VISIBILITY =====
        async function toggleGroupVisibility(groupName, visible) {
          const group = groups.find(g => g.name === groupName);
          if (!group) return;

          group.active = visible;

          // Save to Supabase
          await saveGroup(group);

          // Update cache and invalidate TTL
          window.groupsCache = groups;
          window.groupsCacheTimestamp = Date.now();

          // Dispatch events for UI updates
          window.dispatchEvent(new CustomEvent('groups:updated', { detail: groups }));
          window.dispatchEvent(new CustomEvent('schedules:updated', { detail: groups }));

          showToast(visible ? '‚úÖ Group visible' : 'üëÅÔ∏è‚Äçüó®Ô∏è Group hidden');
        }

        // ===== EDIT SCHEDULE =====
        function editGroupSchedule(groupName) {
          const grid = document.getElementById('groupGrid');
          grid.querySelectorAll('.schedule-editor').forEach(el => el.remove());
          const group = groups.find(g => g.name === groupName);
          if (!group) return;

          const card = [...grid.children].find(c => {
            const titleSpan = c.querySelector('.group-title span');
            return titleSpan && titleSpan.textContent === groupName;
          });

          if (!card) return;

          const editor = document.createElement('div');
          editor.className = 'schedule-editor';
          editor.innerHTML = `
        <h4 style="color:#a855f7;margin:0 0 12px 0;font-size:1rem;">Edit Schedule for ${escapeHtml(groupName)}</h4>
        <div id="scheduleItems"></div>
        <button onclick="addScheduleItem()" style="width:100%;padding:8px;margin:10px 0;background:rgba(168,85,247,0.2);border:2px dashed rgba(168,85,247,0.5);border-radius:8px;color:#a855f7;font-weight:600;cursor:pointer;">+ Add Day/Time</button>
        <div style="display:flex;gap:10px;">
          <button onclick="renderGroups()" style="flex:1;padding:10px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);border-radius:8px;color:#fff;font-weight:600;cursor:pointer;">Cancel</button>
          <button onclick="saveScheduleEdit('${escapeHtml(groupName)}')" style="flex:2;padding:10px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:8px;color:#fff;font-weight:700;cursor:pointer;">üíæ Save</button>
        </div>
      `;
          card.appendChild(editor);

          const container = editor.querySelector('#scheduleItems');
          const slots = group.schedule ? parseSchedule(group.schedule) : [{ day: 'Monday', time: '10:00 AM' }];
          slots.forEach(s => addScheduleItem(s.day, s.time, container));

          // Add one-time schedule overrides if they exist
          if (group.one_time_schedules && Array.isArray(group.one_time_schedules)) {
            group.one_time_schedules.forEach(override => {
              addScheduleItem(override.day, override.time, container, true, override.date);
            });
          }
        }

        // ===== ADD SCHEDULE ITEM =====
        function addScheduleItem(day = 'Monday', time = '10:00 AM', container, isOneTime = false, overrideDate = '') {
          const c = container || document.querySelector('#scheduleItems');
          if (!c) return;

          // Convert 12h AM/PM to 24h for HTML5 time input
          const time24 = convert12to24(time);

          const div = document.createElement('div');
          div.className = 'slot-row';
          div.innerHTML = `
        <select style="flex:1;">
          ${['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(d => `<option ${d === day ? 'selected' : ''}>${d}</option>`).join('')}
        </select>
        <input type="time" value="${time24}" style="flex:1;" onkeydown="if(event.key==='Enter'){event.target.closest('.group-card').querySelector('button[onclick*=saveScheduleEdit]').click();}">
        <label style="display: flex; align-items: center; gap: 6px; white-space: nowrap; font-size: 12px; color: rgba(255, 255, 255, 0.8);" title="Check for one-time temporary class">
          <input type="checkbox" class="one-time-checkbox" ${isOneTime ? 'checked' : ''} onchange="toggleOneTimeDate(this)">
          <span style="font-size: 11px; opacity: 0.9;">üìÖ Temp</span>
        </label>
        <input type="date" class="one-time-date" value="${overrideDate}" style="flex:1;" placeholder="Select date for one-time class" title="Date for this one-time class">
        <button onclick="this.parentElement.remove()">üóëÔ∏è</button>
      `;
          c.appendChild(div);
        }

        // ===== TOGGLE ONE-TIME DATE INPUT =====
        function toggleOneTimeDate(checkbox) {
          // When checked, just keep it checked to indicate one-time class
          // Date picker doesn't auto-open - user can click it manually if needed
          const row = checkbox.closest('.slot-row');
          const dateInput = row.querySelector('.one-time-date');
          if (dateInput && checkbox.checked && !dateInput.value) {
            // Set default date to today only if checkbox is checked and date is empty
            const today = new Date();
            dateInput.value = formatDateYYYYMMDD(today);
          }
        }

        // ===== CONVERT 12H AM/PM TO 24H =====
        function convert12to24(time12) {
          if (!time12) return '10:00';

          // If already in 24h format, return as-is
          if (!time12.includes('AM') && !time12.includes('PM')) {
            return time12.length === 5 ? time12 : '10:00';
          }

          const match = time12.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
          if (!match) return '10:00';

          let hours = parseInt(match[1]);
          const minutes = match[2];
          const period = match[3].toUpperCase();

          if (period === 'PM' && hours !== 12) hours += 12;
          if (period === 'AM' && hours === 12) hours = 0;

          return `${hours.toString().padStart(2, '0')}:${minutes}`;
        }

        // ===== CONVERT 24H TO 12H AM/PM =====
        function convert24to12(time24) {
          if (!time24) return '';
          const [hours, minutes] = time24.split(':').map(Number);
          if (isNaN(hours) || isNaN(minutes)) return time24;

          let period = 'AM';
          let hours12 = hours;

          if (hours >= 12) {
            period = 'PM';
            if (hours > 12) hours12 = hours - 12;
          }
          if (hours === 0) hours12 = 12;

          return `${hours12}:${minutes.toString().padStart(2, '0')} ${period}`;
        }

        // ===== SAVE SCHEDULE =====
        // BEGIN GROUP MANAGER SCHEDULE FIX
        async function saveScheduleEdit(groupName) {
          const card = event.target.closest('.group-card');
          if (!card) return;

          const rows = card.querySelectorAll('.slot-row');
          let schedule = []; // Regular recurring schedule
          let oneTimeSchedules = []; // One-time schedule overrides

          rows.forEach(r => {
            const d = r.querySelector('select').value.slice(0, 3);
            const t = r.querySelector('input[type="time"]').value;
            const isOneTime = r.querySelector('.one-time-checkbox')?.checked || false;
            const overrideDate = r.querySelector('.one-time-date')?.value || '';

            if (d && t) {
              // Convert 24-hour time to 12-hour AM/PM format
              const time12 = convert24to12(t);

              if (isOneTime && overrideDate) {
                // This is a one-time override
                const dayMap = {
                  Mon: 'Monday',
                  Tue: 'Tuesday',
                  Wed: 'Wednesday',
                  Thu: 'Thursday',
                  Fri: 'Friday',
                  Sat: 'Saturday',
                  Sun: 'Sunday',
                };
                const fullDayName = dayMap[d] || d;

                oneTimeSchedules.push({
                  date: overrideDate,
                  day: fullDayName,
                  time: time12,
                  oneTime: true,
                });
              } else {
                // Regular recurring schedule
                schedule.push(`${d} ${time12}`);
              }
            }
          });

          const group = groups.find(g => g.name === groupName);
          if (!group) return;

          // DETECT SCHEDULE CHANGE - Store old schedule before updating
          const oldSchedule = group.schedule || 'Not set';
          const newSchedule = schedule.join(', ');
          const scheduleChanged = oldSchedule !== newSchedule;

          debugLog('üìÖ Schedule Update Check:', {
            group: groupName,
            oldSchedule: oldSchedule,
            newSchedule: newSchedule,
            oneTimeSchedules: oneTimeSchedules,
            changed: scheduleChanged,
          });

          // CRITICAL FIX: Replace old schedule entirely (no appending)
          group.schedule = newSchedule;
          group.one_time_schedules = oneTimeSchedules;

          // Save only this group (not all groups)
          const savedGroup = await saveGroup(group);
          if (savedGroup && savedGroup.id) {
            group.id = savedGroup.id;
            group.name = savedGroup.group_name || group.name;
          }

          // Update cache and notify
          window.groupsCache = groups;
          window.dispatchEvent(new CustomEvent('groups:updated', { detail: groups }));
          window.dispatchEvent(new CustomEvent('schedules:updated', { detail: groups }));

          // SEND SCHEDULE UPDATE EMAILS if schedule changed
          if (scheduleChanged) {
            debugLog('üìß Schedule changed, sending update emails to all students in', groupName);

            // Get all students in this group
            const studentsInGroup =
              window.studentsCache?.filter(student => {
                if (!student.group) return false;
                const studentGroups = student.group.split(',').map(g => g.trim());
                return studentGroups.includes(groupName);
              }) || [];

            console.log(
              'üë• Found',
              studentsInGroup.length,
              'students in group:',
              studentsInGroup.map(s => s.name)
            );

            if (studentsInGroup.length > 0) {
              // Send message to email system iframe
              const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
              if (emailFrame && emailFrame.contentWindow) {
                // Get group schedule for display
                const groupSchedule = group.schedule || 'Not set';

                emailFrame.contentWindow.postMessage(
                  {
                    action: 'sendScheduleUpdateEmail',
                    groupName: groupName,
                    oldSchedule: oldSchedule,
                    newSchedule: newSchedule,
                    students: studentsInGroup.map(s => ({
                      name: s.name,
                      email: s.email,
                      group: s.group,
                    })),
                  },
                  '*'
                );

                debugLog('‚úÖ Schedule update email request sent to email system');
                showNotificationSimple(
                  `üìß Schedule update emails sent to ${studentsInGroup.length} student${studentsInGroup.length !== 1 ? 's' : ''}`,
                  'success'
                );
              } else {
                console.warn('‚ö†Ô∏è Email iframe not found, cannot send schedule update emails');
              }
            } else {
              verboseLog('‚ÑπÔ∏è No students in this group to notify');
            }
          }

          // Flash save confirmation
          const saveBtn = card.querySelector('button[onclick*="saveScheduleEdit"]');
          if (saveBtn) {
            const originalBg = saveBtn.style.background;
            saveBtn.style.background = 'linear-gradient(135deg,#10b981,#059669)';
            saveBtn.style.boxShadow = '0 0 20px rgba(16,185,129,0.6)';
            setTimeout(() => {
              saveBtn.style.background = originalBg;
              saveBtn.style.boxShadow = '';
            }, 800);
          }

          showToast('‚úÖ Schedule Updated');
          renderGroups();
        }
        // END GROUP MANAGER SCHEDULE FIX

        // ===== PARSE SCHEDULE STRING =====
        // ===== PARSE SCHEDULE STRING =====
        // BEGIN GROUP MANAGER SCHEDULE FIX - Convert day abbreviations to full names
        function convertDayAbbrevToFull(abbrev) {
          const map = {
            Mon: 'Monday',
            'Mon.': 'Monday',
            Tue: 'Tuesday',
            'Tue.': 'Tuesday',
            Wed: 'Wednesday',
            'Wed.': 'Wednesday',
            Thu: 'Thursday',
            'Thu.': 'Thursday',
            Fri: 'Friday',
            'Fri.': 'Friday',
            Sat: 'Saturday',
            'Sat.': 'Saturday',
            Sun: 'Sunday',
            'Sun.': 'Sunday',
            // Lowercase versions
            mon: 'Monday',
            tue: 'Tuesday',
            wed: 'Wednesday',
            thu: 'Thursday',
            fri: 'Friday',
            sat: 'Saturday',
            sun: 'Sunday',
            // Already full names
            Monday: 'Monday',
            Tuesday: 'Tuesday',
            Wednesday: 'Wednesday',
            Thursday: 'Thursday',
            Friday: 'Friday',
            Saturday: 'Saturday',
            Sunday: 'Sunday',
          };
          return map[abbrev] || abbrev || 'Monday';
        }

        function parseSchedule(str) {
          if (!str || !str.trim()) {
            return [{ day: 'Monday', time: '10:00 AM' }];
          }

          return str.split(',').map(s => {
            const parts = s.trim().split(' ');
            const dayAbbrev = parts[0] || 'Monday';
            const day = convertDayAbbrevToFull(dayAbbrev);
            const time = parts.slice(1).join(' ') || '10:00 AM';
            return { day, time };
          });
        }
        // END GROUP MANAGER SCHEDULE FIX

        // ===== SAVE GROUPS =====
        async function saveGroups() {
          try {
            // Save all groups to Supabase and update with returned IDs
            for (let i = 0; i < groups.length; i++) {
              const savedGroup = await saveGroup(groups[i]);
              if (savedGroup && savedGroup.id) {
                // Update the local group with the id from Supabase
                groups[i].id = savedGroup.id;
                // Also map back group_name to name
                groups[i].name = savedGroup.group_name || groups[i].name;
              }
            }

            // Update global cache
            window.groupsCache = groups;

            // Dispatch events for Student Manager and Payment Records
            window.dispatchEvent(new CustomEvent('groups:updated', { detail: groups }));
            window.dispatchEvent(new CustomEvent('schedules:updated', { detail: groups }));
          } catch (error) {
            console.error('Error saving groups:', error);
          }
        }

        // ===== UPDATE COLORS =====
        function updateScheduleItemStates() {
          document.querySelectorAll('.schedule-item').forEach(item => {
            const day = item.dataset.day;
            const time = item.dataset.time;
            if (!day || !time) return;

            const mins = getMinutesUntilClass(day, time);
            item.classList.remove('upcoming-green', 'upcoming-orange', 'upcoming-red');
            if (mins < 120) item.classList.add('upcoming-red');
            else if (mins < 360) item.classList.add('upcoming-orange');
            else if (mins < 720) item.classList.add('upcoming-green');

            item.onmouseenter = e => showCountdownPanel(e, day, time);
            item.onmouseleave = hideCountdownPanel;
          });
        }

        // ===== COUNTDOWN =====
        // BEGIN GROUP MANAGER SCHEDULE FIX - Correct nearest class calculation
        function getMinutesUntilClass(day, time) {
          const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const now = getNowLA(); // Use LA timezone

          // Parse the day index
          const targetDayIndex = days.findIndex(d => d.startsWith(day));
          if (targetDayIndex === -1) return 10080; // 1 week fallback

          // Parse the time (handle both "10:00 AM" and "10:00" formats)
          let targetHours = 0;
          let targetMinutes = 0;

          if (time.includes('AM') || time.includes('PM')) {
            // 12-hour format: "10:00 AM" or "3:30 PM"
            const match = time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
            if (match) {
              targetHours = parseInt(match[1]);
              targetMinutes = parseInt(match[2]);
              const period = match[3].toUpperCase();

              if (period === 'PM' && targetHours !== 12) targetHours += 12;
              if (period === 'AM' && targetHours === 12) targetHours = 0;
            }
          } else {
            // 24-hour format: "14:30"
            const [hh, mm] = time.split(':');
            targetHours = parseInt(hh) || 0;
            targetMinutes = parseInt(mm) || 0;
          }

          // Create target date for this week
          const target = new Date(now);
          target.setHours(targetHours, targetMinutes, 0, 0);

          // Calculate days until target
          const currentDay = now.getDay();
          let daysUntil = targetDayIndex - currentDay;

          // If target day is today, check if time has passed
          if (daysUntil === 0) {
            if (target <= now) {
              // Time passed today, move to next week
              daysUntil = 7;
            }
          } else if (daysUntil < 0) {
            // Target day already passed this week, move to next week
            daysUntil += 7;
          }

          // Set the correct date
          target.setDate(now.getDate() + daysUntil);

          // Calculate minutes difference
          const diffMs = target - now;
          const diffMinutes = Math.floor(diffMs / 60000);

          return diffMinutes > 0 ? diffMinutes : 0;
        }
        // END GROUP MANAGER SCHEDULE FIX

        // ===== COUNTDOWN PANEL =====
        // BEGIN GROUP MANAGER SCHEDULE FIX - Better countdown display
        function showCountdownPanel(e, day, time) {
          const panel = document.getElementById('countdownPanel');
          if (!panel) return;

          panel.style.display = 'block';
          panel.style.left = e.pageX + 15 + 'px';
          panel.style.top = e.pageY + 15 + 'px';
          clearInterval(countdownTimer);

          const update = () => {
            const mins = getMinutesUntilClass(day, time);
            const totalHours = Math.floor(mins / 60);
            const remainingMins = Math.floor(mins % 60);

            // Format display based on time remaining
            let displayText = '';
            if (totalHours >= 24) {
              const days = Math.floor(totalHours / 24);
              const hours = totalHours % 24;
              displayText = `${days}d ${hours}h ${remainingMins}m`;
            } else {
              displayText = `${totalHours}h ${remainingMins}m`;
            }

            panel.innerHTML = `Next ${day} at ${time}<br><b style="font-size:1.2rem;">${displayText}</b>`;
          };
          update();
          countdownTimer = setInterval(update, 60000);
        }
        // END GROUP MANAGER SCHEDULE FIX

        function hideCountdownPanel() {
          const panel = document.getElementById('countdownPanel');
          if (panel) panel.style.display = 'none';
          clearInterval(countdownTimer);
        }

        // ===== TOAST =====
        function showToast(msg) {
          const t = document.getElementById('toast');
          if (!t) return;
          t.textContent = msg;
          t.classList.add('show');
          setTimeout(() => t.classList.remove('show'), 2000);
        }

        // ===== LOAD GROUPS ON INIT =====
        if (!window.globalData) window.globalData = {};
        window.globalData.groups = groups;

        // For backwards compatibility with Student Manager
        function loadGroups() {
          return loadGroupsFromSupabase();
        }

        // Listen for student updates to refresh group displays
        window.addEventListener('students:updated', function (event) {
          // Refresh group data when students are updated
          if (document.getElementById('groupManagerModal').style.display === 'block') {
            renderGroups();
          }
        });

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        // ‚ö° FIX #9: PREVENT DUPLICATE INITIALIZATION
        let _appInitialized = false;
        let isInitialized = false;
        let initializePromise = null;

        async function initialize() {
          // ‚ö° FIX #9: Guard against duplicate initialization calls
          if (_appInitialized || isInitialized) {
            debugLog('‚ö° Already initialized, using cached data');
            return window.globalData;
          }

          // ‚ö° If initialization is in progress, return the same promise
          if (initializePromise) {
            debugLog('‚ö° Initialization in progress, waiting...');
            return initializePromise;
          }

          _appInitialized = true;

          // Start initialization
          initializePromise = _initializeInternal();
          await initializePromise;
          isInitialized = true;
          initializePromise = null;
        }

        async function _initializeInternal() {
          debugLog('üöÄ Initializing ARNOMA app with Supabase...');

          if (!window.globalData) {
            window.globalData = {
              groups: [],
              students: [],
              payments: [],
            };
          }

          // ‚ö° FIX #6: CAP SUPABASE QUERIES for mobile performance
          try {
            const [groups, students, payments] = await Promise.all([
              loadGroups(), // Already limited
              loadStudents(), // Will add limit
              PaymentStore.fetchAll(), // Will add limit
            ]);

            window.globalData.groups = groups;
            window.globalData.students = students;
            window.globalData.payments = payments;

            window.groupsCache = groups;
            window.studentsCache = students;
            window.paymentsCache = payments;

            console.log('‚úÖ Core data loaded');
          } catch (error) {
            console.error('‚ùå Error loading data from Supabase:', error);
          }

          // OAuth callback must run immediately after data load to complete Gmail auth flow
          handleOAuthCallback();

          return window.globalData;
        }

        // ‚ö° FIX #2 & #3: PREVENT EMAIL DATA SPAM with mutex
        let _emailDataSending = false;
        let _emailMessageHandlerAdded = false;

        // Initialize hidden email system iframe
        function initializeEmailSystemIframe() {
          // ‚ö° FIX #3: Check if iframe already exists
          const existingIframe = document.querySelector('iframe[src*="email-system-complete.html"]');
          if (existingIframe) {
            debugLog('‚ö†Ô∏è Email system iframe already exists, skipping initialization');
            return;
          }

          // Create hidden iframe for email system postMessage communication
          const iframe = document.createElement('iframe');
          iframe.src = 'email-system-complete.html?v=' + Date.now();
          iframe.style.cssText =
            'position: absolute; width: 1px; height: 1px; top: -9999px; left: -9999px; border: none; visibility: hidden;';
          iframe.setAttribute('aria-hidden', 'true');
          iframe.id = 'hiddenEmailSystemIframe';
          document.body.appendChild(iframe);

          debugLog('‚úÖ Hidden email system iframe initialized');

          // ‚ö° FIX #3: Listen for data requests from automation engine (ONLY ONCE)
          if (!_emailMessageHandlerAdded) {
            _emailMessageHandlerAdded = true;

            window.addEventListener('message', async function (event) {
              if (event.data.action === 'requestGroupsData') {
                if (window.__automationDataSent) {
                  verboseLog('[EmailAutomation] Ignoring iframe requestGroupsData - automation payload already sent');
                  return;
                }
                queueEmailDataSend('iframe-request');
              }

              // Handle email preview requests from email system iframe
              if (event.data.action === 'openEmailPreview') {
                verboseLog('[EmailPreview] üìß Received email preview request from iframe');
                openEmailPreviewModal(event.data.htmlContent, event.data.subject);
              }

              // Handle notification requests from email automation iframe
              if (event.data.action === 'addNotification') {
                console.log(
                  '[NotificationCenter] üì¨ Received notification request from iframe:',
                  event.data.notification
                );

                if (window.NotificationCenter && event.data.notification) {
                  const notif = event.data.notification;
                  await window.NotificationCenter.add(
                    notif.type || window.NotificationCenter.NotificationType.EMAIL,
                    notif.title,
                    notif.description,
                    {
                      groupName: notif.groupName,
                      studentName: notif.studentName,
                      metadata: notif.metadata || {},
                    }
                  );
                  debugLog('[NotificationCenter] ‚úÖ Notification added from iframe');
                }
              }
            });

            debugLog('‚úÖ Email system message listener attached');
          }
        }

        // Email Preview Modal Functions
        function openEmailPreviewModal(htmlContent, subject) {
          verboseLog('[EmailPreview] üîµ Opening email preview modal in parent window');
          const modal = document.getElementById('emailPreviewModal');
          const iframe = document.getElementById('emailPreviewFrame');

          if (!modal || !iframe) {
            console.error('[EmailPreview] ‚ùå Modal or iframe not found!');
            return;
          }

          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
          iframeDoc.open();
          iframeDoc.write(htmlContent);
          iframeDoc.close();

          modal.style.display = 'flex';
          verboseLog('[EmailPreview] ‚úÖ Modal opened successfully');
        }

        function closeEmailPreviewModal() {
          verboseLog('[EmailPreview] üî¥ Closing email preview modal');
          const modal = document.getElementById('emailPreviewModal');
          if (modal) {
            modal.style.display = 'none';
          }
        }

        // Send groups and students data to email system for automation
        // ‚ö° PERFORMANCE: Add guard to prevent message spam
        let lastEmailDataSentTimestamp = 0;
        const EMAIL_DATA_THROTTLE_MS = 1000;
        let emailDataQueueHandle = null;
        window.__automationDataSent = window.__automationDataSent || false;
        window.__automationDataSendReason = window.__automationDataSendReason || null;
        window.__automationDataSentAt = window.__automationDataSentAt || null;

        function queueEmailDataSend(reason = 'manual') {
          if (window.__automationDataSent) {
            verboseLog(`[EmailAutomation] Skipping queued iframe update (${reason}) - automation data already sent`);
            return;
          }
          if (emailDataQueueHandle) return;
          emailDataQueueHandle = setTimeout(() => {
            emailDataQueueHandle = null;
            sendGroupsDataToEmailSystem(reason);
          }, EMAIL_DATA_THROTTLE_MS);
          verboseLog(`[EmailAutomation] Queued iframe update (${reason})`);
        }

        function sendGroupsDataToEmailSystem(reason = 'manual') {
          // ‚ö° FIX #2: Mutex to prevent spam
          if (_emailDataSending) {
            verboseLog(`[EmailAutomation] Already sending data, skipping (${reason})`);
            return;
          }

          if (window.__automationDataSent) {
            verboseLog(`[EmailAutomation] Skipping automation send (${reason}) - data already delivered`);
            return;
          }

          const now = Date.now();
          if (now - lastEmailDataSentTimestamp < EMAIL_DATA_THROTTLE_MS) {
            verboseLog('‚ö° Throttling email iframe update (too frequent)');
            return;
          }

          _emailDataSending = true;
          lastEmailDataSentTimestamp = now;

          const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
          if (!emailFrame || !emailFrame.contentWindow) {
            verboseLog('‚ö†Ô∏è Email iframe not found or not ready, skipping automation data send');
            _emailDataSending = false;
            return;
          }

          const groups = window.groupsCache || window.globalData?.groups || [];
          const students = window.studentsCache || window.globalData?.students || [];

          emailFrame.contentWindow.postMessage(
            {
              action: 'updateGroupsData',
              groups,
              students,
            },
            '*'
          );

          window.__automationDataSent = true;
          window.__automationDataSendReason = reason;
          window.__automationDataSentAt = now;
          debugLog(`üì§ Sent automation data (${reason}): ${groups.length} groups, ${students.length} students`);

          _emailDataSending = false;
        }

        // ============================
        // BEGIN QUICK VIEW FUNCTIONS
        // ============================

        let currentQuickViewTab = 'byGroup';

        // Open Quick View modal
        function openQuickView() {
          const modal = document.getElementById('quickViewModal');
          if (!modal) return;

          // Close Group Manager if open
          const groupModal = document.getElementById('groupManagerModal');
          if (groupModal) groupModal.style.display = 'none';

          // Show Quick View modal
          modal.style.display = 'flex';

          // Render content
          renderQuickView();
        }

        // Close Quick View modal
        function closeQuickView() {
          const modal = document.getElementById('quickViewModal');
          if (!modal) return;
          modal.style.display = 'none';
        }

        // Switch between tabs
        function switchQuickViewTab(tab) {
          currentQuickViewTab = tab;

          // Update tab button styles
          const tabs = {
            byGroup: document.getElementById('tabByGroup'),
            byWeekday: document.getElementById('tabByWeekday'),
            byWeekdayYerevan: document.getElementById('tabByWeekdayYerevan'),
          };

          // Reset all tabs to inactive style
          Object.values(tabs).forEach(btn => {
            if (!btn) return;
            btn.style.background = 'rgba(255,255,255,0.1)';
            btn.style.border = '1px solid rgba(255,255,255,0.2)';
            btn.style.color = 'rgba(255,255,255,0.7)';
            btn.style.boxShadow = 'none';
            btn.style.fontWeight = '600';
          });

          // Set active tab style
          const activeTab = tabs[tab];
          if (activeTab) {
            activeTab.style.background = 'linear-gradient(135deg, #8ab4ff, #a855f7)';
            activeTab.style.border = 'none';
            activeTab.style.color = 'white';
            activeTab.style.boxShadow = '0 4px 12px rgba(138, 180, 255, 0.3)';
            activeTab.style.fontWeight = '700';
          }

          // Re-render content
          renderQuickView();
        }

        // BEGIN QUICK VIEW FIX: Convert LA time to Yerevan time
        // BEGIN DAY SHIFT FIX
        function convertLATimeToYerevan(timeStr, returnDayShift = false) {
          if (!timeStr) return returnDayShift ? { time: '', dayShift: 0 } : '';

          // Parse time (e.g., "8:00 AM", "10:30 PM")
          const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
          if (!match) return returnDayShift ? { time: timeStr, dayShift: 0 } : timeStr;

          let hours = parseInt(match[1]);
          const minutes = match[2];
          const period = match[3].toUpperCase();

          // Convert to 24-hour format
          if (period === 'PM' && hours !== 12) hours += 12;
          if (period === 'AM' && hours === 12) hours = 0;

          // LA to Yerevan offset: DST (UTC-7) = +11h, Standard (UTC-8) = +12h
          // Check if DST is active (timezone offset is 420 minutes / 7 hours)
          const now = new Date();
          const isDST = now.getTimezoneOffset() === 420;
          const offsetHours = isDST ? 11 : 12;

          let yerevanHours = hours + offsetHours;

          // Handle day overflow
          let dayShift = 0;
          if (yerevanHours >= 24) {
            yerevanHours -= 24;
            dayShift = 1; // Next day
          }

          // Convert back to 12-hour format
          let yerevanPeriod = 'AM';
          if (yerevanHours >= 12) {
            yerevanPeriod = 'PM';
            if (yerevanHours > 12) yerevanHours -= 12;
          }
          if (yerevanHours === 0) yerevanHours = 12;

          const timeResult = `${yerevanHours}:${minutes} ${yerevanPeriod}`;

          return returnDayShift ? { time: timeResult, dayShift: dayShift } : timeResult;
        }

        // Convert Yerevan time back to LA time (for display purposes)
        function convertYerevanTimeToLA(timeStr, returnDayShift = false) {
          if (!timeStr) return returnDayShift ? { time: '', dayShift: 0 } : '';

          // Parse time and remove day offset if present
          const cleanTime = timeStr.replace(/\s*\(\+1d\)|\s*\(-1d\)/, '');
          const match = cleanTime.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
          if (!match) return returnDayShift ? { time: timeStr, dayShift: 0 } : timeStr;

          let hours = parseInt(match[1]);
          const minutes = match[2];
          const period = match[3].toUpperCase();

          // Convert to 24-hour format
          if (period === 'PM' && hours !== 12) hours += 12;
          if (period === 'AM' && hours === 12) hours = 0;

          // Yerevan to LA offset: reverse of LA to Yerevan
          const now = new Date();
          const isDST = now.getTimezoneOffset() === 420;
          const offsetHours = isDST ? -11 : -12;

          let laHours = hours + offsetHours;

          // Handle day underflow
          let dayShift = 0;
          if (laHours < 0) {
            laHours += 24;
            dayShift = -1; // Previous day
          }

          // Convert back to 12-hour format
          let laPeriod = 'AM';
          if (laHours >= 12) {
            laPeriod = 'PM';
            if (laHours > 12) laHours -= 12;
          }
          if (laHours === 0) laHours = 12;

          const timeResult = `${laHours}:${minutes} ${laPeriod}`;

          return returnDayShift ? { time: timeResult, dayShift: dayShift } : timeResult;
        }
        // END DAY SHIFT FIX
        // END QUICK VIEW FIX

        // Ensure time is in 12-hour AM/PM format
        function ensureAMPMFormat(timeStr) {
          if (!timeStr) return '';

          // If already has AM/PM, return as-is
          if (/AM|PM/i.test(timeStr)) return timeStr;

          // Try to parse 24-hour format (e.g., "20:00", "08:00")
          const match24 = timeStr.match(/^(\d{1,2}):(\d{2})$/);
          if (match24) {
            let hours = parseInt(match24[1]);
            const minutes = match24[2];

            let period = 'AM';
            if (hours >= 12) {
              period = 'PM';
              if (hours > 12) hours -= 12;
            }
            if (hours === 0) hours = 12;

            return `${hours}:${minutes} ${period}`;
          }

          // Return as-is if can't parse
          return timeStr;
        }

        // Format schedule text into readable chips
        function formatScheduleQuickView(scheduleText, convertToYerevan = false) {
          if (!scheduleText || scheduleText.trim() === '') {
            return '<span style="color: rgba(255,255,255,0.5); font-style: italic;">No schedule</span>';
          }

          // Parse schedule: "Mon/Wed 8:00 AM, Fri 9:00 AM"
          const parts = scheduleText
            .split(',')
            .map(p => p.trim())
            .filter(p => p);
          if (parts.length === 0) {
            return '<span style="color: rgba(255,255,255,0.5); font-style: italic;">No schedule</span>';
          }

          const chips = parts
            .map(part => {
              // Extract days and time: "Mon/Wed 8:00 AM"
              const match = part.match(/^([\w/]+)\s+(.+)$/);
              if (!match) return null;

              const days = match[1];
              const time = match[2];
              // Ensure time is in AM/PM format
              const timeAMPM = ensureAMPMFormat(time);
              // Get clean time without day markers for display
              const displayTime = convertToYerevan ? convertLATimeToYerevan(timeAMPM, true).time : timeAMPM;

              return `<span style="display: inline-block; padding: 6px 12px; margin: 4px; background: rgba(138,180,255,0.15); border: 1px solid rgba(138,180,255,0.3); border-radius: 8px; font-size: 13px; color: #8ab4ff; white-space: nowrap;">${days} ${displayTime}</span>`;
            })
            .filter(c => c);

          return chips.join('');
        }

        // BEGIN QUICK VIEW FIX: Main render function
        function renderQuickView() {
          const contentEl = document.getElementById('quickViewContent');
          if (!contentEl) return;

          try {
            // Load groups from Supabase cache - only show active groups
            const allGroups = window.groupsCache || window.globalData?.groups || [];
            const groupsData = allGroups.filter(g => g.active !== false);

            if (!Array.isArray(groupsData) || groupsData.length === 0) {
              contentEl.innerHTML =
                '<div style="text-align: center; padding: 60px; color: rgba(255,255,255,0.5); font-size: 16px;"><div style="font-size: 64px; margin-bottom: 16px;">üìö</div><p>No active groups found.<br>Add groups in Group Manager to see schedules here.</p></div>';
              return;
            }

            let html = '';

            if (currentQuickViewTab === 'byGroup') {
              // BY GROUP VIEW
              html =
                '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 20px;">';
              groupsData.forEach(group => {
                const schedule = formatScheduleQuickView(group.schedule || '');
                // Ensure group name starts with "Group" prefix if it's just a letter
                const groupName =
                  group.name && group.name.length === 1 ? `Group ${group.name}` : group.name || 'Unnamed Group';
                html += `
              <div style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 18px; transition: all 0.2s;">
                <div style="font-size: 18px; font-weight: 700; color: white; margin-bottom: 8px;">${escapeHtml(groupName)}</div>
                <div style="font-size: 14px; color: rgba(255,255,255,0.5); margin-bottom: 8px; font-weight: 600;">Schedule:</div>
                <div>${schedule}</div>
              </div>
            `;
              });
              html += '</div>';
            } else if (currentQuickViewTab === 'byWeekday') {
              // BY WEEKDAY (LA) VIEW
              const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
              const dayMap = {
                mon: 'Monday',
                tue: 'Tuesday',
                wed: 'Wednesday',
                thu: 'Thursday',
                fri: 'Friday',
                sat: 'Saturday',
                sun: 'Sunday',
              };
              const daySchedule = {};

              // Parse all schedules and organize by day
              groupsData.forEach(group => {
                const scheduleText = (group.schedule || '').trim();
                if (!scheduleText) return;

                const parts = scheduleText
                  .split(',')
                  .map(p => p.trim())
                  .filter(p => p);
                parts.forEach(part => {
                  const match = part.match(/^([\w/]+)\s+(.+)$/);
                  if (!match) return;

                  const daysStr = match[1].toLowerCase();
                  const time = match[2];
                  // Ensure time is in AM/PM format before storing
                  const timeAMPM = ensureAMPMFormat(time);

                  // Handle slash-separated days: "mon/wed"
                  const dayTokens = daysStr.split('/').map(d => d.trim());
                  dayTokens.forEach(token => {
                    const fullDay = dayMap[token];
                    if (!fullDay) return;

                    if (!daySchedule[fullDay]) daySchedule[fullDay] = [];
                    daySchedule[fullDay].push({ group: escapeHtml(group.name), time: escapeHtml(timeAMPM) });
                  });
                });
              });

              // Sort sessions by time within each day
              Object.keys(daySchedule).forEach(day => {
                daySchedule[day].sort((a, b) => {
                  const timeA = new Date('1970-01-01 ' + a.time);
                  const timeB = new Date('1970-01-01 ' + b.time);
                  return timeA - timeB;
                });
              });

              // Get today's weekday in LA timezone
              const todayLA = new Date().toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
                weekday: 'long',
              });

              html = '<div style="display: flex; flex-direction: column; gap: 24px;">';
              weekdays.forEach(day => {
                const sessions = daySchedule[day] || [];
                const isTodayLA = day === todayLA;
                const todayClass = isTodayLA ? ' quickview-today-stroke' : '';

                html += `
              <div class="${todayClass}" style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 18px;">
                <div style="font-size: 20px; font-weight: 700; color: white; margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">${day}</div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                  ${
                    sessions.length === 0
                      ? '<span style="color: rgba(255,255,255,0.4); font-style: italic;">No sessions scheduled</span>'
                      : sessions
                          .map(s => {
                            // Get clean Yerevan time without day markers
                            const yerevanResult = convertLATimeToYerevan(s.time, true);
                            const yerevanTime = yerevanResult.time; // Clean time without markers
                            // Ensure group name starts with "Group" prefix if it's just a letter
                            const groupName = s.group.length === 1 ? `Group ${s.group}` : s.group;
                            return `<span style="padding: 8px 14px; background: rgba(138,180,255,0.15); border: 1px solid rgba(138,180,255,0.3); border-radius: 8px; font-size: 12px; color: #8ab4ff;"><strong>${groupName}</strong> ‚Äî ${s.time} (Los Angeles) <span style="opacity: 0.7;">(${yerevanTime} Yerevan Time)</span></span>`;
                          })
                          .join('')
                  }
                </div>
              </div>
            `;
              });
              html += '</div>';
            } else if (currentQuickViewTab === 'byWeekdayYerevan') {
              // BY WEEKDAY (YEREVAN) VIEW
              // BEGIN DAY SHIFT FIX - Calculate next weekday helper
              function getNextWeekday(weekday, offset) {
                const weekdayIndex = {
                  Monday: 0,
                  Tuesday: 1,
                  Wednesday: 2,
                  Thursday: 3,
                  Friday: 4,
                  Saturday: 5,
                  Sunday: 6,
                };
                const indexToDay = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

                const currentIndex = weekdayIndex[weekday];
                if (currentIndex === undefined) return weekday;

                const newIndex = (currentIndex + offset + 7) % 7; // +7 to handle negative offsets
                return indexToDay[newIndex];
              }
              // END DAY SHIFT FIX

              const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
              const dayMap = {
                mon: 'Monday',
                tue: 'Tuesday',
                wed: 'Wednesday',
                thu: 'Thursday',
                fri: 'Friday',
                sat: 'Saturday',
                sun: 'Sunday',
              };
              const daySchedule = {};

              // BEGIN DAY SHIFT FIX - Parse schedules with Yerevan weekday calculation
              // Parse all schedules and organize by ACTUAL Yerevan day (not LA day)
              groupsData.forEach(group => {
                const scheduleText = (group.schedule || '').trim();
                if (!scheduleText) return;

                const parts = scheduleText
                  .split(',')
                  .map(p => p.trim())
                  .filter(p => p);
                parts.forEach(part => {
                  const match = part.match(/^([\w/]+)\s+(.+)$/);
                  if (!match) return;

                  const daysStr = match[1].toLowerCase();
                  const laTime = match[2];
                  // Ensure LA time is in AM/PM format before converting
                  const laTimeAMPM = ensureAMPMFormat(laTime);
                  const conversionResult = convertLATimeToYerevan(laTimeAMPM, true); // Get day shift info

                  // Handle slash-separated days: "mon/wed"
                  const dayTokens = daysStr.split('/').map(d => d.trim());
                  dayTokens.forEach(token => {
                    const laWeekday = dayMap[token]; // Original LA weekday
                    if (!laWeekday) return;

                    // Calculate actual Yerevan weekday based on day shift
                    const yerevanWeekday = getNextWeekday(laWeekday, conversionResult.dayShift);

                    if (!daySchedule[yerevanWeekday]) daySchedule[yerevanWeekday] = [];
                    daySchedule[yerevanWeekday].push({
                      group: escapeHtml(group.name),
                      yerevanTime: escapeHtml(conversionResult.time), // Clean time without markers
                      laTime: escapeHtml(laTimeAMPM),
                    });
                  });
                });
              });
              // END DAY SHIFT FIX

              // Helper function to convert time string to 24-hour numeric value for sorting
              function timeToNumeric(timeStr) {
                // Parse "8:00 AM" or "5:30 PM" format
                const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!match) return 0;

                let hours = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                const period = match[3].toUpperCase();

                // Convert to 24-hour format
                if (period === 'PM' && hours !== 12) {
                  hours += 12;
                } else if (period === 'AM' && hours === 12) {
                  hours = 0;
                }

                // Return as decimal: 8:30 AM = 8.5, 5:45 PM = 17.75
                return hours + minutes / 60;
              }

              // Sort sessions by time within each day (chronological order)
              Object.keys(daySchedule).forEach(day => {
                daySchedule[day].sort((a, b) => {
                  const timeA = timeToNumeric(a.yerevanTime);
                  const timeB = timeToNumeric(b.yerevanTime);
                  return timeA - timeB;
                });
              });

              // Get today's weekday in Yerevan timezone
              const todayYerevan = new Date().toLocaleString('en-US', {
                timeZone: 'Asia/Yerevan',
                weekday: 'long',
              });

              html = '<div style="display: flex; flex-direction: column; gap: 24px;">';
              weekdays.forEach(day => {
                const sessions = daySchedule[day] || [];
                const isTodayYerevan = day === todayYerevan;
                const todayClass = isTodayYerevan ? ' quickview-today-stroke' : '';

                html += `
              <div class="${todayClass}" style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 18px;">
                <div style="font-size: 20px; font-weight: 700; color: white; margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">${day}</div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                  ${
                    sessions.length === 0
                      ? '<span style="color: rgba(255,255,255,0.4); font-style: italic;">No sessions scheduled</span>'
                      : sessions
                          .map(s => {
                            // Ensure group name starts with "Group" prefix if it's just a letter
                            const groupName = s.group.length === 1 ? `Group ${s.group}` : s.group;
                            return `<span style="padding: 8px 14px; background: rgba(16,185,129,0.15); border: 1px solid rgba(16,185,129,0.3); border-radius: 8px; font-size: 12px; color: #10b981;"><strong>${groupName}</strong> ‚Äî ${s.yerevanTime} (Yerevan) <span style="opacity: 0.7;">(${s.laTime} Los Angeles Time)</span></span>`;
                          })
                          .join('')
                  }
                </div>
              </div>
            `;
              });
              html += '</div>';
            }

            contentEl.innerHTML = html;
          } catch (error) {
            console.error('Quick View render error:', error);
            contentEl.innerHTML =
              '<div style="text-align: center; padding: 60px; color: rgba(255,0,0,0.7); font-size: 16px;"><div style="font-size: 64px; margin-bottom: 16px;">‚ö†Ô∏è</div><p>Error loading schedules.<br>Please try again.</p></div>';
          }
        }
        // END QUICK VIEW FIX

        // Listen for group updates and refresh Quick View if it's open
        window.addEventListener('groups:updated', function () {
          const quickViewModal = document.getElementById('quickViewModal');
          if (quickViewModal && quickViewModal.style.display !== 'none') {
            renderQuickView();
          }
        });

        // ============================
        // END QUICK VIEW FUNCTIONS
        // ============================

        // ========== BEGIN FLOATING NAV FUNCTIONS ==========
        /**
         * Initialize Floating Navigation Bar
         * Ensures idempotent initialization with guard flag
         */
        function initFloatingNav() {
          if (window._floatingNavInitialized) {
            return; // Already initialized, skip
          }
          window._floatingNavInitialized = true;

          const floatingNav = document.getElementById('floatingNav');
          if (!floatingNav) {
            console.warn('Floating Nav: Element not found');
            return;
          }

          // Show the nav bar
          floatingNav.style.display = 'flex';

          // Bind all button handlers with guards
          bindNavBtn('navTopBtn', scrollToTop);
          bindNavBtn('navUndoBtn', undoAction);
          bindNavBtn('navEarningForecastBtn', openEarningsForecast);
          bindNavBtn('navTimerBtn', toggleClassCountdown);
          bindNavBtn('navQuickViewBtn', openQuickView);
          // navCalendarBtn has onclick in HTML
        }

        /**
         * Bind button with duplicate prevention
         */
        function bindNavBtn(id, fn) {
          const el = document.getElementById(id);
          if (el && !el.dataset.bound) {
            el.addEventListener('click', fn);
            el.dataset.bound = '1';
          }
        }

        /**
         * Scroll to top smoothly
         */
        function scrollToTop() {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        /**
         * Undo action (browser history back)
         */
        function undoAction() {
          if (window.history.length > 1) {
            window.history.back();
          } else {
            console.info('Undo: No previous state');
            showNotification('No previous state to undo', 'info');
          }
        }

        /**
         * Redo action (browser history forward)
         */
        /**
         * Refresh current UI view
         */
        function refreshUIAction() {
          try {
            document.body.classList.add('refreshing');

            // Re-render current view based on what's open
            const studentManager = document.getElementById('studentManagerModal');
            const groupManager = document.getElementById('groupManagerModal');
            const quickView = document.getElementById('quickViewModal');

            if (studentManager && studentManager.style.display !== 'none') {
              renderStudents();
            } else if (groupManager && groupManager.style.display !== 'none') {
              renderGroups();
            } else if (quickView && quickView.style.display !== 'none') {
              renderQuickView();
            } else {
              // Refresh main payment grid
              if (typeof renderPaymentEmailsView === 'function') {
                renderPaymentEmailsView();
              }
            }

            setTimeout(() => {
              document.body.classList.remove('refreshing');
              showNotification('Refreshed', 'success');
            }, 800);
          } catch (e) {
            console.warn('Refresh failed:', e);
            document.body.classList.remove('refreshing');
            showNotification('Refresh failed', 'error');
          }
        }

        /* BEGIN CLASS COUNTDOWN TIMER */
        /**
         * Toggle Class Countdown Timer overlay - Enhanced version
         * Manages both legacy and enhanced countdown timers
         */
        function toggleClassCountdown() {
          // Check for enhanced timer first
          let enhancedTimer = document.getElementById('enhancedCountdownTimer');

          if (enhancedTimer) {
            // Hide enhanced timer
            if (window.ClassCountdownTimer && window.ClassCountdownTimer.destroy) {
              window.ClassCountdownTimer.destroy();
            }
            showNotification('Countdown timer hidden', 'info');
            return;
          }

          // Check for legacy overlay
          let overlay = document.getElementById('classCountdownOverlay');

          if (overlay) {
            // Remove legacy overlay
            if (overlay._timer) {
              clearInterval(overlay._timer);
            }
            overlay.remove();
            showNotification('Countdown timer hidden', 'info');
            return;
          }

          // Initialize enhanced countdown timer
          if (window.ClassCountdownTimer && window.ClassCountdownTimer.init) {
            window.ClassCountdownTimer.init();
            showNotification('Countdown timer active', 'success');

            // Dispatch event for Skip Manager to attach handlers
            window.dispatchEvent(new CustomEvent('timerOpened'));
          } else {
            // Fallback to legacy implementation
            overlay = document.createElement('div');
            overlay.id = 'classCountdownOverlay';
            document.body.appendChild(overlay);
            startCountdownTimer(overlay);
            showNotification('Countdown timer active (legacy)', 'success');
          }
        }
        /* END CLASS COUNTDOWN TIMER */

        /**
         * Start countdown timer with live updates (legacy function - preserved for compatibility)
         */
        function startCountdownTimer(overlay) {
          function updateCountdown() {
            const nextClass = getNextClassTime();
            if (nextClass) {
              overlay.textContent = `‚ó∑ ${nextClass.dayName}: ${nextClass.groupName} in ${nextClass.timeRemaining}`;
            } else {
              overlay.textContent = '‚ó∑ No classes scheduled';
            }
          }

          // Initial update
          updateCountdown();

          // Update every minute
          overlay._timer = setInterval(updateCountdown, 60000);
        }

        /**
         * Calculate next upcoming class from schedules (up to 7 days ahead)
         * Returns {groupName, timeRemaining, dayName} or null
         */
        function getNextClassTime() {
          try {
            const groups = JSON.parse(localStorage.getItem('group-manager:v2') || '[]');
            const now = new Date();
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const currentDayIndex = now.getDay();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();

            let nextClass = null;
            let minDiffInMinutes = Infinity;

            // Check up to 7 days ahead
            for (let daysAhead = 0; daysAhead < 7; daysAhead++) {
              const checkDayIndex = (currentDayIndex + daysAhead) % 7;
              const checkDayName = dayNames[checkDayIndex];

              groups.forEach(group => {
                if (!group.schedule || !Array.isArray(group.schedule)) return;

                group.schedule.forEach(slot => {
                  if (!slot.days || !slot.time) return;

                  slot.days.forEach(day => {
                    if (day !== checkDayName) return;

                    // Parse time (e.g., "2:00 PM" or "14:00")
                    const timeMatch = slot.time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
                    if (!timeMatch) return;

                    let hours = parseInt(timeMatch[1]);
                    const minutes = parseInt(timeMatch[2]);
                    const ampm = timeMatch[3];

                    if (ampm) {
                      if (ampm.toUpperCase() === 'PM' && hours !== 12) hours += 12;
                      if (ampm.toUpperCase() === 'AM' && hours === 12) hours = 0;
                    }

                    const classMinutes = hours * 60 + minutes;

                    // Calculate total difference in minutes from now
                    let totalDiff;
                    if (daysAhead === 0) {
                      totalDiff = classMinutes - currentMinutes;
                      // Skip if class already passed today
                      if (totalDiff <= 0) return;
                    } else {
                      // For future days, add full days in minutes
                      totalDiff = daysAhead * 24 * 60 - currentMinutes + classMinutes;
                    }

                    if (totalDiff > 0 && totalDiff < minDiffInMinutes) {
                      minDiffInMinutes = totalDiff;

                      // Format time remaining
                      const daysLeft = Math.floor(totalDiff / (24 * 60));
                      const hoursLeft = Math.floor((totalDiff % (24 * 60)) / 60);
                      const minsLeft = totalDiff % 60;

                      let timeStr = '';
                      if (daysLeft > 0) {
                        timeStr = `${daysLeft}d ${hoursLeft}h`;
                      } else if (hoursLeft > 0) {
                        timeStr = `${hoursLeft}h ${minsLeft}m`;
                      } else {
                        timeStr = `${minsLeft}m`;
                      }

                      // Determine day label
                      let dayLabel = '';
                      if (daysAhead === 0) {
                        dayLabel = 'Today';
                      } else if (daysAhead === 1) {
                        dayLabel = 'Tomorrow';
                      } else {
                        dayLabel = checkDayName;
                      }

                      nextClass = {
                        groupName: group.name.length === 1 ? `Group ${group.name}` : group.name,
                        timeRemaining: timeStr,
                        dayName: dayLabel,
                      };
                    }
                  });
                });
              });
            }

            return nextClass;
          } catch (error) {
            console.error('Error calculating next class:', error);
            return null;
          }
        }

        /* BEGIN CLASS COUNTDOWN TIMER */
        /**
         * Enhanced Class Countdown Timer
         * A comprehensive, self-contained timer system with:
         * - Live per-minute updates
         * - Full LA/Yerevan timezone display (DST-aware)
         * - State-based visual feedback (<15m warning, <5m urgent)
         * - 2-hour class duration with automatic skip to next class
         * - Continuous rolling countdown without "in progress" pauses
         * - Zero side effects on existing code
         *
         * TIMEZONE SYNCHRONIZATION (Yerevan ‚áÑ Los Angeles):
         * - Los Angeles: America/Los_Angeles (PST UTC-8 or PDT UTC-7)
         * - Yerevan: Asia/Yerevan (AMT UTC+4, no DST)
         * - Time difference between Yerevan and Los Angeles is usually 11 hours (during PDT),
         *   but 12 hours during U.S. Standard Time (November ‚Üí March).
         * - All calculations are done in UTC internally, then converted to local time for display.
         * - NEVER hard-code timezone offsets - always retrieve them dynamically.
         */
        window.ClassCountdownTimer = (function () {
          // Private state
          let timerElement = null;
          let updateInterval = null;
          let currentClassData = null;
          let isPinned = false;

          /**
           * Timezone Utilities
           * All time calculations use UTC internally, with dynamic timezone conversion
           */
          const TimezoneUtils = {
            /**
             * Get current time in a specific timezone
             * @param {string} timezone - IANA timezone string (e.g., 'America/Los_Angeles')
             * @returns {Object} { hours, minutes, seconds, day, month, year, dayOfWeek }
             */
            getCurrentTimeInZone(timezone) {
              const now = new Date();

              // Get ISO string in the target timezone
              const isoString = now.toLocaleString('en-CA', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
              });

              // Get day of week separately
              const dayOfWeek = now.toLocaleString('en-US', {
                timeZone: timezone,
                weekday: 'long',
              });

              // Parse: "YYYY-MM-DD, HH:mm:ss"
              const [datePart, timePart] = isoString.split(', ');
              const [year, month, day] = datePart.split('-').map(n => parseInt(n));
              const [hours, minutes, seconds] = timePart.split(':').map(n => parseInt(n));

              return {
                hours,
                minutes,
                seconds,
                day,
                month,
                year,
                dayOfWeek,
                // For backwards compatibility, provide Date-like methods
                getDay() {
                  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                  return dayNames.indexOf(this.dayOfWeek);
                },
                getHours() {
                  return this.hours;
                },
                getMinutes() {
                  return this.minutes;
                },
                getSeconds() {
                  return this.seconds;
                },
                getTime() {
                  // Return milliseconds since epoch for this time
                  return new Date(
                    this.year,
                    this.month - 1,
                    this.day,
                    this.hours,
                    this.minutes,
                    this.seconds
                  ).getTime();
                },
                toLocaleString() {
                  return `${this.month}/${this.day}/${this.year}, ${String(this.hours).padStart(2, '0')}:${String(this.minutes).padStart(2, '0')}:${String(this.seconds).padStart(2, '0')}`;
                },
              };
            },

            /**
             * Get the UTC offset for a timezone in hours (dynamically calculated)
             * @param {string} timezone - IANA timezone string
             * @returns {number} Offset in hours (e.g., -8 for PST, +4 for Yerevan)
             */
            getTimezoneOffset(timezone) {
              const now = new Date();
              const utcDate = new Date(now.toLocaleString('en-US', { timeZone: 'UTC' }));
              const zoneDate = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
              return (zoneDate - utcDate) / (1000 * 60 * 60);
            },

            /**
             * Convert a time from LA timezone to Yerevan timezone
             * @param {string} laTimeStr - Time in LA (e.g., "8:00 PM")
             * @param {Date} referenceDate - Reference date for the conversion (defaults to today)
             * @returns {Object} { time: string, dayShift: number }
             */
            convertLATimeToYerevan(laTimeStr, referenceDate = new Date()) {
              if (!laTimeStr) return { time: '', dayShift: 0 };

              const match = laTimeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
              if (!match) return { time: laTimeStr, dayShift: 0 };

              let hours = parseInt(match[1]);
              const minutes = match[2];
              const period = match[3].toUpperCase();

              // Convert to 24-hour
              if (period === 'PM' && hours !== 12) hours += 12;
              if (period === 'AM' && hours === 12) hours = 0;

              // Create a date object in LA timezone
              const laDate = new Date(referenceDate);
              const laString = laDate.toLocaleDateString('en-US', { timeZone: 'America/Los_Angeles' });
              const [month, day, year] = laString.split('/');

              // Create UTC date with LA time components
              // Get LA's current UTC offset dynamically
              const laOffset = this.getTimezoneOffset('America/Los_Angeles');
              const utcHours = hours - laOffset;

              const utcDate = new Date(
                Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), utcHours, parseInt(minutes))
              );

              // Convert to Yerevan time
              const yerevanString = utcDate.toLocaleString('en-US', {
                timeZone: 'Asia/Yerevan',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
              });

              // Calculate day shift
              const yerevanDate = new Date(utcDate.toLocaleString('en-US', { timeZone: 'Asia/Yerevan' }));
              const dayShift = yerevanDate.getDate() - laDate.getDate();

              return {
                time: yerevanString,
                dayShift: dayShift,
              };
            },
          };

          // Time conversion helper (reuses existing convertLATimeToYerevan function)
          function ensureAMPMFormatLocal(timeStr) {
            if (!timeStr) return '';
            if (/AM|PM/i.test(timeStr)) return timeStr;

            const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
            if (!match) return timeStr;

            let hours = parseInt(match[1]);
            const minutes = match[2];
            const period = hours >= 12 ? 'PM' : 'AM';

            if (hours > 12) hours -= 12;
            if (hours === 0) hours = 12;

            return `${hours}:${minutes} ${period}`;
          }

          // DST-aware LA to Yerevan conversion (legacy - kept for compatibility)
          // NOTE: This uses dynamic offset calculation via TimezoneUtils
          function convertLAToYerevanTime(laTimeStr) {
            return TimezoneUtils.convertLATimeToYerevan(laTimeStr);
          }

          // Original implementation preserved below for reference
          /*
      function convertLAToYerevanTime(laTimeStr) {
        if (!laTimeStr) return { time: '', dayShift: 0 };

        const match = laTimeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
        if (!match) return { time: laTimeStr, dayShift: 0 };

        let hours = parseInt(match[1]);
        const minutes = match[2];
        const period = match[3].toUpperCase();

        // Convert to 24-hour
        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;

        // DST detection: Check if LA is in daylight saving time
        const now = new Date();
        const jan = new Date(now.getFullYear(), 0, 1);
        const jul = new Date(now.getFullYear(), 6, 1);
        const stdOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        const isDST = now.getTimezoneOffset() < stdOffset;

        // LA: UTC-8 (PST) or UTC-7 (PDT)
        // Yerevan: UTC+4 (year-round, no DST)
        // Difference: 12 hours (PST) or 11 hours (PDT)
        const offsetHours = isDST ? 11 : 12;

        let yerevanHours = hours + offsetHours;
        let dayShift = 0;

        if (yerevanHours >= 24) {
          yerevanHours -= 24;
          dayShift = 1;
        }

        // Convert back to 12-hour
        let yerevanPeriod = 'AM';
        let displayHours = yerevanHours;

        if (yerevanHours >= 12) {
          yerevanPeriod = 'PM';
          if (yerevanHours > 12) displayHours = yerevanHours - 12;
        }
        if (yerevanHours === 0) displayHours = 12;

        return {
          time: `${displayHours}:${minutes} ${yerevanPeriod}`,
          dayShift: dayShift
        };
      }
      */

          // Parse schedule string format: "Mon/Wed 8:00 AM, Fri 9:30 PM"
          function parseScheduleString(scheduleStr) {
            if (!scheduleStr || typeof scheduleStr !== 'string') return [];

            const sessions = [];
            const parts = scheduleStr
              .split(',')
              .map(p => p.trim())
              .filter(p => p);

            parts.forEach(part => {
              const match = part.match(/^([\w/]+)\s+(.+)$/);
              if (!match) return;

              const daysStr = match[1];
              const timeStr = match[2];
              const days = daysStr.split('/').map(d => d.trim().toLowerCase());

              const dayMap = {
                mon: 'Monday',
                tue: 'Tuesday',
                wed: 'Wednesday',
                thu: 'Thursday',
                fri: 'Friday',
                sat: 'Saturday',
                sun: 'Sunday',
              };

              days.forEach(dayAbbr => {
                const fullDay = dayMap[dayAbbr];
                if (fullDay) {
                  sessions.push({
                    day: fullDay,
                    time: ensureAMPMFormatLocal(timeStr),
                  });
                }
              });
            });

            return sessions;
          }

          // Get one-time schedule sessions for a specific date
          function getOneTimeSessionsForDate(group, targetDate) {
            const sessions = [];
            if (!group.one_time_schedules || !Array.isArray(group.one_time_schedules)) {
              return sessions;
            }

            // Format targetDate as YYYY-MM-DD
            const targetDateStr =
              typeof targetDate === 'string'
                ? targetDate
                : formatDateYYYYMMDD(targetDate);

            group.one_time_schedules.forEach(override => {
              if (override.date === targetDateStr) {
                sessions.push({
                  day: override.day,
                  time: override.time,
                  isOneTime: true,
                  oneTimeDate: override.date,
                });
              }
            });

            return sessions;
          }

          // BEGIN CLASS COUNTDOWN TIMER FIX - Remove "Class in Progress" & Auto-Jump to Next Class
          // Find next class across all groups (up to 7 days ahead)
          // Classes last 2 hours - automatically skip to next class after 2-hour window ends
          function findNextClass() {
            try {
              const groups = window.groupsCache || window.globalData?.groups || [];

              // Get current time in LA timezone using UTC-based calculation
              // CRITICAL: All time calculations use UTC internally for accuracy
              // Time difference between Yerevan and Los Angeles is usually 11 hours (PDT),
              // but 12 hours during U.S. Standard Time (November ‚Üí March). Always retrieve dynamically.
              const now = TimezoneUtils.getCurrentTimeInZone('America/Los_Angeles');
              const laOffset = TimezoneUtils.getTimezoneOffset('America/Los_Angeles');

              const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
              const currentDayIndex = now.getDay();
              const currentTime = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();

              let nextClass = null;
              let minDiffInSeconds = Infinity;

              // Check up to 7 days ahead
              for (let daysAhead = 0; daysAhead < 7; daysAhead++) {
                const checkDayIndex = (currentDayIndex + daysAhead) % 7;
                const checkDayName = dayNames[checkDayIndex];

                // Calculate the actual calendar date for this check
                const checkDate = new Date(now);
                checkDate.setDate(checkDate.getDate() + daysAhead);
                const checkDateStr = formatDateYYYYMMDD(checkDate);

                groups.forEach(group => {
                  let sessions = [];

                  // FIRST: Check for one-time schedule overrides for this specific date
                  const oneTimeSessions = getOneTimeSessionsForDate(group, checkDateStr);
                  if (oneTimeSessions.length > 0) {
                    // One-time schedule exists for this date - use it instead of regular schedule
                    sessions = oneTimeSessions;
                  } else {
                    // NO one-time override - use regular recurring schedule
                    // Handle both old array format and new string format
                    if (Array.isArray(group.schedule)) {
                      // Legacy array format
                      group.schedule.forEach(slot => {
                        if (slot.days && slot.time) {
                          slot.days.forEach(day => {
                            sessions.push({ day, time: ensureAMPMFormatLocal(slot.time) });
                          });
                        }
                      });
                    } else if (typeof group.schedule === 'string') {
                      // New string format
                      sessions = parseScheduleString(group.schedule);
                    }
                  }

                  sessions.forEach(session => {
                    if (session.day !== checkDayName) return;

                    // Parse time
                    const match = session.time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (!match) return;

                    let hours = parseInt(match[1]);
                    const minutes = parseInt(match[2]);
                    const period = match[3].toUpperCase();

                    if (period === 'PM' && hours !== 12) hours += 12;
                    if (period === 'AM' && hours === 12) hours = 0;

                    const classTimeInSeconds = hours * 3600 + minutes * 60;

                    // Calculate time difference in seconds
                    let totalDiffSeconds;
                    if (daysAhead === 0) {
                      totalDiffSeconds = classTimeInSeconds - currentTime;
                      const sessionLabel = session.isOneTime ? 'üìÖ ONE-TIME' : 'REGULAR';
                      debugLog(
                        `[ClassCountdownTimer] Checking ${group.name} ${sessionLabel} on ${checkDayName} at ${session.time}: totalDiff=${totalDiffSeconds}s (${(totalDiffSeconds / 3600).toFixed(1)}h)`
                      );
                      // Skip if more than 2 hours (7200 seconds) past - class is over
                      if (totalDiffSeconds < -7200) return;
                    } else {
                      totalDiffSeconds = daysAhead * 86400 - currentTime + classTimeInSeconds;
                    }

                    // Skip classes currently in progress (started but not yet 2 hours past)
                    // Only count future classes (totalDiffSeconds > 0)
                    if (totalDiffSeconds > 0 && totalDiffSeconds < minDiffInSeconds) {
                      const sessionLabel = session.isOneTime ? 'üìÖ ONE-TIME' : '';
                      debugLog(
                        `[ClassCountdownTimer] ‚úÖ New next class: ${group.name} ${sessionLabel} on ${checkDayName} at ${session.time} (${(totalDiffSeconds / 3600).toFixed(1)}h away)`
                      );
                      minDiffInSeconds = totalDiffSeconds;

                      // Determine day label
                      let dayLabel = '';
                      if (daysAhead === 0) {
                        dayLabel = 'Today';
                      } else if (daysAhead === 1) {
                        dayLabel = 'Tomorrow';
                      } else {
                        dayLabel = checkDayName;
                      }

                      const groupDisplayName =
                        group.name && group.name.length === 1 ? `Group ${group.name}` : group.name || 'Unknown Group';

                      nextClass = {
                        groupName: session.isOneTime ? `${groupDisplayName} (One-Time)` : groupDisplayName,
                        dayName: dayLabel,
                        laTime: session.time,
                        secondsRemaining: totalDiffSeconds,
                        actualDay: checkDayName,
                        isOneTime: session.isOneTime || false,
                        classDate: checkDateStr, // CRITICAL: Store the actual YYYY-MM-DD date for cancellation
                      };
                    }
                  });
                });
              }

              return nextClass;
            } catch (error) {
              console.error('[ClassCountdownTimer] Error finding next class:', error);
              return null;
            }
          }
          // END CLASS COUNTDOWN TIMER FIX

          // BEGIN CLASS COUNTDOWN TIMER FIX - Remove "Class in Progress" & Auto-Jump to Next Class
          // Format seconds into readable countdown (no "in progress" state)
          function formatCountdown(seconds) {
            const absSeconds = Math.abs(seconds);
            const days = Math.floor(absSeconds / 86400);
            const hours = Math.floor((absSeconds % 86400) / 3600);
            const mins = Math.floor((absSeconds % 3600) / 60);

            if (days > 0) {
              return `${days}d ${hours}h ${mins}m`;
            } else if (hours > 0) {
              return `${hours}h ${mins}m`;
            } else if (mins > 0) {
              return `${mins}m`;
            } else {
              return `<1m`;
            }
          }
          // END CLASS COUNTDOWN TIMER FIX

          // Create timer element as popup
          function createElement() {
            // Prevent duplicate creation
            const existingTimer = document.getElementById('enhancedCountdownTimer');
            if (existingTimer) {
              timerElement = existingTimer;
              return existingTimer;
            }

            const timer = document.createElement('div');
            timer.id = 'enhancedCountdownTimer';
            timer.innerHTML = `
          <div class="timer-header">
            <div style="display: flex; align-items: center; gap: 6px;">
              <span class="timer-icon">üïí</span>
              <span class="timer-title">Upcoming Classes</span>
            </div>
            <button class="timer-close" title="Close timer">√ó</button>
          </div>
          <div class="timer-classes-list"></div>
        `;

            const closeBtn = timer.querySelector('.timer-close');
            closeBtn.addEventListener('click', e => {
              e.stopPropagation();
              destroy();
            });

            // Add click-outside-to-close functionality
            setTimeout(() => {
              setupTimerClickOutsideListener(timer);
            }, 100);

            document.body.appendChild(timer);
            timerElement = timer;

            return timer;
          }

          // Setup click outside to close timer
          function setupTimerClickOutsideListener(timer) {
            // Remove existing listener if any
            if (window._timerClickOutsideListener) {
              document.removeEventListener('click', window._timerClickOutsideListener);
            }

            // Create new listener
            window._timerClickOutsideListener = function (event) {
              // Check if timer exists and is visible
              if (!timer || !document.body.contains(timer)) {
                // Cleanup listener if timer is gone
                document.removeEventListener('click', window._timerClickOutsideListener);
                window._timerClickOutsideListener = null;
                return;
              }

              // Check if click is inside timer
              const clickedInsideTimer = timer.contains(event.target);

              // Check if click is on a button or interactive element
              const clickedButton = event.target.closest('button');
              const clickedInput = event.target.closest('input, textarea, select');

              // If clicked outside timer and not on a button/input, close timer
              if (!clickedInsideTimer && !clickedButton && !clickedInput) {
                destroy();
              }
            };

            // Attach listener with slight delay to prevent immediate trigger
            setTimeout(() => {
              document.addEventListener('click', window._timerClickOutsideListener);
            }, 200);
          }

          // Get all classes for the next 7 days
          function getAllUpcomingClasses() {
            try {
              const allClasses = [];

              // Load groups from Supabase cache or global groups variable
              const groups = window.groupsCache || window.globalData?.groups || [];

              if (!groups || groups.length === 0) {
                return [];
              }

              // Get current LA time using UTC-based calculation
              // CRITICAL: All time calculations use UTC internally for accuracy
              // Time difference between Yerevan and Los Angeles is usually 11 hours (PDT),
              // but 12 hours during U.S. Standard Time (November ‚Üí March). Always retrieve dynamically.
              const nowLA = TimezoneUtils.getCurrentTimeInZone('America/Los_Angeles');
              const laOffset = TimezoneUtils.getTimezoneOffset('America/Los_Angeles');

              // Get current time in seconds since midnight LA time
              const currentTimeInSeconds = nowLA.hours * 3600 + nowLA.minutes * 60 + nowLA.seconds;

              // Check each day for the next 7 days
              for (let daysAhead = 0; daysAhead <= 7; daysAhead++) {
                // Calculate the day we're checking
                const checkDayIndex = (nowLA.getDay() + daysAhead) % 7;
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const checkDayName = dayNames[checkDayIndex];

                // Calculate the actual calendar date for this check
                const checkDate = new Date(nowLA);
                checkDate.setDate(checkDate.getDate() + daysAhead);
                const checkDateStr = formatDateYYYYMMDD(checkDate);

                groups.forEach(group => {
                  let sessions = [];

                  const normalizeDay = day => {
                    if (!day || typeof day !== 'string') return '';
                    const map = {
                      sun: 'Sunday',
                      sunday: 'Sunday',
                      mon: 'Monday',
                      monday: 'Monday',
                      tue: 'Tuesday',
                      tues: 'Tuesday',
                      tuesday: 'Tuesday',
                      wed: 'Wednesday',
                      weds: 'Wednesday',
                      wednesday: 'Wednesday',
                      thu: 'Thursday',
                      thur: 'Thursday',
                      thurs: 'Thursday',
                      thursday: 'Thursday',
                      fri: 'Friday',
                      friday: 'Friday',
                      sat: 'Saturday',
                      saturday: 'Saturday',
                    };
                    return map[day.toLowerCase()] || day;
                  };

                  // FIRST: Check for one-time schedule overrides for this specific date
                  const oneTimeSessions = getOneTimeSessionsForDate(group, checkDateStr);
                  if (oneTimeSessions.length > 0) {
                    // One-time schedule exists for this date - use it instead of regular schedule
                    sessions = oneTimeSessions;
                  } else {
                    // NO one-time override - use regular recurring schedule
                    if (Array.isArray(group.schedule)) {
                      // Legacy array format with { days: [], time: '' }
                      group.schedule.forEach(slot => {
                        if (!slot || !slot.days || !slot.time) return;
                        const timeFormatted = ensureAMPMFormatLocal(slot.time);
                        slot.days.forEach(day => {
                          if (day) {
                            sessions.push({
                              day: normalizeDay(day),
                              time: timeFormatted,
                            });
                          }
                        });
                      });
                    } else if (Array.isArray(group.sessions)) {
                      // Some imports might store sessions separately
                      sessions = group.sessions
                        .filter(s => s && s.day && s.time)
                        .map(s => ({
                          day: normalizeDay(s.day),
                          time: ensureAMPMFormatLocal(s.time),
                        }));
                    } else if (typeof group.schedule === 'string') {
                      // Primary format: "Mon/Wed 8:00 AM, Fri 9:30 PM"
                      sessions = parseScheduleString(group.schedule);
                    }
                  }

                  if (!sessions.length) return;

                  sessions.forEach(session => {
                    if (session.day !== checkDayName) return;

                    // Parse time
                    const match = session.time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (!match) return;

                    let hours = parseInt(match[1]);
                    const minutes = parseInt(match[2]);
                    const period = match[3].toUpperCase();

                    if (period === 'PM' && hours !== 12) hours += 12;
                    if (period === 'AM' && hours === 12) hours = 0;

                    // Calculate class time in seconds since midnight
                    const classTimeInSeconds = hours * 3600 + minutes * 60;

                    // Calculate total time difference in seconds
                    let totalDiffSeconds;
                    if (daysAhead === 0) {
                      // Same day - just subtract current time
                      totalDiffSeconds = classTimeInSeconds - currentTimeInSeconds;
                    } else {
                      // Future day - add full days, subtract current time, add class time
                      totalDiffSeconds = daysAhead * 86400 - currentTimeInSeconds + classTimeInSeconds;
                    }

                    debugLog(
                      `[ClassCountdownTimer] ${group.name} ${checkDayName} ${session.time} (day +${daysAhead}): classTime=${classTimeInSeconds}s, currentTime=${currentTimeInSeconds}s, diff=${totalDiffSeconds}s (${(totalDiffSeconds / 3600).toFixed(1)}h)`
                    );

                    // Skip if more than 2 hours (7200 seconds) past - class is over
                    if (totalDiffSeconds < -7200) {
                      debugLog(`[ClassCountdownTimer] ‚ùå Skipping ${group.name} - more than 2h past`);
                      return;
                    }

                    // Only show future classes (totalDiffSeconds > 0)
                    if (totalDiffSeconds > 0) {
                      let dayLabel = '';
                      if (daysAhead === 0) {
                        dayLabel = 'Today';
                      } else if (daysAhead === 1) {
                        dayLabel = 'Tomorrow';
                      } else {
                        dayLabel = checkDayName;
                      }

                      const groupDisplayName =
                        group.name && group.name.length === 1 ? `Group ${group.name}` : group.name || 'Unknown Group';

                      allClasses.push({
                        groupName: session.isOneTime ? `${groupDisplayName} (One-Time)` : groupDisplayName,
                        dayName: dayLabel,
                        laTime: session.time,
                        secondsRemaining: totalDiffSeconds,
                        actualDay: checkDayName,
                        sortTime: totalDiffSeconds,
                        isOneTime: session.isOneTime || false,
                        classDate: checkDateStr, // CRITICAL: Store the actual YYYY-MM-DD date for cancellation
                      });
                    }
                  });
                });
              }

              // Sort by time chronologically
              allClasses.sort((a, b) => a.sortTime - b.sortTime);

              // Remove duplicates based on group name + time + day
              const uniqueClasses = [];
              const seenKeys = new Set();

              allClasses.forEach(classItem => {
                const key = `${classItem.groupName}|${classItem.laTime}|${classItem.actualDay}`;
                if (!seenKeys.has(key)) {
                  seenKeys.add(key);
                  uniqueClasses.push(classItem);
                }
              });

              return uniqueClasses;
            } catch (error) {
              console.error('[ClassCountdownTimer] Error getting all classes:', error);
              return [];
            }
          }

          // Update timer display with all classes
          function updateDisplay() {
            if (!timerElement) return;

            const allClasses = getAllUpcomingClasses();
            const listContainer = timerElement.querySelector('.timer-classes-list');
            const titleEl = timerElement.querySelector('.timer-title');

            if (!allClasses || allClasses.length === 0) {
              titleEl.textContent = 'Upcoming Classes';
              listContainer.innerHTML = '<div class="timer-no-classes">No upcoming classes in the next 7 days</div>';
              // Remove all pulse classes when no classes
              timerElement.classList.remove('time-critical', 'pulse-slow', 'pulse-medium', 'pulse-fast');
              return;
            }

            // BEGIN CLASS COUNTDOWN TIMER FIX - Remove "Class in Progress" title
            // Update title based on content (never show "Class in Progress")
            if (allClasses.length === 1) {
              titleEl.textContent = `Next Class: ${allClasses[0].groupName}`;
            } else {
              titleEl.textContent = `${allClasses.length} Upcoming Classes`;
            }
            // END CLASS COUNTDOWN TIMER FIX

            // Apply timer container pulse animation based on soonest class
            const soonestClass = allClasses[0]; // First class is the soonest
            const hoursUntilSoonest = soonestClass.secondsRemaining / 3600;

            // Remove all pulse classes first
            timerElement.classList.remove('time-critical', 'pulse-slow', 'pulse-medium', 'pulse-fast');

            // Apply appropriate pulse class based on time remaining
            if (hoursUntilSoonest <= 6) {
              timerElement.classList.add('time-critical'); // Red background
              if (hoursUntilSoonest <= 2) {
                timerElement.classList.add('pulse-fast'); // Fast pulse when <2h
              } else if (hoursUntilSoonest <= 4) {
                timerElement.classList.add('pulse-medium'); // Medium pulse when <4h
              } else {
                timerElement.classList.add('pulse-slow'); // Slow pulse when <6h
              }
            }

            let html = '';
            allClasses.forEach((classData, index) => {
              const yerevanData = convertLAToYerevanTime(classData.laTime);
              const countdown = formatCountdown(classData.secondsRemaining);

              // Check if this class is skipped
              const dateStr = calculateClassDateForTimer(classData.dayName, classData.laTime);
              const isSkipped =
                window.SkipClassManager && window.SkipClassManager.isClassSkipped(classData.groupName, dateStr);

              // BEGIN CLASS COUNTDOWN TIMER FIX - Remove "in-progress" state
              // Determine card tint class based on time remaining
              let cardTintClass = '';
              let stateClass = '';
              let stateIcon = '';

              const hoursRemaining = classData.secondsRemaining / 3600;

              // Apply per-class tinting based on urgency
              if (hoursRemaining > 24) {
                cardTintClass = 'class-safe'; // Green
              } else if (hoursRemaining > 12) {
                cardTintClass = 'class-upcoming'; // Yellow
              } else if (hoursRemaining > 6) {
                cardTintClass = 'class-warning'; // Orange
              } else {
                cardTintClass = 'class-critical'; // Red with pulse
              }

              // State icons based on urgency
              if (classData.secondsRemaining < 900) {
                // <15m
                stateClass = 'urgent';
                stateIcon = 'üî¥';
              } else if (classData.secondsRemaining < 3600) {
                // <60m
                stateClass = 'warning';
                stateIcon = 'üü°';
              } else {
                stateIcon = '‚è±Ô∏è';
              }
              // END CLASS COUNTDOWN TIMER FIX

              const isNext = index === 0;
              const skippedClass = isSkipped ? 'skipped' : '';

              html += `
            <div class="timer-class-item ${cardTintClass} ${stateClass} ${isNext ? 'next-class' : ''} ${skippedClass}" data-group="${classData.groupName}" data-day="${classData.dayName}" data-time="${classData.laTime}">
              <div class="timer-class-header">
                <span class="timer-class-icon">${stateIcon}</span>
                <span class="timer-class-group">${classData.groupName}</span>
                <span class="timer-class-countdown">${countdown}</span>
              </div>
              <div class="timer-class-details">
                <span class="timer-class-day">${classData.dayName}</span>
                <span class="timer-class-separator">‚Ä¢</span>
                <span class="timer-class-time">${classData.laTime} LA</span>
                <span class="timer-class-separator">‚Ä¢</span>
                <span class="timer-class-time">${yerevanData.time} Yerevan</span>
              </div>
            </div>
          `;
            });

            listContainer.innerHTML = html;
          }

          // Helper function to calculate class date
          function calculateClassDateForTimer(dayName, laTime) {
            const now = new Date();
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            let targetDate;
            if (dayName === 'Today') {
              targetDate = new Date(now);
            } else if (dayName === 'Tomorrow') {
              targetDate = new Date(now);
              targetDate.setDate(targetDate.getDate() + 1);
            } else {
              // Find next occurrence of this day
              const currentDay = now.getDay();
              const targetDay = dayNames.indexOf(dayName);
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;

              targetDate = new Date(now);
              targetDate.setDate(targetDate.getDate() + daysAhead);
            }

            // Format as YYYY-MM-DD
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }

          // Initialize timer
          function init() {
            // Prevent duplicate initialization
            if (updateInterval) {
              console.warn('[ClassCountdownTimer] Already initialized - reusing existing instance');
              return;
            }

            createElement();
            updateDisplay();

            // Start live updates (every minute)
            updateInterval = setInterval(() => {
              updateDisplay();
            }, 60000);
          }

          // Destroy timer
          function destroy() {
            // Clear interval first
            if (updateInterval) {
              clearInterval(updateInterval);
              updateInterval = null;
            }

            // Remove click-outside listener
            if (window._timerClickOutsideListener) {
              document.removeEventListener('click', window._timerClickOutsideListener);
              window._timerClickOutsideListener = null;
            }

            // Remove element
            if (timerElement) {
              timerElement.remove();
              timerElement = null;
            }

            currentClassData = null;
          }

          // Toggle pin mode (above modals)
          function togglePin() {
            isPinned = !isPinned;
            if (timerElement) {
              if (isPinned) {
                timerElement.classList.add('pinned');
              } else {
                timerElement.classList.remove('pinned');
              }
            }
            return isPinned;
          }

          // Public API
          return {
            init,
            destroy,
            togglePin,
            getCurrentClass: () => currentClassData,
            isActive: () => timerElement !== null,
          };
        })();

        // Reinitialize countdown timer when groups/schedules are updated
        window.addEventListener('groups:updated', () => {
          if (window.ClassCountdownTimer) {
            window.ClassCountdownTimer.destroy();
            setTimeout(() => {
              window.ClassCountdownTimer.init();
            }, 500);
          }
        });

        window.addEventListener('schedules:updated', () => {
          if (window.ClassCountdownTimer) {
            window.ClassCountdownTimer.destroy();
            setTimeout(() => {
              window.ClassCountdownTimer.init();
            }, 500);
          }
        });

        /* END CLASS COUNTDOWN TIMER */

        // ============================================================================
        // SKIP CLASS MANAGER - Smart Calendar + Timer Integration ‚òÅÔ∏è CLOUD SYNC
        // ============================================================================
        /**
         * Skip Class Manager - Supabase Cloud Sync Version
         * - Double-click timer class items to skip
         * - Automatic payment roll-over
         * - Calendar integration with visual feedback
         * - Undo functionality
         * - ‚òÅÔ∏è CLOUD SYNC - Works across all devices via Supabase
         */
        window.SkipClassManager = (function () {
          // Skipped classes data structure: { groupName: { 'YYYY-MM-DD': { type: 'student-skipped' | 'class-canceled', note: string } } }
          let skippedClasses = {};
          let pendingSkip = null;
          let isInitialized = false;

          // Load skipped classes from Supabase
          async function loadSkippedClasses() {
            try {
              // First try localStorage (faster and more reliable)
              const localData = loadSkippedClassesFromLocalStorage();

              // Then try to sync with Supabase
              const { data, error } = await supabase.from('skipped_classes').select('*');

              if (error) {
                console.warn('[SkipClassManager] ‚ö†Ô∏è Supabase load error (using localStorage):', error.message);
                return localData; // Use localStorage data
              }

              // Convert Supabase array to nested object structure
              const supabaseSkipped = {};
              (data || []).forEach(record => {
                if (!supabaseSkipped[record.group_name]) {
                  supabaseSkipped[record.group_name] = {};
                }
                supabaseSkipped[record.group_name][record.class_date] = {
                  type: record.skip_type || 'student-skipped',
                  note: null, // Note not stored in Supabase (schema issue)
                };
              });

              // Merge localStorage data (which has notes) with Supabase data
              const merged = { ...localData };
              Object.keys(supabaseSkipped).forEach(groupName => {
                if (!merged[groupName]) {
                  merged[groupName] = {};
                }
                Object.keys(supabaseSkipped[groupName]).forEach(dateStr => {
                  // If not in localStorage, add from Supabase
                  if (!merged[groupName][dateStr]) {
                    merged[groupName][dateStr] = supabaseSkipped[groupName][dateStr];
                  }
                });
              });

              debugLog('‚úÖ [SkipClassManager] Loaded from localStorage + Supabase');
              return merged;
            } catch (error) {
              console.error('[SkipClassManager] ‚ùå Exception loading skipped classes:', error);
              return loadSkippedClassesFromLocalStorage(); // Fallback
            }
          }

          // Fallback: Load from localStorage if Supabase fails
          function loadSkippedClassesFromLocalStorage() {
            try {
              const data = localStorage.getItem('skipped-classes:v1');
              debugLog('üì¶ [SkipClassManager] Loaded from localStorage (fallback)');
              return data ? JSON.parse(data) : {};
            } catch (error) {
              console.error('[SkipClassManager] ‚ùå Error loading from localStorage:', error);
              return {};
            }
          }

          // Save skipped classes to Supabase
          async function saveSkippedClasses() {
            try {
              // Convert nested object to array of records
              const records = [];
              Object.keys(skippedClasses).forEach(groupName => {
                Object.keys(skippedClasses[groupName]).forEach(classDate => {
                  const skipInfo = skippedClasses[groupName][classDate];
                  // Don't include 'note' field if it causes Supabase schema issues
                  // Store note in localStorage only for now
                  records.push({
                    group_name: groupName,
                    class_date: classDate,
                    skip_type: skipInfo.type || 'student-skipped',
                    skipped_at: new Date().toISOString(),
                  });
                });
              });

              // Delete all existing records (full replace strategy for simplicity)
              const { error: deleteError } = await supabase.from('skipped_classes').delete().neq('id', 0); // Delete all rows

              if (deleteError) {
                console.error('[SkipClassManager] ‚ùå Error clearing Supabase:', deleteError);
              }

              // Insert new records
              if (records.length > 0) {
                const { error: insertError } = await supabase.from('skipped_classes').insert(records);

                if (insertError) {
                  console.error('[SkipClassManager] ‚ùå Error saving to Supabase:', insertError);
                  verboseLog('[SkipClassManager] üì¶ Using localStorage as primary storage');
                  saveSkippedClassesToLocalStorage(); // Fallback
                  return;
                }

                debugLog('‚úÖ [SkipClassManager] Saved', records.length, 'skipped classes to Supabase');
              } else {
                debugLog('‚úÖ [SkipClassManager] Cleared all skipped classes from Supabase');
              }

              // Also save to localStorage as backup
              saveSkippedClassesToLocalStorage();
            } catch (error) {
              console.error('[SkipClassManager] ‚ùå Exception saving skipped classes:', error);
              saveSkippedClassesToLocalStorage(); // Fallback
            }
          }

          // Fallback: Save to localStorage
          function saveSkippedClassesToLocalStorage() {
            try {
              localStorage.setItem('skipped-classes:v1', JSON.stringify(skippedClasses));
              debugLog('üì¶ [SkipClassManager] Saved to localStorage (backup)');
            } catch (error) {
              console.error('[SkipClassManager] ‚ùå Error saving to localStorage:', error);
            }
          }

          // Calculate the date for a class (Today, Tomorrow, or specific day)
          function calculateClassDate(dayName, laTime) {
            const now = new Date();
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            let targetDate;
            if (dayName === 'Today') {
              targetDate = new Date(now);
            } else if (dayName === 'Tomorrow') {
              targetDate = new Date(now);
              targetDate.setDate(targetDate.getDate() + 1);
            } else {
              // Find next occurrence of this day
              const currentDay = now.getDay();
              const targetDay = dayNames.indexOf(dayName);
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;

              targetDate = new Date(now);
              targetDate.setDate(targetDate.getDate() + daysAhead);
            }

            // Format as YYYY-MM-DD
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }

          // Check if a class is skipped (any type)
          function isClassSkipped(groupName, dateStr) {
            return skippedClasses[groupName] && skippedClasses[groupName][dateStr];
          }

          // Check if a class is canceled (entire class)
          function isClassCanceled(groupName, dateStr) {
            return (
              skippedClasses[groupName] &&
              skippedClasses[groupName][dateStr] &&
              skippedClasses[groupName][dateStr].type === 'class-canceled'
            );
          }

          // Get skip info (type and note)
          function getSkipInfo(groupName, dateStr) {
            if (!skippedClasses[groupName] || !skippedClasses[groupName][dateStr]) {
              return null;
            }
            return skippedClasses[groupName][dateStr];
          }

          // Skip a class (student didn't show)
          function skipClass(groupName, dateStr, classInfo) {
            if (!skippedClasses[groupName]) {
              skippedClasses[groupName] = {};
            }
            skippedClasses[groupName][dateStr] = {
              type: 'student-skipped',
              note: null,
            };
            saveSkippedClasses();

            // Refresh timer display
            if (window.ClassCountdownTimer && window.ClassCountdownTimer.isActive()) {
              window.ClassCountdownTimer.destroy();
              setTimeout(() => {
                window.ClassCountdownTimer.init();
              }, 100);
            }

            // Refresh calendar if visible
            if (typeof renderCalendar === 'function') {
              try {
                renderCalendar();
              } catch (error) {
                console.warn('[SkipClassManager] Could not refresh calendar:', error);
              }
            }
          }

          // Cancel a class (entire class canceled - applies to all students)
          function cancelClass(groupName, dateStr, note = null) {
            console.log('[CLASS CANCELLED] cancelClass() called:', {
              groupName,
              dateStr,
              note: note || '(no note)',
            });

            if (!skippedClasses[groupName]) {
              skippedClasses[groupName] = {};
            }
            skippedClasses[groupName][dateStr] = {
              type: 'class-canceled',
              note: note,
            };

            console.log('üö´ [SkipClassManager] Class canceled:', groupName, dateStr, note || '(no reason)');
            console.log('[CLASS CANCELLED] ‚úÖ Saved to skippedClasses:', {
              groupName,
              dateStr,
              status: 'cancelled',
              cancelled: true,
            });

            // Forward any payments made on this canceled date to next class
            forwardPaymentsForCanceledClass(groupName, dateStr);

            saveSkippedClasses();

            // Refresh timer display
            if (window.ClassCountdownTimer && window.ClassCountdownTimer.isActive()) {
              console.log('[CLASS CANCELLED] Refreshing countdown timer...');
              window.ClassCountdownTimer.destroy();
              setTimeout(() => {
                window.ClassCountdownTimer.init();
              }, 100);
            }

            // Refresh calendar if visible
            if (typeof renderCalendar === 'function') {
              try {
                console.log('[CLASS CANCELLED] Refreshing calendar display...');
                renderCalendar();
                console.log('[CLASS CANCELLED] ‚úÖ Calendar refreshed - class should now appear grayed out');
              } catch (error) {
                console.error('[CLASS CANCELLED] ‚ùå Error refreshing calendar:', error);
                console.warn('[SkipClassManager] Could not refresh calendar:', error);
              }
            }

            return true;
          }

          // Forward payments made on a canceled date to the next active class
          async function forwardPaymentsForCanceledClass(groupName, canceledDateStr) {
            try {
              console.log('üí∏ [PaymentForwarding] Checking for payments on canceled date:', groupName, canceledDateStr);

              // Get all students in this group
              const groupStudents = window.studentsCache
                ? window.studentsCache.filter(s => s.group && s.group.includes(groupName))
                : students.filter(s => s.group && s.group.includes(groupName));

              if (!groupStudents || groupStudents.length === 0) {
                console.log('üí∏ [PaymentForwarding] No students found in group:', groupName);
                return;
              }

              // Load payment records from Supabase
              const { data: payments, error } = await supabase
                .from('credit_payments')
                .select('*')
                .eq('payment_date', canceledDateStr)
                .in(
                  'student_id',
                  groupStudents.map(s => s.id)
                );

              if (error) {
                console.error('üí∏ [PaymentForwarding] Error loading payments:', error);
                return;
              }

              if (!payments || payments.length === 0) {
                console.log('üí∏ [PaymentForwarding] No payments found on canceled date');
                return;
              }

              console.log(`üí∏ [PaymentForwarding] Found ${payments.length} payment(s) to forward`);

              // For each payment, find the next active class and forward it
              for (const payment of payments) {
                const student = groupStudents.find(s => s.id === payment.student_id);
                if (!student) continue;

                // Find next active class date for this student
                const nextClassDate = findNextActiveClassDate(groupName, canceledDateStr);

                if (!nextClassDate) {
                  console.warn('üí∏ [PaymentForwarding] No future class found for student:', student.name);
                  continue;
                }

                // Update payment record to apply to next class
                const { error: updateError } = await supabase
                  .from('credit_payments')
                  .update({
                    applied_class_date: nextClassDate,
                    note: `Forwarded from canceled class on ${canceledDateStr}`,
                  })
                  .eq('id', payment.id);

                if (updateError) {
                  console.error('üí∏ [PaymentForwarding] Error updating payment:', updateError);
                } else {
                  console.log(
                    `üí∏ [PaymentForwarding] ‚úÖ Forwarded payment for ${student.name}: ${canceledDateStr} ‚Üí ${nextClassDate}`
                  );
                }
              }

              // Refresh calendar to show updated payment status
              if (typeof renderCalendar === 'function') {
                renderCalendar();
              }
            } catch (error) {
              console.error('üí∏ [PaymentForwarding] Exception:', error);
            }
          }

          // Find next active class date for a group (excluding skipped/canceled dates)
          function findNextActiveClassDate(groupName, fromDateStr) {
            // Get group schedule
            const group = (window.groupsCache || groups || []).find(g => g.name === groupName);
            if (!group || !group.schedule) {
              console.warn('üí∏ [PaymentForwarding] Group not found or has no schedule:', groupName);
              return null;
            }

            const schedule = group.schedule;
            const fromDate = new Date(fromDateStr + 'T00:00:00');
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Get class days from schedule (e.g., "Mon, Wed 6:00 PM" ‚Üí [1, 3])
            const classDays = [];
            schedule.split(',').forEach(part => {
              const dayMatch = part.trim().match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)/);
              if (dayMatch) {
                const dayAbbr = dayMatch[1];
                const dayMap = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };
                if (dayMap.hasOwnProperty(dayAbbr)) {
                  classDays.push(dayMap[dayAbbr]);
                }
              }
            });

            if (classDays.length === 0) {
              console.warn('üí∏ [PaymentForwarding] Could not parse schedule:', schedule);
              return null;
            }

            // Find next class date (within next 30 days)
            for (let i = 1; i <= 30; i++) {
              const checkDate = new Date(fromDate);
              checkDate.setDate(checkDate.getDate() + i);
              const dayOfWeek = checkDate.getDay();

              // Check if this is a class day
              if (classDays.includes(dayOfWeek)) {
                const dateStr = formatDate(checkDate);

                // Check if this date is not skipped/canceled
                if (!isClassSkipped(groupName, dateStr)) {
                  return dateStr;
                }
              }
            }

            return null;
          }

          // Format date as YYYY-MM-DD
          function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }

          // Unskip a class (undo)
          function unskipClass(groupName, dateStr) {
            if (skippedClasses[groupName]) {
              delete skippedClasses[groupName][dateStr];
              if (Object.keys(skippedClasses[groupName]).length === 0) {
                delete skippedClasses[groupName];
              }
              saveSkippedClasses();
            }

            // Refresh timer display
            if (window.ClassCountdownTimer && window.ClassCountdownTimer.isActive()) {
              window.ClassCountdownTimer.destroy();
              setTimeout(() => {
                window.ClassCountdownTimer.init();
              }, 100);
            }

            // Refresh calendar if visible
            if (typeof renderCalendar === 'function') {
              try {
                renderCalendar();
              } catch (error) {
                console.warn('[SkipClassManager] Could not refresh calendar:', error);
              }
            }
          }

          // Show skip confirmation dialog
          function showSkipDialog(classData) {
            pendingSkip = classData;

            const dialog = document.getElementById('skipClassDialog');
            const overlay = document.getElementById('skipClassOverlay');
            const classNameEl = document.getElementById('skipDialogClassName');
            const classTimeEl = document.getElementById('skipDialogClassTime');

            if (!dialog || !overlay) {
              console.error('[SkipClassManager] Dialog elements not found');
              return;
            }

            // Populate dialog
            classNameEl.textContent = classData.groupName;
            classTimeEl.textContent = `${classData.dayName} at ${classData.laTime}`;

            // Show dialog
            overlay.classList.add('show');
            dialog.classList.add('show');
          }

          // Hide skip dialog
          function hideSkipDialog() {
            const dialog = document.getElementById('skipClassDialog');
            const overlay = document.getElementById('skipClassOverlay');

            if (dialog) dialog.classList.remove('show');
            if (overlay) overlay.classList.remove('show');

            pendingSkip = null;
          }

          // Confirm skip
          function confirmSkip() {
            if (!pendingSkip) return;

            const dateStr = calculateClassDate(pendingSkip.dayName, pendingSkip.laTime);
            skipClass(pendingSkip.groupName, dateStr, pendingSkip);
            hideSkipDialog();

            // Show success notification
            showNotification(`‚úì Class skipped: ${pendingSkip.groupName} on ${pendingSkip.dayName}`, 'success');
          }

          // Confirm cancel entire class
          function confirmCancelClass() {
            if (!pendingSkip) return;

            // CRITICAL FIX: Use the stored classDate instead of recalculating
            // The stored date is already in LA timezone and YYYY-MM-DD format
            const dateStr = pendingSkip.classDate || calculateClassDate(pendingSkip.dayName, pendingSkip.laTime);

            console.log('[CLASS CANCELLED] Initiating cancellation:', {
              source: 'COUNTDOWN_TIMER',
              group: pendingSkip.groupName,
              date: dateStr,
              dayName: pendingSkip.dayName,
              time: pendingSkip.laTime,
              actualDay: pendingSkip.actualDay,
            });

            // Prompt for cancellation reason
            const reason = prompt('Cancellation reason (optional):');

            // User clicked cancel
            if (reason === null) {
              console.log('[CLASS CANCELLED] User canceled the cancellation prompt');
              hideSkipDialog();
              return;
            }

            // Cancel class for entire group
            const success = cancelClass(pendingSkip.groupName, dateStr, reason);
            
            if (success) {
              console.log('[CLASS CANCELLED] ‚úÖ Successfully canceled via COUNTDOWN_TIMER:', {
                group: pendingSkip.groupName,
                date: dateStr,
                reason: reason || '(no reason provided)',
              });
            } else {
              console.error('[CLASS CANCELLED] ‚ùå Failed to cancel class');
            }

            hideSkipDialog();

            // Show success notification
            showNotification(`üö´ Entire class canceled: ${pendingSkip.groupName} on ${pendingSkip.dayName}`, 'success');
          }

          // Cancel skip
          function cancelSkip() {
            hideSkipDialog();
          }

          // Show notification (simple version) - DISABLED per user request
          function showNotification(message, type = 'info') {
            return; // Notifications disabled - no popups in upper right
          }

          // Initialize - attach double-click handlers to timer items
          async function init() {
            if (isInitialized) {
              debugLog('‚ö†Ô∏è [SkipClassManager] Already initialized, skipping');
              return;
            }

            // debugLog('üöÄ [SkipClassManager] Initializing with Supabase cloud sync...');

            // Load skipped classes from Supabase
            skippedClasses = await loadSkippedClasses();
            isInitialized = true;

            // debugLog('‚úÖ [SkipClassManager] Initialized with', Object.keys(skippedClasses).length, 'groups');

            // Attach button event listeners
            const cancelBtn = document.getElementById('skipDialogCancelBtn');
            const overlay = document.getElementById('skipClassOverlay');

            if (cancelBtn) {
              cancelBtn.addEventListener('click', cancelSkip);
            }

            if (overlay) {
              overlay.addEventListener('click', cancelSkip);
            }

            // Wait for timer to be rendered, then attach handlers
            const attachHandlers = () => {
              const timerElement = document.getElementById('enhancedCountdownTimer');
              if (!timerElement) {
                return;
              }

              // Remove existing listener if any
              if (timerElement._skipHandlerAttached) {
                return;
              }

              // Use event delegation for dynamic timer items
              timerElement.addEventListener('dblclick', e => {
                const classItem = e.target.closest('.timer-class-item');
                if (!classItem) {
                  return;
                }
                if (classItem.classList.contains('skipped')) {
                  return;
                }

                // Extract class data from the element
                const groupName = classItem.getAttribute('data-group');
                const dayName = classItem.getAttribute('data-day');
                const laTime = classItem.getAttribute('data-time');

                if (!groupName || !dayName || !laTime) {
                  console.error('[SkipClassManager] Missing class data attributes');
                  return;
                }

                const classData = {
                  groupName,
                  dayName,
                  laTime,
                };

                showSkipDialog(classData);
              });

              timerElement._skipHandlerAttached = true;
            };

            // Try attaching handlers after a short delay
            setTimeout(attachHandlers, 500);
            setTimeout(attachHandlers, 1500); // Retry after 1.5s
            setTimeout(attachHandlers, 3000); // Retry after 3s

            // Listen for timer being opened
            window.addEventListener('timerOpened', () => {
              setTimeout(attachHandlers, 200);
            });

            // Also attach when timer is reinitialized
            window.addEventListener('groups:updated', () => {
              setTimeout(attachHandlers, 600);
            });
            window.addEventListener('schedules:updated', () => {
              setTimeout(attachHandlers, 600);
            });
          }

          // Public API
          return {
            init,
            isClassSkipped,
            isClassCanceled,
            getSkipInfo,
            skipClass,
            cancelClass,
            unskipClass,
            confirmSkip,
            confirmCancelClass,
            cancelSkip,
            findNextActiveClassDate,
            getSkippedClasses: () => ({ ...skippedClasses }),
            reloadFromSupabase: async () => {
              debugLog('üîÑ [SkipClassManager] Reloading from Supabase...');
              skippedClasses = await loadSkippedClasses();
              debugLog('‚úÖ [SkipClassManager] Reloaded', Object.keys(skippedClasses).length, 'groups');

              // Refresh UI if calendar or timer is visible
              if (typeof renderCalendar === 'function') {
                try {
                  renderCalendar();
                } catch (e) {
                  console.warn('[SkipClassManager] Could not refresh calendar:', e);
                }
              }
              if (window.ClassCountdownTimer && window.ClassCountdownTimer.isActive()) {
                window.ClassCountdownTimer.destroy();
                setTimeout(() => window.ClassCountdownTimer.init(), 100);
              }
            },
          };
        })();

        // Initialize Skip Class Manager
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            SkipClassManager.init();
          });
        } else {
          SkipClassManager.init();
        }

        // ============================================================================
        // END SKIP CLASS MANAGER
        // ============================================================================

        // ============================================================================
        // ABSENT MANAGER - Cloud Sync for Student Absences ‚òÅÔ∏è
        // ============================================================================
        /**
         * Absent Manager - Supabase Cloud Sync Version
         * - Tracks when students are marked absent
         * - Syncs across all devices via Supabase
         * - Fallback to localStorage for offline support
         */
        window.AbsentManager = (function () {
          // Absences data structure: { studentId: { 'YYYY-MM-DD': true } }
          let absences = {};
          let isInitialized = false;

          // Load absences from Supabase
          async function loadAbsences() {
            try {
              debugLog('‚òÅÔ∏è Loading absences from Supabase...');
              const { data, error } = await supabase.from('student_absences').select('*');

              if (error) {
                console.error('‚ùå Error loading absences from Supabase:', error);
                loadAbsencesFromLocalStorage();
                return;
              }

              // debugLog('‚úÖ Loaded absences from Supabase:', data);

              // Convert array to nested object: { studentId: { 'YYYY-MM-DD': true } }
              absences = {};
              (data || []).forEach(record => {
                const studentId = record.student_id;
                const dateStr = record.class_date;

                if (!absences[studentId]) {
                  absences[studentId] = {};
                }
                absences[studentId][dateStr] = true;
              });

              // console.log('üìä Absences loaded:', absences);
            } catch (err) {
              console.error('‚ùå Exception loading absences:', err);
              loadAbsencesFromLocalStorage();
            }
          }

          // Save absences to Supabase
          async function saveAbsences() {
            try {
              debugLog('‚òÅÔ∏è Saving absences to Supabase...');

              // Convert nested object to array of records
              const records = [];
              for (const studentId in absences) {
                for (const dateStr in absences[studentId]) {
                  if (absences[studentId][dateStr]) {
                    records.push({
                      student_id: parseInt(studentId),
                      class_date: dateStr,
                    });
                  }
                }
              }

              // Delete all existing records
              const { error: deleteError } = await supabase.from('student_absences').delete().neq('id', 0);

              if (deleteError) {
                console.error('‚ùå Error deleting absences:', deleteError);
                saveAbsencesToLocalStorage();
                return;
              }

              // Insert new records
              if (records.length > 0) {
                const { error: insertError } = await supabase.from('student_absences').insert(records);

                if (insertError) {
                  console.error('‚ùå Error inserting absences:', insertError);
                  saveAbsencesToLocalStorage();
                  return;
                }
              }

              debugLog('‚úÖ Saved absences to Supabase:', records.length, 'records');
              saveAbsencesToLocalStorage(); // Keep localStorage as backup
            } catch (err) {
              console.error('‚ùå Exception saving absences:', err);
              saveAbsencesToLocalStorage();
            }
          }

          // Fallback: Load from localStorage
          function loadAbsencesFromLocalStorage() {
            debugLog('üì¶ Loading absences from localStorage (fallback)...');
            // Migrate from old format: absent:studentId:dateStr
            absences = {};
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('absent:')) {
                const [, studentId, dateStr] = key.split(':');
                if (localStorage.getItem(key) === 'true') {
                  if (!absences[studentId]) {
                    absences[studentId] = {};
                  }
                  absences[studentId][dateStr] = true;
                }
              }
            }
            debugLog('üì¶ Loaded absences from localStorage:', absences);
          }

          // Fallback: Save to localStorage
          function saveAbsencesToLocalStorage() {
            debugLog('üì¶ Saving absences to localStorage (fallback)...');
            // Clear old absence keys
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('absent:')) {
                keysToRemove.push(key);
              }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));

            // Save new absences
            for (const studentId in absences) {
              for (const dateStr in absences[studentId]) {
                if (absences[studentId][dateStr]) {
                  const key = `absent:${studentId}:${dateStr}`;
                  localStorage.setItem(key, 'true');
                }
              }
            }
          }

          // Initialize: Load from Supabase
          async function init() {
            if (isInitialized) return;
            // debugLog('üöÄ Initializing AbsentManager...');
            await loadAbsences();
            isInitialized = true;
          }

          // Public API
          return {
            init,

            // Check if student is absent on a date
            isAbsent(studentId, dateStr) {
              return !!(absences[studentId] && absences[studentId][dateStr]);
            },

            // Mark student as absent
            async markAbsent(studentId, dateStr) {
              if (!absences[studentId]) {
                absences[studentId] = {};
              }
              absences[studentId][dateStr] = true;
              await saveAbsences();

              // AUTO-SEND: Absence Notification Email
              const students = getCachedStudents();
              const student = students.find(s => String(s.id) === String(studentId));

              if (student && student.email) {
                debugLog('üìß Sending absence notification email to:', student.name);
                try {
                  // Get group name from student
                  const groupName = student.group || 'your class';
                  await sendAbsenceNotificationEmail(student, groupName, dateStr);
                } catch (emailError) {
                  console.error('‚ö†Ô∏è Absence notification email failed:', emailError);
                  // Don't block absence marking - email failure is non-critical
                }
              }
            },

            // Remove absent mark
            async removeAbsent(studentId, dateStr) {
              if (absences[studentId]) {
                delete absences[studentId][dateStr];
                if (Object.keys(absences[studentId]).length === 0) {
                  delete absences[studentId];
                }
              }
              await saveAbsences();
            },

            // Reload from Supabase (for manual sync)
            async reloadFromSupabase() {
              debugLog('üîÑ Reloading absences from Supabase...');
              await loadAbsences();
            },
          };
        })();

        // Initialize AbsentManager
        if (window.supabase) {
          window.AbsentManager.init().catch(err => {
            console.error('Failed to initialize AbsentManager:', err);
          });
        }

        // ============================================================================
        // END ABSENT MANAGER
        // ============================================================================

        // ============================================================================
        // CREDIT PAYMENT MANAGER - Cloud Sync for Credit Payments ‚òÅÔ∏è
        // ============================================================================
        /**
         * Credit Payment Manager - Supabase Cloud Sync Version
         * - Tracks when student credit/balance is applied to pay for a class
         * - Syncs across all devices via Supabase
         * - Fallback to localStorage for offline support
         */
        window.CreditPaymentManager = (function () {
          // Credit payments data structure: { studentId: { 'YYYY-MM-DD': {amount, balance} } }
          let creditPayments = {};
          let isInitialized = false;

          // Load credit payments from Supabase
          async function loadCreditPayments() {
            try {
              debugLog('‚òÅÔ∏è Loading credit payments from Supabase...');
              const { data, error } = await supabase.from('credit_payments').select('*');

              if (error) {
                console.error('‚ùå Error loading credit payments from Supabase:', error);
                loadCreditPaymentsFromLocalStorage();
                return;
              }

              // debugLog('‚úÖ Loaded credit payments from Supabase:', data);

              // Convert array to nested object
              creditPayments = {};
              (data || []).forEach(record => {
                const studentId = record.student_id;
                const dateStr = record.class_date;

                if (!creditPayments[studentId]) {
                  creditPayments[studentId] = {};
                }
                creditPayments[studentId][dateStr] = {
                  amount: parseFloat(record.amount),
                  balance: record.balance_after ? parseFloat(record.balance_after) : null,
                };
              });

              // console.log('üìä Credit payments loaded:', creditPayments);
            } catch (err) {
              console.error('‚ùå Exception loading credit payments:', err);
              loadCreditPaymentsFromLocalStorage();
            }
          }

          // Save credit payments to Supabase
          async function saveCreditPayments() {
            try {
              debugLog('‚òÅÔ∏è Saving credit payments to Supabase...');

              // Convert nested object to array of records
              const records = [];
              for (const studentId in creditPayments) {
                for (const dateStr in creditPayments[studentId]) {
                  const payment = creditPayments[studentId][dateStr];
                  records.push({
                    student_id: parseInt(studentId),
                    class_date: dateStr,
                    amount: payment.amount,
                    balance_after: payment.balance,
                  });
                }
              }

              // Delete all existing records
              const { error: deleteError } = await supabase.from('credit_payments').delete().neq('id', 0);

              if (deleteError) {
                console.error('‚ùå Error deleting credit payments:', deleteError);
                saveCreditPaymentsToLocalStorage();
                return;
              }

              // Insert new records
              if (records.length > 0) {
                const { error: insertError } = await supabase.from('credit_payments').insert(records);

                if (insertError) {
                  console.error('‚ùå Error inserting credit payments:', insertError);
                  saveCreditPaymentsToLocalStorage();
                  return;
                }
              }

              debugLog('‚úÖ Saved credit payments to Supabase:', records.length, 'records');
              saveCreditPaymentsToLocalStorage(); // Keep localStorage as backup
            } catch (err) {
              console.error('‚ùå Exception saving credit payments:', err);
              saveCreditPaymentsToLocalStorage();
            }
          }

          // Fallback: Load from localStorage
          function loadCreditPaymentsFromLocalStorage() {
            debugLog('üì¶ Loading credit payments from localStorage (fallback)...');
            creditPayments = {};
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('credit-payment:')) {
                const [, , studentId, dateStr] = key.split(':');
                const value = localStorage.getItem(key);
                if (value) {
                  try {
                    const data = JSON.parse(value);
                    if (!creditPayments[studentId]) {
                      creditPayments[studentId] = {};
                    }
                    creditPayments[studentId][dateStr] = {
                      amount: data.amount,
                      balance: data.balance,
                    };
                  } catch (e) {
                    console.error('Error parsing credit payment:', e);
                  }
                }
              }
            }
            debugLog('üì¶ Loaded credit payments from localStorage:', creditPayments);
          }

          // Fallback: Save to localStorage
          function saveCreditPaymentsToLocalStorage() {
            debugLog('üì¶ Saving credit payments to localStorage (fallback)...');
            // Clear old credit payment keys
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('credit-payment:')) {
                keysToRemove.push(key);
              }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));

            // Save new credit payments
            for (const studentId in creditPayments) {
              for (const dateStr in creditPayments[studentId]) {
                const payment = creditPayments[studentId][dateStr];
                const key = `credit-payment:${studentId}:${dateStr}`;
                localStorage.setItem(key, JSON.stringify(payment));
              }
            }
          }

          // Initialize: Load from Supabase
          async function init() {
            if (isInitialized) return;
            // debugLog('üöÄ Initializing CreditPaymentManager...');
            await loadCreditPayments();
            isInitialized = true;
          }

          // Public API
          return {
            init,

            // Check if credit was applied for a student on a date
            getCreditPayment(studentId, dateStr) {
              return creditPayments[studentId] && creditPayments[studentId][dateStr];
            },

            // Apply credit payment
            async applyCreditPayment(studentId, dateStr, amount, balance) {
              if (!creditPayments[studentId]) {
                creditPayments[studentId] = {};
              }
              creditPayments[studentId][dateStr] = { amount, balance };
              await saveCreditPayments();
            },

            // Remove credit payment
            async removeCreditPayment(studentId, dateStr) {
              if (creditPayments[studentId]) {
                delete creditPayments[studentId][dateStr];
                if (Object.keys(creditPayments[studentId]).length === 0) {
                  delete creditPayments[studentId];
                }
              }
              await saveCreditPayments();
            },

            // Reload from Supabase (for manual sync)
            async reloadFromSupabase() {
              debugLog('üîÑ Reloading credit payments from Supabase...');
              await loadCreditPayments();
            },
          };
        })();

        // Initialize CreditPaymentManager
        if (window.supabase) {
          window.CreditPaymentManager.init().catch(err => {
            console.error('Failed to initialize CreditPaymentManager:', err);
          });
        }

        // ============================================================================
        // END CREDIT PAYMENT MANAGER
        // ============================================================================

        // Initialize Floating Nav on DOM ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initFloatingNav);
        } else {
          // DOM already loaded
          initFloatingNav();
        }
        // ========== END FLOATING NAV FUNCTIONS ==========

        // ============================================================================
        // BEGIN EARNING FORECAST SYSTEM
        // ============================================================================

        function openEarningsForecast() {
          const modal = document.getElementById('earningsForecastModal');
          if (!modal) return;

          modal.style.display = 'block';
          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });

          // Calculate and display forecast
          updateForecastData();
        }

        function closeEarningsForecast() {
          const modal = document.getElementById('earningsForecastModal');
          if (!modal) return;

          modal.style.opacity = '0';
          setTimeout(() => {
            modal.style.display = 'none';
          }, 250);
        }

        function updateForecastData() {
          // Load students data from Supabase cache
          const students = window.studentsCache || window.globalData?.students || [];

          // Safety check: ensure students is an array
          if (!Array.isArray(students)) {
            console.warn('‚ö†Ô∏è Students data is not an array:', students);
            document.getElementById('forecastActiveCount').textContent = '0';
            document.getElementById('forecastWeekly').textContent = formatCurrency(0, '$');
            document.getElementById('forecastMonthly').textContent = formatCurrency(0, '$');
            document.getElementById('forecastActual').textContent = formatCurrency(0, '$');
            return;
          }

          // Filter active students only (exclude paused, graduated, inactive)
          const activeStudents = students.filter(s => {
            const status = (s.status || 'active').toLowerCase();
            return status === 'active' && s.isActive !== false;
          });

          // Calculate weekly and monthly projections
          let totalWeekly = 0;
          let activeCount = 0;

          activeStudents.forEach(student => {
            // Get student's per-class payment rate
            const pricePerClass = parseFloat(student.payPerClass) || 0;

            // Skip if no price set
            if (pricePerClass <= 0) return;

            const groupName = student.group || '';

            // Skip if no group assigned
            if (!groupName.trim()) return;

            // Count weekly classes for this student's group
            const weeklyClasses = countWeeklyClasses(groupName);

            // Skip if group has no schedule
            if (weeklyClasses <= 0) return;

            // Calculate: student's weekly earning = price per class √ó weekly classes
            const studentWeekly = pricePerClass * weeklyClasses;

            // Add to total
            totalWeekly += studentWeekly;
            activeCount++;
          });

          // Calculate monthly projection (weekly √ó 4)
          const totalMonthly = totalWeekly * 4;

          // Calculate actual earnings for current month
          const actualEarnings = calculateActualMonthlyEarnings();

          // Update UI with formatted values
          document.getElementById('forecastActiveCount').textContent = activeCount;
          document.getElementById('forecastWeekly').textContent = formatCurrency(totalWeekly, '$');
          document.getElementById('forecastMonthly').textContent = formatCurrency(totalMonthly, '$');
          document.getElementById('forecastActual').textContent = formatCurrency(actualEarnings, '$');
        }

        function countWeeklyClasses(groupName) {
          // Return 0 if no group name provided
          if (!groupName || !groupName.trim()) return 0;

          // Load groups from Supabase cache
          const groups = window.groupsCache || window.globalData?.groups || [];

          // Find the group by name
          const group = groups.find(g => g.name === groupName);

          // Return 0 if group not found or no schedule
          if (!group || !group.schedule) return 0;

          // Parse schedule string (e.g., "Mon 8:00 AM, Wed 8:00 PM, Fri 8:00 PM")
          // Count comma-separated day-time slots
          const scheduleString = group.schedule.trim();

          if (!scheduleString) return 0;

          // Split by comma and count non-empty slots
          const slots = scheduleString.split(',').filter(slot => slot.trim() !== '');

          return slots.length;
        }

        function calculateActualMonthlyEarnings() {
          // Load payments from localStorage
          const payments = PaymentStore.getAll();

          // Get current month and year
          const now = new Date();
          const currentMonth = now.getMonth();
          const currentYear = now.getFullYear();

          let total = 0;

          payments.forEach(payment => {
            // Skip ignored payments
            if (payment.ignoredOnce || payment.ignorePermanently) return;

            // Get payment date (try multiple date fields)
            const dateString = payment.emailDate || payment.transactionDate || payment.createdAt;

            if (!dateString) return;

            const paymentDate = new Date(dateString);

            // Validate date
            if (isNaN(paymentDate.getTime())) return;

            // Check if payment is from current month and year
            if (paymentDate.getMonth() === currentMonth && paymentDate.getFullYear() === currentYear) {
              const amount = parseFloat(payment.amount) || 0;
              total += amount;
            }
          });

          return total;
        }

        // Listen for data updates to refresh forecast automatically
        window.addEventListener('students:updated', () => {
          const modal = document.getElementById('earningsForecastModal');
          if (modal && modal.style.display === 'block') {
            updateForecastData();
          }
        });

        window.addEventListener('payments:updated', () => {
          const modal = document.getElementById('earningsForecastModal');
          if (modal && modal.style.display === 'block') {
            updateForecastData();
          }
        });

        window.addEventListener('groups:updated', () => {
          const modal = document.getElementById('earningsForecastModal');
          if (modal && modal.style.display === 'block') {
            updateForecastData();
          }
        });

        window.addEventListener('schedules:updated', () => {
          const modal = document.getElementById('earningsForecastModal');
          if (modal && modal.style.display === 'block') {
            updateForecastData();
          }
        });

        // ============================================================================
        // STUDENT BREAKDOWN MODAL
        // ============================================================================

        async function openStudentBreakdown() {
          const modal = document.getElementById('studentBreakdownModal');
          if (!modal) return;

          // Reload students from Supabase to get latest status
          try {
            window.studentsCache = await loadStudents();
          } catch (error) {
            console.error('Error reloading students:', error);
          }

          // Calculate and display breakdown
          updateStudentBreakdown();

          modal.style.display = 'block';
          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
        }

        function closeStudentBreakdown() {
          const modal = document.getElementById('studentBreakdownModal');
          if (!modal) return;

          modal.style.opacity = '0';
          setTimeout(() => {
            modal.style.display = 'none';
          }, 250);
        }

        function updateStudentBreakdown() {
          const students = window.studentsCache || window.globalData?.students || [];
          const container = document.getElementById('studentBreakdownList');

          if (!container) return;

          // Safety check
          if (!Array.isArray(students)) {
            console.warn('‚ö†Ô∏è Students data is not an array in breakdown:', students);
            container.innerHTML = '<div class="no-data">No student data available</div>';
            return;
          }

          // Show ACTIVE and PAUSED students only ‚Äî exclude GRADUATED entirely
          const eligibleStudents = students.filter(s => {
            if (s.isActive === false) return false;
            const status = normalizeStatus(s.status);
            return status === 'active' || status === 'paused';
          });

          let totalWeekly = 0;
          let html = '';

          // Build list of students with their earnings
          const studentData = [];

          eligibleStudents.forEach(student => {
            const pricePerClass = parseFloat(student.payPerClass) || 0;
            if (pricePerClass <= 0) return;

            const groupName = student.group || '';
            if (!groupName.trim()) return;

            const weeklyClasses = countWeeklyClasses(groupName);
            if (weeklyClasses <= 0) return;

            const studentWeekly = pricePerClass * weeklyClasses;
            const studentMonthly = studentWeekly * 4;

            // Only count active students in totals
            const studentStatus = normalizeStatus(student.status);
            if (studentStatus === 'active') {
              totalWeekly += studentWeekly;
            }

            studentData.push({
              id: student.id,
              name: student.name,
              group: groupName,
              pricePerClass,
              weeklyClasses,
              studentWeekly,
              studentMonthly,
              status: studentStatus,
            });
          });

          // Sort by status first (active before paused), then by name within each status
          studentData.sort((a, b) => {
            // Active students come before paused students
            if (a.status === 'active' && b.status === 'paused') return -1;
            if (a.status === 'paused' && b.status === 'active') return 1;
            // Within same status, sort alphabetically by name
            return a.name.localeCompare(b.name);
          });

          // Generate HTML
          studentData.forEach(data => {
            // Determine if student is paused (graduated students don't appear in this modal)
            const isPaused = data.status === 'paused';
            const statusDetails = getStatusDetails(data.status);

            // Apply grayed-out styling for paused students
            const cardOpacity = isPaused ? '0.4' : '1';
            const cardFilter = isPaused ? 'grayscale(0.6)' : 'none';
            const cardBg = isPaused ? 'rgba(255,255,255,0.015)' : 'rgba(255,255,255,0.03)';
            const cardBgHover = isPaused ? 'rgba(255,255,255,0.025)' : 'rgba(255,255,255,0.06)';

            html += `
          <div style="padding: 16px; background: ${cardBg}; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; transition: all 0.2s; opacity: ${cardOpacity}; filter: ${cardFilter};" onmouseover="this.style.background='${cardBgHover}'" onmouseout="this.style.background='${cardBg}'">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 4px;">
                  <div style="font-size: 16px; font-weight: 700; color: white;">${escapeHtml(data.name)}</div>
                  <span class="status-pill-single status-${data.status}"
                        onclick="cycleStatusInBreakdown(${data.id})"
                        title="Click to cycle: Active ‚Üí Paused ‚Üí Graduated"
                        style="cursor: pointer; user-select: none; transition: all 0.2s;">
                    ${statusDetails.label}
                  </span>
                </div>
                <div style="font-size: 12px; color: #94a3b8;">${isPaused ? '‚è∏ ' : ''}Group ${escapeHtml(data.group)} ‚Ä¢ ${data.weeklyClasses} classes/week ‚Ä¢ ${formatCurrency(data.pricePerClass, '$')}/class</div>
              </div>
            </div>
            <div style="display: flex; gap: 16px; margin-top: 12px;">
              <div style="flex: 1; padding: 10px; background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3); border-radius: 8px;">
                <div style="font-size: 10px; font-weight: 700; color: #22c55e; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Weekly</div>
                <div style="font-size: 18px; font-weight: 900; color: white;">${formatCurrency(data.studentWeekly, '$')}</div>
              </div>
              <div style="flex: 1; padding: 10px; background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.4); border-radius: 8px;">
                <div style="font-size: 10px; font-weight: 700; color: #22c55e; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Monthly</div>
                <div style="font-size: 18px; font-weight: 900; color: white;">${formatCurrency(data.studentMonthly, '$')}</div>
              </div>
            </div>
          </div>
        `;
          });

          // Show message if no students
          if (studentData.length === 0) {
            html =
              '<div style="padding: 40px; text-align: center; color: #94a3b8; font-style: italic;">No active or paused students with pricing and schedules</div>';
          }

          container.innerHTML = html;

          // Update totals
          const totalMonthly = totalWeekly * 4;
          document.getElementById('breakdownTotalWeekly').textContent = formatCurrency(totalWeekly, '$');
          document.getElementById('breakdownTotalMonthly').textContent = formatCurrency(totalMonthly, '$');
        }

        // Cycle student status from within the breakdown modal
        async function cycleStatusInBreakdown(studentId) {
          // Get students from cache
          const students = window.studentsCache || window.globalData?.students || [];
          const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));

          if (!student) {
            console.error('‚ùå Student not found:', studentId);
            showNotificationSimple('‚ùå Student not found', 'error');
            return;
          }

          // Define status cycle: Active ‚Üí Paused ‚Üí Graduated ‚Üí Active
          const statusCycle = {
            [STUDENT_STATUSES.ACTIVE]: STUDENT_STATUSES.PAUSED,
            [STUDENT_STATUSES.PAUSED]: STUDENT_STATUSES.GRADUATED,
            [STUDENT_STATUSES.GRADUATED]: STUDENT_STATUSES.ACTIVE,
          };

          const oldStatus = normalizeStatus(student.status);
          const newStatus = statusCycle[oldStatus] || STUDENT_STATUSES.ACTIVE;

          student.status = newStatus;

          // Record timestamp when status changes to paused or graduated
          if (newStatus === STUDENT_STATUSES.PAUSED || newStatus === STUDENT_STATUSES.GRADUATED) {
            student.statusChangedDate = new Date().toISOString();
          } else {
            student.statusChangedDate = null;
          }

          // Save to Supabase
          const saved = await saveStudent(student);

          if (!saved) {
            showNotificationSimple('‚ùå Failed to update status', 'error');
            return;
          }

          // Update cache
          Object.assign(student, saved);
          window.studentsCache = students;

          // Refresh the breakdown modal WITHOUT reordering
          // This will update the UI while maintaining current order
          updateStudentBreakdown();

          // Also fire event so other modules can update if needed
          window.dispatchEvent(new CustomEvent('students:updated'));

          showNotificationSimple(`‚úÖ ${student.name} status updated to ${newStatus}`, 'success');
        }

        // ============================================================================
        // SMART CALENDAR PAYMENT SYSTEM
        // ============================================================================

        let currentCalendarDate = new Date();
        let studentBalances = {}; // Track advance payments per student

        // Storage key for balances
        const BALANCE_STORAGE_KEY = 'firestone:student-balances:v1';
        const CALENDAR_SNAPSHOT_KEY = 'firestone:calendar-snapshots:v1';

        // Calendar start date - November 1, 2025
        const CALENDAR_START_DATE = new Date('2025-11-01T00:00:00');

        // Load balances from localStorage
        function loadStudentBalances() {
          const stored = localStorage.getItem(BALANCE_STORAGE_KEY);
          return stored ? JSON.parse(stored) : {};
        }

        // Save balances to localStorage
        function saveStudentBalances(balances) {
          localStorage.setItem(BALANCE_STORAGE_KEY, JSON.stringify(balances));
          studentBalances = balances;
        }

        // Load calendar snapshots (frozen historical data)
        function loadCalendarSnapshots() {
          const stored = localStorage.getItem(CALENDAR_SNAPSHOT_KEY);
          return stored ? JSON.parse(stored) : {};
        }

        // Save calendar snapshot for a specific date
        function saveCalendarSnapshot(dateStr, studentData) {
          const snapshots = loadCalendarSnapshots();

          // Initialize snapshot for this date if it doesn't exist
          if (!snapshots[dateStr]) {
            snapshots[dateStr] = {
              students: {},
              frozenAt: new Date().toISOString(),
            };
          }

          // Merge student data (don't overwrite existing students)
          snapshots[dateStr].students = {
            ...snapshots[dateStr].students,
            ...studentData,
          };

          // Update frozen timestamp
          snapshots[dateStr].frozenAt = new Date().toISOString();

          localStorage.setItem(CALENDAR_SNAPSHOT_KEY, JSON.stringify(snapshots));
        }

        // Get snapshot for a date if it exists
        function getCalendarSnapshot(dateStr) {
          const snapshots = loadCalendarSnapshots();
          return snapshots[dateStr] || null;
        }

        // Initialize balances
        studentBalances = loadStudentBalances();

        // Helper function to get current date in LA timezone
        function getLADate() {
          const now = new Date();
          const laTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }));
          return laTime;
        }

        // Helper function to convert any date to LA timezone
        function toLADate(date) {
          // Convert UTC date to LA timezone properly
          // Don't use toLocaleString + new Date as it corrupts the time!
          const utcDate = new Date(date);

          // Get the LA timezone offset for this specific date (handles DST)
          const laDateStr = utcDate.toLocaleString('en-US', {
            timeZone: 'America/Los_Angeles',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false,
          });

          // Parse "MM/DD/YYYY, HH:mm:ss" format
          const [datePart, timePart] = laDateStr.split(', ');
          const [month, day, year] = datePart.split('/');
          const [hour, minute, second] = timePart.split(':');

          // Create date object with LA time components
          return new Date(year, month - 1, day, hour, minute, second);
        }

        function openSmartCalendar() {
          const modal = document.getElementById('smartCalendarModal');
          if (!modal) return;

          currentCalendarDate = getLADate();
          renderCalendar();

          modal.style.display = 'block';
          requestAnimationFrame(() => {
            modal.style.opacity = '1';
          });
        }

        function closeSmartCalendar() {
          const modal = document.getElementById('smartCalendarModal');
          if (!modal) return;

          modal.style.opacity = '0';
          setTimeout(() => {
            modal.style.display = 'none';
          }, 300);
        }

        // ============================================================================
        // NOTIFICATION CENTER UI FUNCTIONS
        // ============================================================================

        function openNotificationCenter() {
          const overlay = document.getElementById('notificationCenterOverlay');
          const panel = document.getElementById('notificationCenterPanel');
          if (!overlay || !panel) return;

          debugLog('[NotificationCenter] üîî Opening notification center...');

          // Reload notifications from Supabase to get latest
          if (window.NotificationCenter) {
            window.NotificationCenter.initialize().then(() => {
              debugLog('[NotificationCenter] üîÑ Reloaded notifications from Supabase');
              renderNotifications();
            });
          } else {
            renderNotifications();
          }

          // Show with fade-in
          overlay.style.display = 'block';
          panel.style.display = 'flex';

          requestAnimationFrame(() => {
            overlay.style.opacity = '1';
            panel.style.opacity = '1';
          });
        }

        function closeNotificationCenter() {
          const overlay = document.getElementById('notificationCenterOverlay');
          const panel = document.getElementById('notificationCenterPanel');
          if (!overlay || !panel) return;

          overlay.style.opacity = '0';
          panel.style.opacity = '0';

          setTimeout(() => {
            overlay.style.display = 'none';
            panel.style.display = 'none';
          }, 300);
        }

        async function clearAllNotifications() {
          debugLog('[NotificationCenter] üóëÔ∏è Clearing all notifications...');

          if (!window.NotificationCenter) {
            console.error('[NotificationCenter] ‚ùå NotificationCenter not initialized');
            return;
          }

          // Get all notifications using the public API
          const allNotifications = window.NotificationCenter.getAll();
          console.log(`[NotificationCenter] Deleting ${allNotifications.length} notifications...`);

          // Delete each notification
          for (const notif of allNotifications) {
            await window.NotificationCenter.delete(notif.id);
          }

          debugLog('[NotificationCenter] ‚úÖ All notifications cleared');

          // Reload the notifications view
          await window.NotificationCenter.initialize();
          renderNotifications();

          showNotification('üóëÔ∏è All notifications cleared', 'success');
        }

        function renderNotifications() {
          const listContainer = document.getElementById('notificationsList');
          const countElement = document.getElementById('notificationCount');

          if (!listContainer || !window.NotificationCenter) return;

          const grouped = window.NotificationCenter.getGroupedByDate();
          const unreadCount = window.NotificationCenter.getUnreadCount();

          // Update count
          countElement.textContent = unreadCount > 0 ? `${unreadCount} unread` : 'All caught up';

          // Clear existing content
          listContainer.innerHTML = '';

          const dateKeys = Object.keys(grouped);

          if (dateKeys.length === 0) {
            listContainer.innerHTML = `
          <div style="text-align: center; padding: 60px 20px; color: rgba(255, 255, 255, 0.5);">
            <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;">üîî</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No notifications yet</div>
            <div style="font-size: 14px; opacity: 0.7;">You'll see updates here when things happen in the app</div>
          </div>
        `;
            return;
          }

          // Render each date group
          dateKeys.forEach(dateLabel => {
            const notifications = grouped[dateLabel];

            // Date header
            const dateHeader = document.createElement('div');
            dateHeader.style.cssText = `
          font-size: 12px;
          font-weight: 700;
          color: rgba(255, 255, 255, 0.5);
          text-transform: uppercase;
          letter-spacing: 0.8px;
          margin: 20px 0 12px 0;
          padding-bottom: 8px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
            dateHeader.textContent = dateLabel;
            listContainer.appendChild(dateHeader);

            // Render notifications for this date
            notifications.forEach(notification => {
              const notifElement = createNotificationElement(notification);
              listContainer.appendChild(notifElement);
            });
          });
        }

        function createNotificationElement(notification) {
          const div = document.createElement('div');
          div.className = 'notification-item';
          div.style.cssText = `
        background: ${notification.read ? 'rgba(255, 255, 255, 0.03)' : 'rgba(138, 180, 255, 0.1)'};
        border: 1px solid ${notification.read ? 'rgba(255, 255, 255, 0.08)' : 'rgba(138, 180, 255, 0.3)'};
        border-radius: 12px;
        padding: 14px 16px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
      `;

          // Get icon and color based on type
          const { icon, color } = getNotificationStyle(notification.type);

          // Unread indicator
          if (!notification.read) {
            const unreadDot = document.createElement('div');
            unreadDot.style.cssText = `
          position: absolute;
          top: 18px;
          left: -6px;
          width: 8px;
          height: 8px;
          background: #3b82f6;
          border-radius: 50%;
          box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
        `;
            div.appendChild(unreadDot);
          }

          // Header
          const header = document.createElement('div');
          header.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-bottom: 6px;';
          header.innerHTML = `
        <span style="font-size: 16px;">${icon}</span>
        <span style="font-size: 13px; font-weight: 600; color: ${color}; text-transform: uppercase; letter-spacing: 0.5px;">${getTypeLabel(notification.type)}</span>
        <span style="flex: 1;"></span>
        <span style="font-size: 11px; color: rgba(255, 255, 255, 0.4);">${formatNotificationTime(notification.timestamp)}</span>
      `;
          div.appendChild(header);

          // Title
          const title = document.createElement('div');
          title.style.cssText = 'font-size: 14px; font-weight: 600; color: #fff; margin-bottom: 4px;';
          title.textContent = notification.title;
          div.appendChild(title);

          // Description
          const description = document.createElement('div');
          description.style.cssText = 'font-size: 13px; color: rgba(255, 255, 255, 0.7); line-height: 1.5;';
          description.textContent = notification.description;
          div.appendChild(description);

          // Student/Group info if available
          if (notification.studentName || notification.groupName) {
            const info = document.createElement('div');
            info.style.cssText = 'font-size: 12px; color: rgba(255, 255, 255, 0.5); margin-top: 8px;';
            const parts = [];
            if (notification.studentName) parts.push(`üë§ ${notification.studentName}`);
            if (notification.groupName) parts.push(`üìö ${notification.groupName}`);
            info.textContent = parts.join('  ‚Ä¢  ');
            div.appendChild(info);
          }

          // Click handler
          div.addEventListener('click', () => {
            verboseLog('[NotificationClick] Clicked notification:', notification);
            verboseLog('[NotificationClick] Has metadata?', !!notification.metadata);
            verboseLog('[NotificationClick] Has emailBody?', notification.metadata?.emailBody ? 'YES' : 'NO');

            if (!notification.read) {
              window.NotificationCenter.markAsRead(notification.id);
            }

            // If notification has emailId (sent emails), open in email system
            if (notification.metadata && notification.metadata.emailId) {
              verboseLog('[NotificationClick] Opening sent email ID:', notification.metadata.emailId);
              const emailIframe = document.querySelector('iframe[src*="email-system-complete.html"]');
              if (emailIframe && emailIframe.contentWindow && emailIframe.contentWindow.viewSentEmail) {
                // Switch to EMAIL tab first
                const emailTabButton = document.querySelector('[data-tab="EMAIL"]');
                if (emailTabButton) emailTabButton.click();

                // Open the email in the iframe
                setTimeout(() => {
                  emailIframe.contentWindow.viewSentEmail(notification.metadata.emailId);
                }, 100);
              } else {
                console.warn('[NotificationClick] Email system iframe not found or viewSentEmail not available');
              }
            }
            // Show email content if available (for payment reminders)
            else if (notification.metadata && notification.metadata.emailBody) {
              verboseLog('[NotificationClick] Opening email preview...');
              showEmailPreview(notification);
            } else {
              verboseLog('[NotificationClick] No email body or emailId found in notification metadata');
            }

            renderNotifications();
          });

          // Hover effect
          div.addEventListener('mouseenter', () => {
            div.style.background = notification.read ? 'rgba(255, 255, 255, 0.06)' : 'rgba(138, 180, 255, 0.15)';
            div.style.transform = 'translateX(-2px)';
          });

          div.addEventListener('mouseleave', () => {
            div.style.background = notification.read ? 'rgba(255, 255, 255, 0.03)' : 'rgba(138, 180, 255, 0.1)';
            div.style.transform = 'translateX(0)';
          });

          return div;
        }

        function getNotificationStyle(type) {
          const styles = {
            email: { icon: 'üìß', color: '#3b82f6' },
            payment: { icon: 'üí∞', color: '#22c55e' },
            update: { icon: 'üìù', color: '#8ab4ff' },
            reminder: { icon: 'üîî', color: '#f59e0b' },
            system: { icon: '‚öôÔ∏è', color: '#94a3b8' },
            status_change: { icon: 'üîÑ', color: '#a78bfa' },
            group_change: { icon: 'üìö', color: '#ec4899' },
            schedule_update: { icon: 'üìÖ', color: '#06b6d4' },
            absence: { icon: 'üö´', color: '#ef4444' },
          };
          return styles[type] || styles.system;
        }

        function getTypeLabel(type) {
          const labels = {
            email: 'Email',
            payment: 'Payment',
            update: 'Update',
            reminder: 'Reminder',
            system: 'System',
            status_change: 'Status',
            group_change: 'Group',
            schedule_update: 'Schedule',
            absence: 'Absence',
          };
          return labels[type] || 'Notification';
        }

        function formatNotificationTime(timestamp) {
          const now = new Date();
          const notifTime = new Date(timestamp);
          const diffMs = now - notifTime;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return 'Just now';
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;

          return notifTime.toLocaleDateString('en-US', {
            timeZone: 'America/Los_Angeles',
            month: 'short',
            day: 'numeric',
          });
        }

        async function markAllNotificationsAsRead() {
          if (!window.NotificationCenter) return;

          const success = await window.NotificationCenter.markAllAsRead();
          if (success) {
            renderNotifications();
            showNotification('‚úÖ All notifications marked as read', 'success');
          }
        }

        // Show email preview modal
        function showEmailPreview(notification) {
          const { metadata } = notification;
          if (!metadata || !metadata.emailBody) return;

          // Create modal overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          z-index: 200000;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
          backdrop-filter: blur(4px);
        `;

          // Create modal content
          const modal = document.createElement('div');
          modal.style.cssText = `
          background: #1e293b;
          border-radius: 16px;
          width: 800px;
          height: 85vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
          border: 1px solid rgba(255, 255, 255, 0.1);
        `;

          // Header
          const header = document.createElement('div');
          header.style.cssText = `
          padding: 20px 24px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
          display: flex;
          align-items: center;
          justify-content: space-between;
        `;
          header.innerHTML = `
          <div>
            <div style="font-size: 18px; font-weight: 700; color: #fff; margin-bottom: 4px;">
              üìß ${metadata.emailSubject || 'Email Preview'}
            </div>
            <div style="font-size: 13px; color: rgba(255, 255, 255, 0.6);">
              Sent to: ${metadata.email} on ${metadata.date || ''}
            </div>
          </div>
          <button id="closeEmailPreview" style="
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
          ">‚úï</button>
        `;

          // Body (iframe for safe HTML rendering)
          const body = document.createElement('div');
          body.style.cssText = `
          flex: 1;
          overflow: auto;
          background: #fff;
          margin: 0;
        `;

          const iframe = document.createElement('iframe');
          iframe.style.cssText = `
          width: 100%;
          height: 100%;
          border: none;
          min-height: 400px;
        `;
          iframe.srcdoc = metadata.emailBody;
          body.appendChild(iframe);

          // Assemble modal
          modal.appendChild(header);
          modal.appendChild(body);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);

          // Close handlers
          const closeModal = () => {
            document.body.removeChild(overlay);
          };

          overlay.addEventListener('click', e => {
            if (e.target === overlay) closeModal();
          });

          header.querySelector('#closeEmailPreview').addEventListener('click', closeModal);

          // ESC key to close
          const handleEsc = e => {
            if (e.key === 'Escape') {
              closeModal();
              document.removeEventListener('keydown', handleEsc);
            }
          };
          document.addEventListener('keydown', handleEsc);
        }

        // ============================================================================
        // END NOTIFICATION CENTER UI FUNCTIONS
        // ============================================================================

        // ============================================================================
        // NOTIFICATION HELPER FUNCTIONS
        // ============================================================================

        // Helper: Log email sent notification
        window.logEmailNotification = async function (recipientName, subject, type = 'manual') {
          if (!window.NotificationCenter) return;

          await window.NotificationCenter.add(
            window.NotificationCenter.NotificationType.EMAIL,
            `Email Sent: ${subject}`,
            `Email sent to ${recipientName}`,
            {
              studentName: recipientName,
              metadata: {
                subject: subject,
                type: type,
                timestamp: new Date().toISOString(),
              },
            }
          );
        };

        // Helper: Log payment record notification
        window.logPaymentNotification = async function (payerName, amount, studentName = null) {
          if (!window.NotificationCenter) return;

          await window.NotificationCenter.add(
            window.NotificationCenter.NotificationType.PAYMENT,
            `Payment Recorded: $${amount}`,
            `Payment of $${amount} from ${payerName}${studentName ? ` (${studentName})` : ''}`,
            {
              studentName: studentName,
              metadata: {
                amount: amount,
                payerName: payerName,
                timestamp: new Date().toISOString(),
              },
            }
          );
        };

        // Helper: Log absence notification
        window.logAbsenceNotification = async function (studentName, date, groupName = null) {
          if (!window.NotificationCenter) return;

          await window.NotificationCenter.add(
            window.NotificationCenter.NotificationType.ABSENCE,
            `Absence Marked: ${studentName}`,
            `${studentName} marked absent on ${date}`,
            {
              studentName: studentName,
              groupName: groupName,
              metadata: {
                date: date,
                timestamp: new Date().toISOString(),
              },
            }
          );
        };

        // Helper: Log schedule update notification
        window.logScheduleNotification = async function (groupName, action, details = '') {
          if (!window.NotificationCenter) return;

          await window.NotificationCenter.add(
            window.NotificationCenter.NotificationType.SCHEDULE_UPDATE,
            `Schedule ${action}: ${groupName}`,
            `Group ${groupName} schedule ${action}${details ? ': ' + details : ''}`,
            {
              groupName: groupName,
              metadata: {
                action: action,
                details: details,
                timestamp: new Date().toISOString(),
              },
            }
          );
        };

        // Helper: Log system notification
        window.logSystemNotification = async function (title, description) {
          if (!window.NotificationCenter) return;

          await window.NotificationCenter.add(window.NotificationCenter.NotificationType.SYSTEM, title, description, {
            metadata: {
              timestamp: new Date().toISOString(),
            },
          });
        };

        // ============================================================================
        // END NOTIFICATION HELPER FUNCTIONS
        // ============================================================================

        function changeCalendarMonth(delta) {
          currentCalendarDate.setMonth(currentCalendarDate.getMonth() + delta);
          renderCalendar();
        }

        function renderCalendar() {
          const year = currentCalendarDate.getFullYear();
          const month = currentCalendarDate.getMonth();

          // Update header
          const monthNames = [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December',
          ];
          document.getElementById('calendarMonthYear').textContent = `${monthNames[month]} ${year}`;

          // Get calendar data
          const calendarData = generateCalendarData(year, month);

          // Store in global scope for PaymentReminderManager
          window.currentCalendarData = calendarData;

          // Dispatch calendar initialized event for automation engine
          if (!window._calendarInitializedDispatched) {
            window._calendarInitializedDispatched = true;
            debugLog('[Calendar] üìä Dispatching calendar:initialized event for automation engine');
            window.dispatchEvent(new CustomEvent('calendar:initialized', { detail: calendarData }));
          }

          // Update subtitle
          const totalClasses = calendarData.totalScheduledClasses;
          const activeStudentCount = calendarData.activeStudents.length;
          const monthPaid = calendarData.monthTotalPaid || 0;
          const monthUnpaid = calendarData.monthTotalUnpaid || 0;

          document.getElementById('calendarSubtitle').innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
          <span>${activeStudentCount} active student${activeStudentCount !== 1 ? 's' : ''} ‚Ä¢ ${totalClasses} scheduled class${totalClasses !== 1 ? 'es' : ''}</span>
          <span style="color: rgba(255,255,255,0.3);">|</span>
          <span style="color: #22c55e; font-weight: 600;">üí∞ ${formatCurrency(monthPaid, '$')} paid</span>
          <span style="color: rgba(255,255,255,0.3);">|</span>
          <span style="color: #ef4444; font-weight: 600;">‚ö†Ô∏è ${formatCurrency(monthUnpaid, '$')} pending</span>
        </div>
      `;

          // Render grid
          renderCalendarGrid(calendarData);
        }

        function generateCalendarData(year, month) {
          // Get first day of month and number of days
          const firstDay = new Date(year, month, 1).getDay();
          const daysInMonth = new Date(year, month + 1, 0).getDate();

          // Load data from Supabase cache
          const students = window.studentsCache || window.globalData?.students || [];
          const groups = window.groupsCache || window.globalData?.groups || [];
          const payments = PaymentStore.getAll();

          // Filter active students who are shown in calendar
          const activeStudents = students.filter(s => {
            const status = (s.status || 'active').toLowerCase();
            const showInGrid = s.showInGrid ?? s.show_in_grid ?? true;
            return status === 'active' && s.isActive !== false && showInGrid === true;
          });

          // Map students to their schedules
          const scheduleMap = {};
          let totalScheduledClasses = 0;

          activeStudents.forEach(student => {
            const groupName = student.group || '';
            if (!groupName.trim()) return;

            const group = groups.find(g => g.name === groupName);
            if (!group || !group.schedule) return;

            if (!scheduleMap[student.id]) {
              scheduleMap[student.id] = {
                student: student,
                group: group, // Store the full group object for one-time schedule checks
                pricePerClass: parseFloat(student.payPerClass) || 0,
              };
            }
          });

          // Build day data
          const days = [];
          let monthTotalPaid = 0;
          let monthTotalUnpaid = 0;

          for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month, day);
            const dayOfWeek = date.getDay();
            const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek];
            const dateStr = formatDateYYYYMMDD(date);

            // Check which students have class on this day
            const studentsWithClass = [];

            Object.values(scheduleMap).forEach(({ student, group, pricePerClass }) => {
              // Get schedule for this specific date (checks one-time overrides first)
              const scheduleDays = getScheduleForDate(group, dateStr);

              if (scheduleDays.includes(dayName)) {
                // FILTER: Only show classes on or after student's creation date
                const studentCreatedAt = student.created_at ? new Date(student.created_at) : null;
                const classDate = new Date(date);

                // Normalize both dates to date-only strings for comparison
                const classDateStr = formatDateYYYYMMDD(classDate);

                if (studentCreatedAt) {
                  const creationDateStr = formatDateYYYYMMDD(studentCreatedAt);

                  // Skip if class date is before student was created
                  if (classDateStr < creationDateStr) {
                    if (DEBUG_MODE) {
                      console.log(
                        '[Calendar] Hiding',
                        classDateStr,
                        'for',
                        student.name,
                        '- before creation',
                        creationDateStr
                      );
                    }
                    return; // Don't show this class
                  }
                } else {
                  // FALLBACK: Students without created_at use CALENDAR_START_DATE
                  const calendarStartStr = formatDateYYYYMMDD(CALENDAR_START_DATE);
                  if (classDateStr < calendarStartStr) {
                    if (DEBUG_MODE) {
                      verboseLog('[Calendar] Hiding', classDateStr, 'for', student.name, '- before calendar start');
                    }
                    return; // Don't show this class
                  }
                }

                const paymentStatus = checkPaymentStatus(student, date, pricePerClass, payments);
                studentsWithClass.push({
                  student,
                  pricePerClass,
                  ...paymentStatus,
                });
                totalScheduledClasses++;

                // Add to month totals
                const status = paymentStatus.status;
                const price = parseFloat(pricePerClass) || 0;
                if (status === 'paid' || status === 'deducted' || status === 'low-balance') {
                  monthTotalPaid += price;
                } else if (status === 'unpaid') {
                  monthTotalUnpaid += price;
                }
              }
            });

            days.push({
              day,
              date,
              dayName,
              studentsWithClass,
            });
          }

          return {
            firstDay,
            daysInMonth,
            days,
            activeStudents,
            totalScheduledClasses,
            monthTotalPaid,
            monthTotalUnpaid,
          };
        }

        // Get data for a specific day (used when refreshing day details sidebar)
        function getDayData(dateStr) {
          const date = new Date(dateStr);
          const year = date.getFullYear();
          const month = date.getMonth();
          const day = date.getDate();
          const dayOfWeek = date.getDay();
          const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek];

          // Load data from Supabase cache
          const students = window.studentsCache || window.globalData?.students || [];
          const groups = window.groupsCache || window.globalData?.groups || [];
          const payments = PaymentStore.getAll();

          // Filter active students
          const activeStudents = students.filter(s => {
            const status = (s.status || 'active').toLowerCase();
            return status === 'active' && s.isActive !== false;
          });

          // Map students to their schedules
          const scheduleMap = {};
          activeStudents.forEach(student => {
            const groupName = student.group || '';
            if (!groupName.trim()) return;

            const group = groups.find(g => g.name === groupName);
            if (!group || !group.schedule) return;

            if (!scheduleMap[student.id]) {
              scheduleMap[student.id] = {
                student: student,
                group: group, // Store the full group object for one-time schedule checks
                pricePerClass: parseFloat(student.payPerClass) || 0,
              };
            }
          });

          // Check which students have class on this day
          const studentsWithClass = [];
          Object.values(scheduleMap).forEach(({ student, group, pricePerClass }) => {
            // Get schedule for this specific date (checks one-time overrides first)
            const scheduleDays = getScheduleForDate(group, dateStr);

            if (scheduleDays.includes(dayName)) {
              // FILTER: Only show classes on or after student's creation date
              const studentCreatedAt = student.created_at ? new Date(student.created_at) : null;
              const classDate = new Date(date);

              // Normalize both dates to date-only strings for comparison
              const classDateStr = formatDateYYYYMMDD(classDate);

              if (studentCreatedAt) {
                const creationDateStr = formatDateYYYYMMDD(studentCreatedAt);

                // Skip if class date is before student was created
                if (classDateStr < creationDateStr) {
                  if (DEBUG_MODE) {
                    console.log(
                      '[DayData] Hiding',
                      classDateStr,
                      'for',
                      student.name,
                      '- before creation',
                      creationDateStr
                    );
                  }
                  return; // Don't show this class
                }
              } else {
                // FALLBACK: Students without created_at use CALENDAR_START_DATE
                const calendarStartStr = formatDateYYYYMMDD(CALENDAR_START_DATE);
                if (classDateStr < calendarStartStr) {
                  if (DEBUG_MODE) {
                    console.log('[DayData] Hiding', classDateStr, 'for', student.name, '- before calendar start');
                  }
                  return; // Don't show this class
                }
              }

              const paymentStatus = checkPaymentStatus(student, date, pricePerClass, payments);
              studentsWithClass.push({
                student,
                pricePerClass,
                ...paymentStatus,
              });
            }
          });

          return {
            day,
            date,
            dayName,
            studentsWithClass,
          };
        }

        function parseScheduleDays(scheduleString) {
          // Parse "Tue 8:00 PM, Thu 8:00 PM" or "Monday 8:00 PM, Wednesday 8:00 PM" ‚Üí ["Tuesday", "Thursday"]
          if (!scheduleString || !scheduleString.trim()) return [];

          // Remove Markdown bold markers (* and **) that may wrap the schedule
          const cleanedSchedule = scheduleString.replace(/\*\*/g, '').replace(/\*/g, '');

          // Map abbreviated day names to full names
          const dayMap = {
            sun: 'Sunday',
            mon: 'Monday',
            tue: 'Tuesday',
            wed: 'Wednesday',
            thu: 'Thursday',
            fri: 'Friday',
            sat: 'Saturday',
            sunday: 'Sunday',
            monday: 'Monday',
            tuesday: 'Tuesday',
            wednesday: 'Wednesday',
            thursday: 'Thursday',
            friday: 'Friday',
            saturday: 'Saturday',
          };

          const days = [];
          const slots = cleanedSchedule.split(',');

          slots.forEach(slot => {
            const trimmed = slot.trim().toLowerCase();

            // Try to match abbreviated or full day name at the start
            const dayMatch = trimmed.match(
              /^(sun|mon|tue|wed|thu|fri|sat|sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
            );

            if (dayMatch) {
              const fullDayName = dayMap[dayMatch[1].toLowerCase()];
              if (fullDayName && !days.includes(fullDayName)) {
                days.push(fullDayName);
              }
            }
          });

          return days;
        }

        // ===== CHECK FOR ONE-TIME SCHEDULE OVERRIDE =====
        function getScheduleForDate(group, dateStr) {
          // Check if there's a one-time schedule override for this specific date
          if (group.one_time_schedules && Array.isArray(group.one_time_schedules)) {
            // Filter out expired one-time schedules (dates before today)
            const today = formatDateYYYYMMDD(new Date());
            const activeOverrides = group.one_time_schedules.filter(override => override.date >= today);

            // Find override for this specific date
            const oneTimeOverride = activeOverrides.find(override => override.date === dateStr);
            if (oneTimeOverride) {
              // Return the one-time schedule day
              return [oneTimeOverride.day];
            }
          }

          // Fall back to regular recurring schedule
          return parseScheduleDays(group.schedule);
        }

        // ===== CLEANUP EXPIRED ONE-TIME SCHEDULES =====
        async function cleanupExpiredOneTimeSchedules() {
          const groups = window.groupsCache || [];
          const today = formatDateYYYYMMDD(new Date());
          let cleaned = false;

          for (const group of groups) {
            if (group.one_time_schedules && Array.isArray(group.one_time_schedules)) {
              const originalCount = group.one_time_schedules.length;

              // Filter out expired one-time schedules
              const activeOverrides = group.one_time_schedules.filter(override => override.date >= today);

              if (activeOverrides.length < originalCount) {
                // Some schedules were expired, update the group
                group.one_time_schedules = activeOverrides;
                await saveGroup(group);
                cleaned = true;
                debugLog(
                  `üßπ Cleaned ${originalCount - activeOverrides.length} expired one-time schedules from group ${group.name}`
                );
              }
            }
          }

          if (cleaned) {
            // Reload groups from Supabase to ensure consistency
            await loadGroupsFromSupabase();
            window.dispatchEvent(new CustomEvent('groups:updated', { detail: window.groupsCache }));
          }

          return cleaned;
        }

        function checkPaymentStatus(student, classDate, pricePerClass, payments) {
          const dateStr = formatDateYYYYMMDD(classDate);
          const studentId = student.id;
          const laToday = getLADate();
          const todayStr = formatDateYYYYMMDD(laToday);

          // CHECK 1: Is this student marked absent?
          if (window.AbsentManager && window.AbsentManager.isAbsent(studentId, dateStr)) {
            debugLog('Absent check - Student is marked absent:', { studentId, dateStr });
            return {
              status: 'absent',
              paid: false,
              amount: 0,
              balance: student.balance || 0,
              message: 'Marked Absent',
            };
          }

          // CHECK 1b: Was credit applied to this class?
          const creditPayment =
            window.CreditPaymentManager && window.CreditPaymentManager.getCreditPayment(studentId, dateStr);

          if (creditPayment) {
            return {
              status: 'deducted',
              paid: true,
              amount: creditPayment.amount,
              balance: student.balance || 0,
              message: `Paid from Credit (${formatCurrency(student.balance || 0, '$')} remaining)`,
            };
          }

          // CHECK 2: Is this class skipped?
          const groupName = student.group;
          if (groupName && window.SkipClassManager && window.SkipClassManager.isClassSkipped(groupName, dateStr)) {
            return {
              status: 'skipped',
              paid: false,
              amount: 0,
              balance: student.balance || 0,
              message: 'Class skipped - payments roll over',
              showActions: false,
            };
          }

          // RULE 1: Skip dates before November 1, 2025
          if (classDate < CALENDAR_START_DATE) {
            return {
              status: 'hidden',
              paid: false,
              amount: 0,
              balance: 0,
              message: 'Before calendar start date',
            };
          }

          // RULE 1b: Skip dates before student was created (NO RETROACTIVE UNPAID DOTS)
          // Students should not have red unpaid dots for classes before they existed
          // This prevents showing red dots for dates before the student was added to the system
          if (student.created_at) {
            // Parse student creation date and convert to LA timezone
            const studentCreatedAt = new Date(student.created_at);
            const studentCreatedLA = toLADate(studentCreatedAt);

            // Compare at day level (ignore time)
            const creationDateStr = formatDateYYYYMMDD(studentCreatedLA);

            if (dateStr < creationDateStr) {
              // Class date is before student existed - hide it
              debugLog(`[RedDot] Hiding ${dateStr} - before student creation (${creationDateStr})`);
              return {
                status: 'hidden',
                paid: false,
                amount: 0,
                balance: 0,
                message: 'Before student creation date',
              };
            }
          } else {
            // FALLBACK: If student has no created_at, use CALENDAR_START_DATE to avoid showing old red dots
            // This prevents existing students from having retroactive unpaid classes
            debugLog(`[RedDot] Student ${student.name} has no created_at - using calendar start date as fallback`);
            const calendarStartStr = formatDateYYYYMMDD(CALENDAR_START_DATE);

            if (dateStr < calendarStartStr) {
              // Class date is before calendar start - hide it
              debugLog(`[RedDot] Hiding ${dateStr} - before calendar start (${calendarStartStr})`);
              return {
                status: 'hidden',
                paid: false,
                amount: 0,
                balance: 0,
                message: 'Before calendar start date',
              };
            }
          }

          // RULE 2: Historical Freeze - Use snapshot for dates older than 2 weeks
          const twoWeeksAgo = new Date(laToday);
          twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

          if (classDate < twoWeeksAgo) {
            const snapshot = getCalendarSnapshot(dateStr);
            if (snapshot && snapshot.students && snapshot.students[studentId]) {
              // Return frozen data - immune to student/payment/group changes
              return snapshot.students[studentId];
            }
            // If no snapshot exists for this old date, recalculate once and freeze it
          }

          // RULE 3: Dynamic calculation for TODAY, recent past (< 2 weeks), and FUTURE dates
          const balance = student.balance || 0;

          // Find all payments for this student (by name or alias match)
          // Check studentName, payerName, AND payerNameRaw (original sender name)
          const studentPayments = payments.filter(p => {
            if (p.ignored) return false;

            const paymentStudentName = (p.studentName || '').toLowerCase().trim();
            const paymentPayerName = (p.payerName || '').toLowerCase().trim();
            const paymentPayerNameRaw = (p.payerNameRaw || '').toLowerCase().trim();
            const studentNameLower = (student.name || '').toLowerCase().trim();

            // Check if studentName matches
            if (paymentStudentName === studentNameLower) return true;

            // Check if payerName matches (for cases where parent pays)
            if (paymentPayerName === studentNameLower) return true;

            // Check if payerNameRaw matches (original sender name from email)
            if (paymentPayerNameRaw === studentNameLower) return true;

            // Check if payment matches any student alias
            if (student.aliases && Array.isArray(student.aliases)) {
              return student.aliases.some(alias => {
                const aliasLower = alias.toLowerCase().trim();
                return (
                  aliasLower === paymentStudentName ||
                  aliasLower === paymentPayerName ||
                  aliasLower === paymentPayerNameRaw
                );
              });
            }

            return false;
          });

          // DEBUG logs removed for performance

          // Check for payment on this date OR any recent payment that can cover this class
          // If checking a past date, allow payments from up to 7 days after the class
          const paymentOnDate = studentPayments.find(p => {
            const paymentTimestamp = p.emailDate || p.date || p.timestamp;
            if (!paymentTimestamp) return false;

            // Payment dates are already stored in LA timezone (via applyLAOffset during email processing)
            // So we just need to format them, NOT convert timezone again
            const paymentDate = new Date(paymentTimestamp);
            const paymentDateStr = formatDateYYYYMMDD(paymentDate);

            // Exact date match
            if (paymentDateStr === dateStr) return true;

            // For past classes: allow payment from up to 7 days after the class
            if (dateStr < todayStr) {
              const classDate = new Date(dateStr);
              const payDate = new Date(paymentDateStr);
              const daysDiff = Math.floor((payDate - classDate) / (1000 * 60 * 60 * 24));

              // Payment can be up to 7 days after the class date
              if (daysDiff > 0 && daysDiff <= 7) return true;
            }

            return false;
          });

          if (paymentOnDate) {
            const paymentAmount = parseFloat(paymentOnDate.amount) || 0;

            if (paymentAmount > pricePerClass) {
              const remainder = paymentAmount - pricePerClass;

              // NOTE: Balance changes must be done manually via "Apply from Credit" or payment processing
              // DO NOT modify student.balance during calendar render - it causes duplicate additions

              const result = {
                status: 'paid',
                paid: true,
                amount: paymentAmount,
                balance: balance,
                message: `Paid ${formatCurrency(paymentAmount, '$')} (${formatCurrency(remainder, '$')} overpaid)`,
              };

              // Freeze data for dates older than 2 weeks
              const twoWeeksAgo = new Date(laToday);
              twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

              if (classDate < twoWeeksAgo) {
                saveCalendarSnapshot(dateStr, {
                  [studentId]: result,
                });
              }

              return result;
            } else {
              const result = {
                status: 'paid',
                paid: true,
                amount: paymentAmount,
                balance: balance,
                message: `Paid ${formatCurrency(paymentAmount, '$')}`,
              };

              if (classDate < twoWeeksAgo) {
                saveCalendarSnapshot(dateStr, {
                  [studentId]: result,
                });
              }

              return result;
            }
          }

          // No payment found - check class timing for status

          // Future class - show as pending if has balance
          if (classDate > laToday && balance >= pricePerClass) {
            return {
              status: 'pending',
              paid: false,
              amount: 0,
              balance: balance,
              message: `Future (${formatCurrency(balance, '$')} available)`,
            };
          }

          // CRITICAL: Red dots for TODAY and PAST unpaid classes (not future)
          if (dateStr <= todayStr) {
            // Current or past unpaid - show red dot
            const result = {
              status: 'unpaid',
              paid: false,
              amount: 0,
              balance: balance,
              message: balance > 0 ? `Unpaid (${formatCurrency(balance, '$')} balance)` : 'Not Paid',
              showActions: true,
            };

            // Save snapshot for dates older than 2 weeks
            if (classDate < twoWeeksAgo) {
              saveCalendarSnapshot(dateStr, {
                [studentId]: result,
              });
            }

            return result;
          }

          // Future unpaid - no red dot, show as transparent/empty
          return {
            status: 'future',
            paid: false,
            amount: 0,
            balance: balance,
            message: 'Scheduled',
            showActions: false,
          };
        }

        function formatDateYYYYMMDD(date) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        }

        function renderCalendarGrid(calendarData) {
          const grid = document.getElementById('calendarGrid');
          if (!grid) return;

          let html = '';

          // Empty cells before first day
          for (let i = 0; i < calendarData.firstDay; i++) {
            html +=
              '<div style="min-height: 80px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.05); border-radius: 8px;"></div>';
          }

          // Day cells with dot-based view
          calendarData.days.forEach(dayData => {
            const isToday = isDateToday(dayData.date);
            const hasClasses = dayData.studentsWithClass.length > 0;
            const dateStr = formatDateYYYYMMDD(dayData.date);

            // Check if any classes are CANCELED on this day (not just skipped)
            const hasCanceledClass =
              hasClasses &&
              dayData.studentsWithClass.some(classInfo => {
                const groupName = classInfo.student.group;
                return (
                  groupName && window.SkipClassManager && window.SkipClassManager.isClassCanceled(groupName, dateStr)
                );
              });

            // Determine cell styling - GRAY OUT entire cell if class is canceled
            const cellBgColor = hasCanceledClass 
              ? 'rgba(100,100,100,0.15)' // Gray background for canceled classes
              : isToday 
                ? 'rgba(138,180,255,0.08)' 
                : 'rgba(255,255,255,0.02)';
            const cellBorderColor = hasCanceledClass
              ? 'rgba(100,100,100,0.3)' // Gray border for canceled classes
              : isToday 
                ? 'rgba(138,180,255,0.3)' 
                : 'rgba(255,255,255,0.05)';

            html += `
          <div onclick="openDayDetails('${dateStr}', ${JSON.stringify(dayData).replace(/"/g, '&quot;')})"
               style="min-height: 80px; background: ${cellBgColor};
                      border: 1px solid ${cellBorderColor};
                      border-radius: 8px; padding: 8px; display: flex; flex-direction: column;
                      cursor: ${hasClasses ? 'pointer' : 'default'};
                      transition: all 0.2s; position: relative; overflow: visible;"
               onmouseover="if(${hasClasses}){this.style.background='rgba(138,180,255,0.12)'; this.style.borderColor='rgba(138,180,255,0.4)';}"
               onmouseout="this.style.background='${cellBgColor}'; this.style.borderColor='${cellBorderColor}';">
            <div style="font-size: 14px; font-weight: 700; color: ${isToday ? '#8ab4ff' : hasCanceledClass ? 'rgba(150,150,150,0.9)' : 'white'}; margin-bottom: 8px; ${hasCanceledClass ? 'text-decoration: line-through;' : ''}">
              ${dayData.day}
              ${isToday ? '<span style="font-size: 9px; color: #8ab4ff; margin-left: 4px;">TODAY</span>' : ''}
              ${hasCanceledClass ? '<span style="font-size: 9px; color: rgba(239, 68, 68, 0.9); margin-left: 4px;">üö´ CANCELED</span>' : ''}
            </div>
            <div style="flex: 1; display: flex; flex-wrap: wrap; gap: 4px; align-content: flex-start; position: relative; overflow: visible;">
              ${hasClasses ? renderDayDots(dayData, dateStr) : ''}
            </div>
            ${
              hasClasses
                ? (() => {
                    const uniqueGroups = new Set(dayData.studentsWithClass.map(c => c.student.group || 'No Group'));
                    const groupCount = uniqueGroups.size;
                    return `<div style="font-size: 9px; color: rgba(255,255,255,0.5); margin-top: 4px; text-align: center;">${dayData.studentsWithClass.length} student${dayData.studentsWithClass.length !== 1 ? 's' : ''} ¬∑ ${groupCount} class${groupCount !== 1 ? 'es' : ''}</div>`;
                  })()
                : ''
            }
          </div>
        `;
          });

          grid.innerHTML = html;
        }

        function renderDayDots(dayData, dateStr) {
          let html = '';

          // Group students by their group name
          const studentsByGroup = {};
          dayData.studentsWithClass.forEach(classInfo => {
            const groupName = classInfo.student.group || 'No Group';
            if (!studentsByGroup[groupName]) {
              studentsByGroup[groupName] = [];
            }
            studentsByGroup[groupName].push(classInfo);
          });

          // Get sorted group names
          const groupNames = Object.keys(studentsByGroup).sort();

          groupNames.forEach((groupName, groupIndex) => {
            const studentsInGroup = studentsByGroup[groupName];

            // Render dots for each student in this group
            studentsInGroup.forEach(classInfo => {
              const { student, status } = classInfo;

              // Skip hidden status (before November 1, 2025)
              if (status === 'hidden') {
                return;
              }

              // Check if this class is skipped/canceled
              const groupNameForCheck = window.groupsCache?.find(g => g.name === student.group)?.name;
              const isSkipped =
                groupNameForCheck &&
                window.SkipClassManager &&
                window.SkipClassManager.isClassSkipped(groupNameForCheck, dateStr);

              let dotColor;

              if (isSkipped) {
                dotColor = 'rgba(150, 150, 150, 0.4)'; // Gray for skipped/canceled classes
              } else {
                switch (status) {
                  case 'paid':
                  case 'deducted':
                  case 'low-balance':
                    dotColor = '#22c55e'; // Green - Paid
                    break;
                  case 'pending':
                    dotColor = '#3b82f6'; // Blue - Future class with balance
                    break;
                  case 'absent':
                    dotColor = '#94a3b8'; // Gray - Absent
                    break;
                  case 'unpaid':
                    dotColor = '#ef4444'; // Red - Unpaid (CURRENT DAY ONLY)
                    break;
                  case 'future':
                    dotColor = 'rgba(255,255,255,0.15)'; // Very light transparent - Future unpaid
                    break;
                  default:
                    dotColor = 'rgba(255,255,255,0.15)'; // Default to transparent
                    break;
                }
              }

              const statusText = isSkipped
                ? 'Canceled'
                : status === 'paid' || status === 'deducted'
                  ? 'Paid'
                  : status === 'pending'
                    ? 'Future'
                    : status === 'future'
                      ? 'Scheduled'
                      : status === 'absent'
                        ? 'Absent'
                        : 'Unpaid';

              html += `
          <div class="calendar-dot"
               onclick="event.stopPropagation(); showStudentClassDetails('${student.id}', '${dateStr}', ${JSON.stringify(classInfo).replace(/"/g, '&quot;')});"
               data-tooltip="${escapeHtml(student.name)} ‚Äî ${statusText}"
               style="width: 8px; height: 8px; border-radius: 50%; background: ${dotColor};
                      cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"
               onmouseover="this.style.transform='scale(1.5)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.5)';"
               onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.3)';"></div>
        `;
            });

            // Add separator between groups (except after the last group)
            if (groupIndex < groupNames.length - 1) {
              html += `
          <div style="width: 100%; height: 1px; background: rgba(255,255,255,0.1); margin: 4px 0;"></div>
        `;
            }
          });

          return html;
        }

        function isDateToday(date) {
          const today = getLADate();
          return (
            date.getDate() === today.getDate() &&
            date.getMonth() === today.getMonth() &&
            date.getFullYear() === today.getFullYear()
          );
        }

        // Toggle auto-reminder pause/resume for a student (GLOBAL SCOPE)
        window.toggleAutoReminder = async function (studentId, buttonElement) {
          if (!window.PaymentReminderManager) {
            showNotification('‚ùå Payment Reminder Manager not available', 'error');
            return;
          }

          const success = await window.PaymentReminderManager.togglePause(studentId);

          if (success) {
            // Update button appearance (small orange/red icon)
            const isPaused = window.PaymentReminderManager.isPaused(studentId);
            buttonElement.style.background = isPaused ? 'rgba(239,68,68,0.2)' : 'rgba(251,146,60,0.2)';
            buttonElement.style.borderColor = isPaused ? 'rgba(239,68,68,0.4)' : 'rgba(251,146,60,0.4)';
            buttonElement.style.color = isPaused ? '#ef4444' : '#fb923c';
            buttonElement.textContent = isPaused ? '‚ñ∂' : '‚è∏';
            buttonElement.title = isPaused
              ? 'Auto-reminders paused - Click to resume'
              : 'Auto-reminders active - Click to pause';
          }
        };

        // Send payment reminder immediately (GLOBAL SCOPE)
        // CRITICAL FIX v2.10.1: ALWAYS use the exact clicked date from calendar
        // - If clicked date is not unpaid, REJECT and show error
        // - NO fallback to "most recent" or "last unpaid" dates
        // - Email date MUST match the red dot on Smart Payment Calendar
        // ==================================================================================
        // MANUAL PAYMENT REMINDER - SUPABASE RESEND ONLY
        // ==================================================================================
        // CRITICAL: This function sends UNPAID payment reminders via Supabase Resend ONLY
        // Gmail is NOT used for unpaid emails - only for payment praise and calendar summaries
        // 
        // @param {string} studentId - The student's ID
        // @param {HTMLElement} buttonElement - The button that was clicked
        // @param {string} clickedDateStr - The EXACT date (YYYY-MM-DD) that was clicked in the calendar
        window.sendReminderNow = async function (studentId, buttonElement, clickedDateStr) {
          console.log('[MANUAL][UNPAID EMAIL] ============================================');
          console.log('[MANUAL][UNPAID EMAIL] Manual payment reminder triggered');
          console.log('[MANUAL][UNPAID EMAIL] Student ID:', studentId);
          console.log('[MANUAL][UNPAID EMAIL] Clicked Date:', clickedDateStr);
          console.log('[MANUAL][UNPAID EMAIL] ============================================');

          // Store original button state for restoration
          const originalHTML = buttonElement.innerHTML;
          const originalBackground = buttonElement.style.background;
          const originalCursor = buttonElement.style.cursor;
          const originalOpacity = buttonElement.style.opacity;

          try {
            // CRITICAL: clickedDateStr is REQUIRED - never fallback
            if (!clickedDateStr || typeof clickedDateStr !== 'string' || clickedDateStr.trim() === '') {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå CRITICAL: No clickedDateStr provided');
              throw new Error('Date parameter is required for manual payment emails');
            }

            console.log('[MANUAL][UNPAID EMAIL] ‚úÖ Date validation passed:', clickedDateStr);

            // Show loading state immediately
            buttonElement.disabled = true;
            buttonElement.innerHTML = '‚è≥';
            buttonElement.style.opacity = '0.6';
            buttonElement.style.cursor = 'not-allowed';
            buttonElement.title = 'Sending...';

            // Get students from cache
            const students = getCachedStudents();
            console.log('[MANUAL][UNPAID EMAIL] Students in cache:', students?.length || 0);

            if (!students || students.length === 0) {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå No students in cache');
              throw new Error('Student data not loaded');
            }

            // Find the student
            const student = students.find(s => s.id === studentId || s.id === parseInt(studentId));
            if (!student) {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå Student not found with ID:', studentId);
              console.error('[MANUAL][UNPAID EMAIL] Available student IDs:', students.map(s => s.id).slice(0, 10));
              throw new Error('Student not found');
            }

            console.log('[MANUAL][UNPAID EMAIL] ‚úÖ Student found:', student.name);
            console.log('[MANUAL][UNPAID EMAIL] Student email:', student.email);

            // Validate student email
            if (!student.email || student.email.trim() === '') {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå Student has no email:', student.name);
              throw new Error(`${student.name} has no email address`);
            }

            // Find the EXACT unpaid class for the clicked date
            console.log('[MANUAL][UNPAID EMAIL] Searching for unpaid class on:', clickedDateStr);
            
            const currentMonth =
              window.currentCalendarData || getMonthData(new Date().getFullYear(), new Date().getMonth());

            let unpaidClassForDate = null;
            let allUnpaidClasses = [];

            // Search through all days to find unpaid classes
            currentMonth.days.forEach(dayData => {
              const dayDateStr = formatDateYYYYMMDD(dayData.date);
              
              dayData.studentsWithClass.forEach(classInfo => {
                if (classInfo.student.id === studentId || classInfo.student.id === parseInt(studentId)) {
                  if (classInfo.status === 'unpaid') {
                    allUnpaidClasses.push({
                      date: dayData.date,
                      dateStr: dayDateStr,
                      pricePerClass: classInfo.pricePerClass,
                      status: classInfo.status,
                      isClickedDate: dayDateStr === clickedDateStr,
                    });

                    // Found the exact clicked date
                    if (dayDateStr === clickedDateStr) {
                      unpaidClassForDate = {
                        date: dayData.date,
                        dateStr: dayDateStr,
                        pricePerClass: classInfo.pricePerClass,
                        status: classInfo.status,
                        isClickedDate: true,
                      };
                    }
                  }
                }
              });
            });

            console.log('[MANUAL][UNPAID EMAIL] Total unpaid classes found:', allUnpaidClasses.length);
            console.log('[MANUAL][UNPAID EMAIL] Unpaid dates:', allUnpaidClasses.map(c => c.dateStr).join(', '));

            // CRITICAL VALIDATION: The clicked date MUST be unpaid
            if (!unpaidClassForDate) {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå CRITICAL: Clicked date is NOT unpaid');
              console.error('[MANUAL][UNPAID EMAIL] Clicked date:', clickedDateStr);
              console.error('[MANUAL][UNPAID EMAIL] Available unpaid dates:', allUnpaidClasses.map(c => c.dateStr));
              throw new Error(`The selected date (${clickedDateStr}) is not unpaid. Cannot send payment reminder.`);
            }

            console.log('[MANUAL][UNPAID EMAIL] ‚úÖ Clicked date IS unpaid:', clickedDateStr);
            console.log('[MANUAL][UNPAID EMAIL] Price for this class: $' + unpaidClassForDate.pricePerClass);

            // Find email iframe
            console.log('[MANUAL][UNPAID EMAIL] Searching for email system iframe...');
            const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
            
            if (!emailFrame || !emailFrame.contentWindow) {
              console.error('[MANUAL][UNPAID EMAIL] ‚ùå Email system iframe not found');
              const allIframes = document.querySelectorAll('iframe');
              console.error('[MANUAL][UNPAID EMAIL] Total iframes on page:', allIframes.length);
              allIframes.forEach((iframe, idx) => {
                console.error(`[MANUAL][UNPAID EMAIL]   Iframe ${idx}:`, iframe.src || iframe.id || 'no src/id');
              });
              throw new Error('Email system not available');
            }

            console.log('[MANUAL][UNPAID EMAIL] ‚úÖ Email iframe found');
            console.log('[MANUAL][UNPAID EMAIL] Iframe src:', emailFrame.src);

            // Create promise for email send
            const sendPromise = new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                console.error('[MANUAL][UNPAID EMAIL] ‚ùå Timeout after 30 seconds');
                reject(new Error('Email send timeout - no response from email system'));
              }, 30000);

              const handleMessage = event => {
                if (event.data.action === 'emailSent' || event.data.action === 'emailError') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handleMessage);

                  if (event.data.action === 'emailSent') {
                    console.log('[MANUAL][UNPAID EMAIL] ‚úÖ Email sent successfully');
                    resolve(event.data);
                  } else {
                    console.error('[MANUAL][UNPAID EMAIL] ‚ùå Email error:', event.data.error);
                    reject(new Error(event.data.error || 'Email send failed'));
                  }
                }
              };

              window.addEventListener('message', handleMessage);
            });

            // Prepare payload for email system
            const payload = {
              action: 'sendAutoReminder',
              student: {
                id: student.id,
                name: student.name,
                email: student.email,
                balance: student.balance || 0,
                payPerClass: student.price_per_class || unpaidClassForDate.pricePerClass,
              },
              classDate: clickedDateStr, // EXACT date that was clicked
              unpaidClasses: allUnpaidClasses.map(c => ({
                date: c.dateStr,
                pricePerClass: c.pricePerClass,
                isClickedDate: c.isClickedDate,
              })),
              manual: true, // Bypass duplicate check
            };

            console.log('[MANUAL][UNPAID EMAIL] Sending to email system via Supabase Resend:');
            console.log('[MANUAL][UNPAID EMAIL]   Student:', student.name, '(' + student.email + ')');
            console.log('[MANUAL][UNPAID EMAIL]   Primary date:', clickedDateStr);
            console.log('[MANUAL][UNPAID EMAIL]   Total unpaid classes:', allUnpaidClasses.length);
            console.log('[MANUAL][UNPAID EMAIL]   Service: SUPABASE RESEND (not Gmail)');

            // Send via postMessage to email iframe
            emailFrame.contentWindow.postMessage(payload, '*');

            console.log('[MANUAL][UNPAID EMAIL] ‚è≥ Waiting for email system response...');

            // Wait for response
            const response = await sendPromise;

            console.log('[MANUAL][UNPAID EMAIL] ‚úÖ SUCCESS - Email sent successfully');
            console.log('[MANUAL][UNPAID EMAIL] Response:', response);

            // Show success state
            buttonElement.innerHTML = '‚úì';
            buttonElement.style.background = 'rgba(34, 197, 94, 0.3)';
            buttonElement.style.borderColor = 'rgba(34, 197, 94, 0.5)';
            buttonElement.title = 'Email sent ‚úì';

            // Show success notification
            const emailSubject = response.emailContent?.subject || 'Payment Reminder';
            const emailBody = response.emailContent?.body || '';
            
            if (window.NotificationCenter) {
              await window.NotificationCenter.add(
                window.NotificationCenter.NotificationType.EMAIL,
                `Email Sent: ${emailSubject}`,
                `Sent to ${student.name} (${student.email}) - ${allUnpaidClasses.length} unpaid class${allUnpaidClasses.length !== 1 ? 'es' : ''}`,
                {
                  studentName: student.name,
                  metadata: {
                    recipientName: student.name,
                    recipientEmail: student.email,
                    email: student.email,
                    unpaidClassCount: allUnpaidClasses.length,
                    emailType: 'payment_reminder',
                    clickedDate: clickedDateStr,
                    emailSubject: emailSubject,
                    emailBody: emailBody, // CRITICAL: Include email body for preview
                    date: new Date().toLocaleDateString(),
                  },
                }
              );
            } else {
              showNotificationSimple('‚úÖ Payment reminder sent to ' + student.name, 'success');
            }

            // Log email details if available
            if (response.emailContent) {
              console.log('[MANUAL][UNPAID EMAIL] Email details:');
              console.log('[MANUAL][UNPAID EMAIL]   Subject:', emailSubject);
              console.log('[MANUAL][UNPAID EMAIL]   Template: Payment Reminder');
              console.log('[MANUAL][UNPAID EMAIL]   Delivery: Supabase Resend Edge Function');
            }

            // Restore button after 2 seconds
            setTimeout(() => {
              buttonElement.disabled = false;
              buttonElement.innerHTML = originalHTML;
              buttonElement.style.background = originalBackground;
              buttonElement.style.opacity = originalOpacity;
              buttonElement.style.cursor = originalCursor;
              buttonElement.title = 'Send payment reminder now';
            }, 2000);

            console.log('[MANUAL][UNPAID EMAIL] ============================================');
            console.log('[MANUAL][UNPAID EMAIL] Manual send completed successfully');
            console.log('[MANUAL][UNPAID EMAIL] ============================================');
          } catch (error) {
            console.error('[MANUAL][UNPAID EMAIL] ‚ùå ERROR:', error.message);
            console.error('[MANUAL][UNPAID EMAIL] Stack:', error.stack);

            // Show error state
            buttonElement.innerHTML = '‚úó';
            buttonElement.style.background = 'rgba(239, 68, 68, 0.3)';
            buttonElement.style.borderColor = 'rgba(239, 68, 68, 0.5)';
            buttonElement.title = 'Error - Check Console';

            // Show error notification
            showNotificationSimple('‚ùå ' + error.message, 'error');

            // Restore button after 3 seconds
            setTimeout(() => {
              buttonElement.disabled = false;
              buttonElement.innerHTML = originalHTML;
              buttonElement.style.background = originalBackground;
              buttonElement.style.opacity = originalOpacity;
              buttonElement.style.cursor = originalCursor;
              buttonElement.title = 'Send payment reminder now';
            }, 3000);

            console.log('[MANUAL][UNPAID EMAIL] ============================================');
            console.log('[MANUAL][UNPAID EMAIL] Manual send failed');
            console.log('[MANUAL][UNPAID EMAIL] ============================================');
          }
        };

        // Open day details panel showing all students scheduled that day
        function openDayDetails(dateStr, dayData) {
          const dateObj = new Date(dateStr);
          const dateDisplay = dateObj.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          });

          if (!dayData.studentsWithClass || dayData.studentsWithClass.length === 0) {
            return; // No classes this day
          }

          // Calculate totals
          let totalPaid = 0;
          let totalUnpaid = 0;
          let paidCount = 0;
          let unpaidCount = 0;
          let canceledCount = 0;

          // Check for canceled classes
          const canceledGroups = [];

          dayData.studentsWithClass.forEach(classInfo => {
            const { status, pricePerClass, student } = classInfo;
            if (status === 'hidden') return;

            const groupName = student.group || 'No Group';

            // Check if this class is canceled
            if (window.SkipClassManager) {
              const skipInfo = window.SkipClassManager.getSkipInfo(groupName, dateStr);
              if (skipInfo && skipInfo.type === 'class-canceled') {
                if (!canceledGroups.includes(groupName)) {
                  canceledGroups.push(groupName);
                  canceledCount++;
                }
                return; // Don't count canceled classes in paid/unpaid totals
              }
            }

            const price = parseFloat(pricePerClass) || 0;

            if (status === 'paid' || status === 'deducted' || status === 'low-balance') {
              totalPaid += price;
              paidCount++;
            } else if (status === 'unpaid') {
              totalUnpaid += price;
              unpaidCount++;
            }
          });

          let studentsHTML = '';
          // Group students by their group name
          const studentsByGroup = {};
          dayData.studentsWithClass.forEach(classInfo => {
            const { student, status } = classInfo;

            // Skip hidden status (before November 1, 2025)
            if (status === 'hidden') return;

            const groupName = student.group || 'No Group';
            if (!studentsByGroup[groupName]) {
              studentsByGroup[groupName] = [];
            }
            studentsByGroup[groupName].push(classInfo);
          });

          // Sort groups alphabetically
          const sortedGroups = Object.keys(studentsByGroup).sort();

          // Build HTML with group sections
          sortedGroups.forEach((groupName, groupIndex) => {
            const groupStudents = studentsByGroup[groupName];

            // Group header
            studentsHTML += `
          <div style="margin-bottom: 16px; margin-top: ${groupIndex > 0 ? '24px' : '0'};">
            <div style="padding: 12px 16px; margin-bottom: 12px; background: rgba(138,180,255,0.05); border-radius: 12px; display: flex; align-items: center; justify-content: space-between;">
              <div style="font-size: 16px; font-weight: 800; color: #8ab4ff; text-transform: uppercase; letter-spacing: 1px;">
                ${groupName} <span style="color: rgba(255,255,255,0.4); font-weight: 500; font-size: 14px;">(${groupStudents.length})</span>
              </div>
              <button
                onclick="cancelGroupClassFromSidebar('${groupName}', '${dateStr}')"
                style="
                  padding: 6px 12px;
                  background: rgba(239, 68, 68, 0.15);
                  border: 1px solid rgba(239, 68, 68, 0.4);
                  border-radius: 8px;
                  color: #ef4444;
                  font-size: 11px;
                  font-weight: 700;
                  cursor: pointer;
                  transition: all 0.2s;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                "
                onmouseover="this.style.background='rgba(239,68,68,0.25)'; this.style.transform='scale(1.05)';"
                onmouseout="this.style.background='rgba(239,68,68,0.15)'; this.style.transform='scale(1)';"
                title="Cancel entire class for ${groupName}"
              >
                üö´ Cancel Class
              </button>
            </div>
        `;

            // Students in this group
            groupStudents.forEach(classInfo => {
              const { student, status, message, balance, pricePerClass } = classInfo;

              // Check if this class is canceled
              const skipInfo = window.SkipClassManager ? window.SkipClassManager.getSkipInfo(groupName, dateStr) : null;
              const isCanceled = skipInfo && skipInfo.type === 'class-canceled';

              let statusColor, statusText, statusIcon;

              // Priority: Canceled status overrides everything else
              if (isCanceled) {
                statusColor = '#94a3b8';
                statusText = 'Canceled';
                statusIcon = 'üö´';
              } else {
                switch (status) {
                  case 'paid':
                  case 'deducted':
                  case 'low-balance':
                    statusColor = '#22c55e';
                    statusText = 'Paid';
                    statusIcon = '‚úÖ';
                    break;
                  case 'pending':
                    statusColor = '#3b82f6';
                    statusText = 'Future';
                    statusIcon = 'üîµ';
                    break;
                  case 'absent':
                    statusColor = '#94a3b8';
                    statusText = 'Absent';
                    statusIcon = '‚ö™';
                    break;
                  case 'future':
                    statusColor = 'rgba(255,255,255,0.4)';
                    statusText = 'Scheduled';
                    statusIcon = 'üìÖ';
                    break;
                  case 'unpaid':
                  default:
                    statusColor = '#ef4444';
                    statusText = 'Unpaid';
                    statusIcon = '‚ùå';
                    break;
                }
              }

              studentsHTML += `
            <div style="padding: 14px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; margin-bottom: 10px; transition: all 0.2s;">
              <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;"
                   onclick="showStudentClassDetails('${student.id}', '${dateStr}', ${JSON.stringify(classInfo).replace(/"/g, '&quot;')});"
                   onmouseover="this.closest('div[style*=padding]').style.background='rgba(255,255,255,0.06)'; this.closest('div[style*=padding]').style.borderColor='rgba(138,180,255,0.3)';"
                   onmouseout="this.closest('div[style*=padding]').style.background='rgba(255,255,255,0.03)'; this.closest('div[style*=padding]').style.borderColor='rgba(255,255,255,0.08)';">
                <div style="flex: 1;">
                  <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="font-size: 15px; font-weight: 700; color: white;">${escapeHtml(student.name)}</div>
                    <button onclick="event.stopPropagation(); toggleAutoReminder('${student.id}', this);"
                            id="reminderBtn_${student.id}"
                            title="${window.PaymentReminderManager && window.PaymentReminderManager.isPaused(student.id) ? 'Auto-reminders paused - Click to resume' : 'Auto-reminders active - Click to pause'}"
                            style="width: 24px; height: 24px; padding: 0; background: ${window.PaymentReminderManager && window.PaymentReminderManager.isPaused(student.id) ? 'rgba(239,68,68,0.2)' : 'rgba(251,146,60,0.2)'};
                                   border: 1px solid ${window.PaymentReminderManager && window.PaymentReminderManager.isPaused(student.id) ? 'rgba(239,68,68,0.4)' : 'rgba(251,146,60,0.4)'};
                                   border-radius: 6px; color: ${window.PaymentReminderManager && window.PaymentReminderManager.isPaused(student.id) ? '#ef4444' : '#fb923c'};
                                   font-size: 12px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;"
                            onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 2px 8px rgba(251,146,60,0.4)';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                      ${window.PaymentReminderManager && window.PaymentReminderManager.isPaused(student.id) ? '‚ñ∂' : '‚è∏'}
                    </button>
                    <button onclick="event.stopPropagation(); sendReminderNow('${student.id}', this, '${dateStr}');"
                            title="Send payment reminder now"
                            style="width: 24px; height: 24px; padding: 0; background: rgba(34, 197, 94, 0.2);
                                   border: 1px solid rgba(34, 197, 94, 0.4);
                                   border-radius: 6px; color: #22c55e;
                                   font-size: 14px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;"
                            onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 2px 8px rgba(34,197,94,0.4)';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                      ‚Üí
                    </button>
                  </div>
                  <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 4px;">${formatCurrency(pricePerClass, '$')}/class</div>
                </div>
                <div style="display: flex; align-items: center; gap: 6px;">
                  <span style="font-size: 18px;">${statusIcon}</span>
                  <span style="font-size: 13px; font-weight: 700; color: ${statusColor};">${statusText}</span>
                </div>
              </div>
              ${balance > 0 ? `<div style="margin-top: 8px; font-size: 10px; color: #eab308;">üí∞ Balance: ${formatCurrency(balance, '$')}</div>` : ''}
              ${isCanceled && skipInfo.note ? `<div style="margin-top: 8px; padding: 8px; background: rgba(148,163,184,0.1); border-left: 3px solid #94a3b8; border-radius: 4px; font-size: 11px; color: rgba(255,255,255,0.7);">üìã Reason: ${escapeHtml(skipInfo.note)}</div>` : ''}
            </div>
          `;
            });

            studentsHTML += `</div>`; // Close group section
          });

          // Check if panel already exists
          const existingPanel = document.getElementById('dayDetailsPanel');

          if (existingPanel) {
            // Panel exists - just update the content without closing
            console.log('üìù Updating existing sidebar panel');

            // Update header
            const headerDiv = existingPanel.querySelector('[data-panel-header]');
            if (headerDiv) {
              headerDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div>
                <h3 style="margin: 0; font-size: 20px; font-weight: 900; color: white;">${dateDisplay}</h3>
                <p style="margin: 4px 0 0 0; font-size: 12px; color: #94a3b8;">${dayData.studentsWithClass.length} scheduled class${dayData.studentsWithClass.length !== 1 ? 'es' : ''}</p>
              </div>
              <button onclick="closeDayDetails()" style="width: 36px; height: 36px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; color: white; font-size: 20px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'">√ó</button>
            </div>
            <div style="display: flex; gap: 10px;">
              <div style="flex: 1; padding: 10px; background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(34,197,94,0.7); font-weight: 600; margin-bottom: 3px;">PAID</div>
                <div style="font-size: 18px; font-weight: 900; color: #22c55e;">${formatCurrency(totalPaid, '$')}</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${paidCount} payment${paidCount !== 1 ? 's' : ''}</div>
              </div>
              <div style="flex: 1; padding: 10px; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(239,68,68,0.7); font-weight: 600; margin-bottom: 3px;">UNPAID</div>
                <div style="font-size: 18px; font-weight: 900; color: #ef4444;">${formatCurrency(totalUnpaid, '$')}</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${unpaidCount} pending</div>
              </div>
              ${
                canceledCount > 0
                  ? `<div style="flex: 1; padding: 10px; background: rgba(148,163,184,0.1); border: 1px solid rgba(148,163,184,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(148,163,184,0.7); font-weight: 600; margin-bottom: 3px;">CANCELED</div>
                <div style="font-size: 18px; font-weight: 900; color: #94a3b8;">üö´</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${canceledCount} class${canceledCount !== 1 ? 'es' : ''}</div>
              </div>`
                  : ''
              }
            </div>
          `;
            }

            // Update student list
            const contentDiv = existingPanel.querySelector('[data-panel-content]');
            if (contentDiv) {
              contentDiv.innerHTML = studentsHTML;
              debugLog('‚úÖ Sidebar panel updated');
            }

            return; // Don't create a new panel
          }

          // Panel doesn't exist - create it
          console.log('üÜï Creating new sidebar panel');
          const panelHTML = `
        <div id="dayDetailsOverlay" onclick="closeDayDetails()" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 28000; backdrop-filter: blur(10px); opacity: 0; transition: opacity 0.3s;"></div>
        <div id="dayDetailsPanel" onclick="event.stopPropagation()" style="position: fixed; right: -500px; top: 0; bottom: 0; width: 450px; background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%); border-left: 2px solid rgba(138,180,255,0.3); z-index: 28001; backdrop-filter: blur(20px); box-shadow: -10px 0 40px rgba(0,0,0,0.5); transition: right 0.3s ease; overflow-y: auto;">
          <div data-panel-header style="padding: 24px; border-bottom: 1px solid rgba(255,255,255,0.1); position: sticky; top: 0; background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%); z-index: 1;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div>
                <h3 style="margin: 0; font-size: 20px; font-weight: 900; color: white;">${dateDisplay}</h3>
                <p style="margin: 4px 0 0 0; font-size: 12px; color: #94a3b8;">${dayData.studentsWithClass.length} scheduled class${dayData.studentsWithClass.length !== 1 ? 'es' : ''}</p>
              </div>
              <button onclick="closeDayDetails()" style="width: 36px; height: 36px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; color: white; font-size: 20px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'">√ó</button>
            </div>
            <div style="display: flex; gap: 10px;">
              <div style="flex: 1; padding: 10px; background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(34,197,94,0.7); font-weight: 600; margin-bottom: 3px;">PAID</div>
                <div style="font-size: 18px; font-weight: 900; color: #22c55e;">${formatCurrency(totalPaid, '$')}</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${paidCount} payment${paidCount !== 1 ? 's' : ''}</div>
              </div>
              <div style="flex: 1; padding: 10px; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(239,68,68,0.7); font-weight: 600; margin-bottom: 3px;">UNPAID</div>
                <div style="font-size: 18px; font-weight: 900; color: #ef4444;">${formatCurrency(totalUnpaid, '$')}</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${unpaidCount} pending</div>
              </div>
              ${
                canceledCount > 0
                  ? `<div style="flex: 1; padding: 10px; background: rgba(148,163,184,0.1); border: 1px solid rgba(148,163,184,0.3); border-radius: 8px;">
                <div style="font-size: 10px; color: rgba(148,163,184,0.7); font-weight: 600; margin-bottom: 3px;">CANCELED</div>
                <div style="font-size: 18px; font-weight: 900; color: #94a3b8;">üö´</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 1px;">${canceledCount} class${canceledCount !== 1 ? 'es' : ''}</div>
              </div>`
                  : ''
              }
            </div>
          </div>
          <div data-panel-content style="padding: 24px;">
            ${studentsHTML}
          </div>
        </div>
      `;

          document.body.insertAdjacentHTML('beforeend', panelHTML);

          // Animate in
          requestAnimationFrame(() => {
            document.getElementById('dayDetailsOverlay').style.opacity = '1';
            document.getElementById('dayDetailsPanel').style.right = '0';
          });
        }

        // Cancel class for a specific group from the sidebar
        function cancelGroupClassFromSidebar(groupName, dateStr) {
          console.log('[CLASS CANCELLED] Initiating cancellation:', {
            source: 'CALENDAR_SIDEBAR',
            group: groupName,
            date: dateStr,
          });

          const dateObj = new Date(dateStr);
          const dateDisplay = dateObj.toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          });

          const reason = prompt(
            `üö´ Cancel Class for ${groupName}\n\n` +
              `Date: ${dateDisplay}\n\n` +
              `This will cancel the entire class for all students in ${groupName}.\n` +
              `Payments will be forwarded to the next class.\n\n` +
              `Enter cancellation reason (optional):`
          );

          // User clicked Cancel
          if (reason === null) {
            console.log('[CLASS CANCELLED] User canceled the cancellation prompt');
            return;
          }

          // Cancel the class
          if (window.SkipClassManager && window.SkipClassManager.cancelClass) {
            const success = window.SkipClassManager.cancelClass(groupName, dateStr, reason || 'Class canceled');

            if (success) {
              console.log('[CLASS CANCELLED] ‚úÖ Successfully canceled via CALENDAR_SIDEBAR:', {
                group: groupName,
                date: dateStr,
                reason: reason || 'Class canceled',
              });
            } else {
              console.error('[CLASS CANCELLED] ‚ùå Failed to cancel class');
            }

            // Refresh the sidebar to show updated status
            const dayData = window.currentCalendarData?.days.find(d => {
              const dStr = formatDateYYYYMMDD(d.date);
              return dStr === dateStr;
            });

            if (dayData) {
              openDayDetails(dateStr, dayData);
            }

            // Refresh the calendar
            if (typeof renderCalendar === 'function') {
              renderCalendar();
            }

            showNotification(`‚úÖ Class canceled for ${groupName} on ${dateDisplay}`, 'success');
          } else {
            console.error('SkipClassManager not available');
            showNotification('‚ùå Failed to cancel class', 'error');
          }
        }

        function closeDayDetails() {
          console.log('üö™ closeDayDetails called');
          const overlay = document.getElementById('dayDetailsOverlay');
          const panel = document.getElementById('dayDetailsPanel');

          if (overlay && panel) {
            overlay.style.opacity = '0';
            panel.style.right = '-500px';

            setTimeout(() => {
              overlay.remove();
              panel.remove();
            }, 300);
          }
        }

        // Show individual student class details (when clicking a dot)
        function showStudentClassDetails(studentId, dateStr, classInfo) {
          // Don't close day details - keep it open for marking multiple absences
          // closeDayDetails();

          // Show class details modal
          showClassDetails(studentId, dateStr, classInfo);
        }

        function showClassDetails(studentId, dateStr, classInfo) {
          const student = classInfo.student;
          const dateObj = new Date(dateStr);
          const dateDisplay = dateObj.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          });

          let actionsHTML = '';

          if (classInfo.showActions && classInfo.status === 'unpaid') {
            actionsHTML = `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 12px; font-weight: 600;">Quick Actions:</div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button onclick="event.stopPropagation(); quickAddPayment('${studentId}', '${dateStr}', ${classInfo.pricePerClass})" style="padding: 8px 14px; background: rgba(34,197,94,0.2); border: 1px solid rgba(34,197,94,0.4); border-radius: 8px; color: #22c55e; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(34,197,94,0.3)'" onmouseout="this.style.background='rgba(34,197,94,0.2)'">
                ‚ûï Add Payment
              </button>
              <button onclick="event.stopPropagation(); applyFromCredit('${studentId}', '${dateStr}', ${classInfo.pricePerClass})" style="padding: 8px 14px; background: rgba(234,179,8,0.2); border: 1px solid rgba(234,179,8,0.4); border-radius: 8px; color: #eab308; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(234,179,8,0.3)'" onmouseout="this.style.background='rgba(234,179,8,0.2)'">
                üí≥ Apply from Credit
              </button>
              <button onclick="event.stopPropagation(); markAsAbsent('${studentId}', '${dateStr}')" style="padding: 8px 14px; background: rgba(100,116,139,0.2); border: 1px solid rgba(100,116,139,0.4); border-radius: 8px; color: #94a3b8; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(100,116,139,0.3)'" onmouseout="this.style.background='rgba(100,116,139,0.2)'">
                ‚ö™ Mark Absent
              </button>
            </div>
          </div>
        `;
          }

          if (classInfo.status === 'absent') {
            actionsHTML = `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
            <button onclick="event.stopPropagation(); unmarkAbsent('${studentId}', '${dateStr}')" style="padding: 8px 14px; background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.4); border-radius: 8px; color: #ef4444; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.3)'" onmouseout="this.style.background='rgba(239,68,68,0.2)'">
              ‚Ü©Ô∏è Unmark Absent
            </button>
          </div>
        `;
          }

          const balanceInfo =
            classInfo.balance > 0
              ? `
        <div style="margin-top: 12px; padding: 12px; background: rgba(234,179,8,0.1); border: 1px solid rgba(234,179,8,0.3); border-radius: 8px;">
          <div style="font-size: 11px; color: #eab308; font-weight: 700; margin-bottom: 4px;">BALANCE</div>
          <div style="font-size: 18px; color: white; font-weight: 900;">${formatCurrency(classInfo.balance, '$')}</div>
          <div style="font-size: 10px; color: rgba(255,255,255,0.6); margin-top: 4px;">‚âà ${Math.floor(classInfo.balance / classInfo.pricePerClass)} class${Math.floor(classInfo.balance / classInfo.pricePerClass) !== 1 ? 'es' : ''} remaining</div>
        </div>
      `
              : '';

          const detailHTML = `
        <div id="classDetailModal" onclick="event.stopPropagation()" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 28000; background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%); border: 2px solid rgba(138,180,255,0.3); border-radius: 16px; padding: 24px; min-width: 400px; max-width: 500px; backdrop-filter: blur(20px); box-shadow: 0 20px 60px rgba(0,0,0,0.7);">
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
            <div>
              <h3 style="margin: 0 0 4px 0; font-size: 20px; font-weight: 900; color: white;">${escapeHtml(student.name)}</h3>
              <p style="margin: 0; font-size: 12px; color: #94a3b8;">Group ${escapeHtml(student.group || 'N/A')}</p>
            </div>
            <button onclick="document.getElementById('classDetailModal').remove(); document.getElementById('calendarDetailOverlay').remove();" style="width: 32px; height: 32px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;">√ó</button>
          </div>

          <div style="padding: 12px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; margin-bottom: 16px;">
            <div style="font-size: 11px; color: #8ab4ff; font-weight: 700; margin-bottom: 6px;">CLASS DATE</div>
            <div style="font-size: 14px; color: white; font-weight: 700;">${dateDisplay}</div>
          </div>

          <div style="padding: 12px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; margin-bottom: 16px;">
            <div style="font-size: 11px; color: #8ab4ff; font-weight: 700; margin-bottom: 6px;">STATUS</div>
            <div style="font-size: 14px; color: white; font-weight: 700;">${classInfo.message}</div>
          </div>

          <div style="padding: 12px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px;">
            <div style="font-size: 11px; color: #8ab4ff; font-weight: 700; margin-bottom: 6px;">PRICE PER CLASS</div>
            <div style="font-size: 14px; color: white; font-weight: 700;">${formatCurrency(classInfo.pricePerClass, '$')}</div>
          </div>

          ${balanceInfo}
          ${actionsHTML}
        </div>
      `;

          // Add overlay
          const overlay = document.createElement('div');
          overlay.id = 'calendarDetailOverlay';
          overlay.style.cssText =
            'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 27500; backdrop-filter: blur(4px);';
          overlay.onclick = function () {
            this.remove();
            const modal = document.getElementById('classDetailModal');
            if (modal) modal.remove();
          };

          document.body.insertAdjacentHTML('beforeend', detailHTML);
          document.body.appendChild(overlay);
        }

        async function quickAddPayment(studentId, dateStr, amount) {
          // Close detail popup
          const overlay = document.getElementById('calendarDetailOverlay');
          if (overlay) overlay.click();

          // Open main payment modal or create quick payment
          const confirmed = confirm(`Add payment of ${formatCurrency(amount, '$')} for this class?`);
          if (!confirmed) return;

          const students = getCachedStudents();
          const student = students.find(s => s.id === studentId);
          if (!student) {
            showToast('‚ùå Student not found', 'error');
            return;
          }

          // CRITICAL FIX: Use addPayment() to trigger receipt email automatically
          const paymentData = {
            payer_name: student.name,
            amount: amount,
            payment_date: dateStr,
            note: 'Added from Calendar Quick Payment',
            ignored: false,
            source: 'calendar_quick',
            derivedStudentId: studentId,
            matched_student_id: studentId,
          };

          try {
            console.log('üí≥ Creating quick payment via addPayment()...');
            const result = await addPayment(paymentData);

            if (result) {
              showToast('‚úÖ Payment added & receipt sent!', 'success');
              renderCalendar();

              // Reload payments to update UI
              await window.PaymentStore.load();
            } else {
              showToast('‚ùå Failed to add payment', 'error');
            }
          } catch (error) {
            console.error('‚ùå Quick payment error:', error);
            showToast('‚ùå Payment failed: ' + error.message, 'error');
          }
        }

        async function applyFromCredit(studentId, dateStr, pricePerClass) {
          // Convert to number for consistency
          const numericId = parseInt(studentId);

          // Get student from cache
          const students = getCachedStudents();
          const student = students.find(s => s.id === numericId);

          if (!student) {
            showToast('‚ùå Student not found', 'error');
            return;
          }

          const currentBalance = parseFloat(student.balance) || 0;

          // Check if student has enough credit
          if (currentBalance < pricePerClass) {
            alert(
              `‚ùå Insufficient credit!\n\nStudent: ${student.name}\nCurrent Balance: ${formatCurrency(currentBalance, '$')}\nClass Price: ${formatCurrency(pricePerClass, '$')}\n\nNeed ${formatCurrency(pricePerClass - currentBalance, '$')} more.`
            );
            return;
          }

          // Confirm deduction
          const confirmMsg = `Apply credit to this class?\n\nStudent: ${student.name}\nClass Date: ${dateStr}\nClass Price: ${formatCurrency(pricePerClass, '$')}\n\nCurrent Balance: ${formatCurrency(currentBalance, '$')}\nNew Balance: ${formatCurrency(currentBalance - pricePerClass, '$')}`;

          if (!confirm(confirmMsg)) return;

          // Deduct from balance
          const newBalance = currentBalance - pricePerClass;
          student.balance = newBalance;

          // Save to Supabase
          try {
            await saveStudent(student);

            // Store credit payment using CreditPaymentManager for cloud sync
            if (window.CreditPaymentManager) {
              await window.CreditPaymentManager.applyCreditPayment(numericId, dateStr, pricePerClass, newBalance);
              debugLog('Applied credit payment (Supabase):', { studentId: numericId, dateStr, amount: pricePerClass });
            } else {
              // Fallback to localStorage
              const creditPaymentKey = `credit-payment:${numericId}:${dateStr}`;
              localStorage.setItem(
                creditPaymentKey,
                JSON.stringify({
                  amount: pricePerClass,
                  balance: newBalance,
                })
              );
              debugLog('Applied credit payment (localStorage fallback):', {
                studentId: numericId,
                dateStr,
                amount: pricePerClass,
              });
            }

            // Send credit applied email notification
            if (student.email) {
              verboseLog('[Credit] üìß Sending credit applied email...');
              const emailResult = await sendCreditAppliedEmail(student, dateStr, pricePerClass, newBalance);

              if (emailResult.success) {
                showToast(
                  `‚úÖ Applied ${formatCurrency(pricePerClass, '$')} from credit\nNew Balance: ${formatCurrency(newBalance, '$')}`,
                  'success'
                );
                showNotification(`üìß Email sent to ${student.email}`, 'success');
                verboseLog('[Credit] ‚úÖ Email sent successfully');
              } else {
                showToast(
                  `‚úÖ Applied ${formatCurrency(pricePerClass, '$')} from credit\nNew Balance: ${formatCurrency(newBalance, '$')}`,
                  'success'
                );
                showNotification(`‚ö†Ô∏è Credit applied but email failed: ${emailResult.error}`, 'warning');
                console.error('[Credit] ‚ùå Email failed:', emailResult.error);
              }
            } else {
              showToast(
                `‚úÖ Applied ${formatCurrency(pricePerClass, '$')} from credit\nNew Balance: ${formatCurrency(newBalance, '$')}`,
                'success'
              );
            }

            debugLog('üîç Checking for panels to close after credit apply...');

            // Close the detail modal only (not the sidebar)
            const modal = document.getElementById('classDetailModal');
            if (modal) {
              console.log('‚ùå Closing classDetailModal');
              modal.remove();
            }
            const overlay = document.getElementById('calendarDetailOverlay');
            if (overlay) {
              console.log('‚ùå Closing calendarDetailOverlay');
              overlay.remove();
            }

            debugLog('üîÑ Calling renderCalendar after credit apply...');
            // Refresh calendar to update dot colors
            renderCalendar();

            debugLog('üìã Checking for sidebar panel after credit apply...');
            // Update the day details sidebar immediately if it's open
            const dayPanel = document.getElementById('dayDetailsPanel');
            if (dayPanel) {
              debugLog('‚úÖ Sidebar panel found, updating after credit apply...');
              // Re-fetch the day data with updated status and update content
              const dayData = getDayData(dateStr);
              if (dayData) {
                openDayDetails(dateStr, dayData);
              }
            } else {
              debugLog('‚ö†Ô∏è No sidebar panel found after credit apply');
            }
          } catch (error) {
            console.error('Failed to apply credit:', error);
            showToast('‚ùå Failed to apply credit', 'error');
          }
        }

        function markAsAbsent(studentId, dateStr) {
          // Convert to number for consistency
          const numericId = parseInt(studentId);

          // Use AbsentManager for cloud sync
          if (window.AbsentManager) {
            window.AbsentManager.markAbsent(numericId, dateStr)
              .then(() => {
                debugLog('Marked absent (Supabase):', { studentId: numericId, dateStr });
                showToast('‚ö™ Marked as absent');

                // Close the detail modal only (not the sidebar)
                const modal = document.getElementById('classDetailModal');
                if (modal) {
                  modal.remove();
                }
                const overlay = document.getElementById('calendarDetailOverlay');
                if (overlay) {
                  overlay.remove();
                }

                // Refresh calendar to update dot colors
                renderCalendar();

                // Update the day details sidebar immediately if it's open
                const dayPanel = document.getElementById('dayDetailsPanel');
                if (dayPanel) {
                  // Re-fetch the day data with updated status and update content
                  const dayData = getDayData(dateStr);
                  if (dayData) {
                    openDayDetails(dateStr, dayData);
                  }
                }
              })
              .catch(err => {
                console.error('Error marking absent:', err);
                showToast('‚ùå Error marking absent');
              });
          } else {
            // Fallback to localStorage
            const absentKey = `absent:${numericId}:${dateStr}`;
            localStorage.setItem(absentKey, 'true');
            debugLog('Marked absent (localStorage fallback):', { studentId: numericId, dateStr, key: absentKey });
            showToast('‚ö™ Marked as absent');
            renderCalendar();

            // Update sidebar if open
            const dayPanel = document.getElementById('dayDetailsPanel');
            if (dayPanel) {
              const dayData = getDayData(dateStr);
              if (dayData) {
                openDayDetails(dateStr, dayData);
              }
            }
          }
        }

        function unmarkAbsent(studentId, dateStr) {
          // Convert to number for consistency
          const numericId = parseInt(studentId);

          const absentKey = `absent:${numericId}:${dateStr}`;
          localStorage.removeItem(absentKey);

          showToast('‚Ü©Ô∏è Unmarked absent');

          // Close the detail modal only
          const modal = document.getElementById('classDetailModal');
          if (modal) modal.remove();
          const overlay = document.getElementById('calendarDetailOverlay');
          if (overlay) overlay.remove();

          // Refresh calendar to update dot colors
          renderCalendar();

          // Update the day details sidebar if it's open
          const dayPanel = document.getElementById('dayDetailsPanel');
          if (dayPanel) {
            // Re-fetch the day data with updated status
            const dateObj = new Date(dateStr);
            const dayData = getDayData(dateStr);
            if (dayData) {
              // Close and reopen the day panel with updated data
              closeDayDetails();
              setTimeout(() => {
                openDayDetails(dateStr, dayData);
              }, 100);
            }
          }
        }

        // Listen for payment/student updates to refresh calendar
        window.addEventListener('payments:updated', () => {
          if (document.getElementById('smartCalendarModal').style.display !== 'none') {
            renderCalendar();
          }
        });

        window.addEventListener('students:updated', () => {
          if (document.getElementById('smartCalendarModal').style.display !== 'none') {
            renderCalendar();
          }
        });

        window.addEventListener('groups:updated', () => {
          if (document.getElementById('smartCalendarModal').style.display !== 'none') {
            renderCalendar();
          }
        });

        window.addEventListener('schedules:updated', () => {
          if (document.getElementById('smartCalendarModal').style.display !== 'none') {
            renderCalendar();
          }
        });

        // ============================================================================
        // END SMART CALENDAR PAYMENT SYSTEM
        // ============================================================================

        // ============================================================================
        // END EARNING FORECAST SYSTEM
        // ============================================================================

        // ============================================================================
        // PAYMENT REMINDER MANAGER - Auto-send reminders for unpaid classes ‚òÅÔ∏è CLOUD SYNC
        // ============================================================================
        /**
         * Payment Reminder Manager
         * - Detects red dots (unpaid classes) daily
         * - Calculates class end time (start + 2 hours)
         * - Sends payment reminders ONLY after class ends
         * - Tracks sent reminders to prevent duplicates
         * - Manual pause/resume per student
         * - Stops when red dot resolves (paid/absent)
         */
        window.PaymentReminderManager = (function () {
          let pausedStudents = {}; // {studentId: true/false}
          let sentReminders = {}; // {studentId: {date: timestamp}}
          let lastCheckDate = null;

          // Load paused students from Supabase
          async function loadPausedFromSupabase() {
            try {
              const { data, error } = await supabase.from('auto_reminder_paused').select('*');

              if (error) {
                console.error('[PaymentReminderManager] ‚ùå Error loading paused students:', error);
                return;
              }

              pausedStudents = {};
              if (data && data.length > 0) {
                data.forEach(row => {
                  pausedStudents[row.student_id] = row.paused;
                });
              }

              // debugLog('‚úÖ [PaymentReminderManager] Loaded', Object.keys(pausedStudents).length, 'paused states from Supabase');
            } catch (error) {
              console.error('[PaymentReminderManager] ‚ùå Exception loading paused students:', error);
            }
          }

          // Save paused state to Supabase
          async function savePausedToSupabase(studentId, paused) {
            try {
              const { error } = await supabase.from('auto_reminder_paused').upsert(
                {
                  student_id: studentId,
                  paused: paused,
                  updated_at: new Date().toISOString(),
                },
                {
                  onConflict: 'student_id',
                }
              );

              if (error) {
                console.error('[PaymentReminderManager] ‚ùå Error saving paused state:', error);
                return false;
              }

              pausedStudents[studentId] = paused;
              debugLog('‚úÖ [PaymentReminderManager] Saved paused state for student:', studentId, paused);
              return true;
            } catch (error) {
              console.error('[PaymentReminderManager] ‚ùå Exception saving paused state:', error);
              return false;
            }
          }

          // Check if student is paused
          function isPaused(studentId) {
            return pausedStudents[studentId] === true;
          }

          // Toggle pause state
          async function togglePause(studentId) {
            const currentState = isPaused(studentId);
            const newState = !currentState;
            const success = await savePausedToSupabase(studentId, newState);
            if (success) {
              showNotification(
                newState ? '‚è∏Ô∏è Auto-reminders paused for this student' : '‚ñ∂Ô∏è Auto-reminders resumed for this student',
                'success'
              );
            }
            return success;
          }

          // Get class end time (start time + 2 hours) - FORCED LA TIMEZONE
          function getClassEndTime(groupName, dateStr) {
            try {
              // Find the group
              const group = groups.find(g => g.name === groupName);
              if (!group || !group.schedule) {
                console.warn('[PaymentReminderManager] No schedule found for group:', groupName);
                return null;
              }

              // Parse schedule to get class time for this date
              // CRITICAL: Use LA timezone for date parsing
              const classDate = new Date(dateStr + 'T00:00:00-08:00'); // Force PST/PDT
              const laDateStr = classDate.toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
                weekday: 'long',
              });
              const dayName = laDateStr.split(',')[0]; // Get day name in LA timezone

              const scheduleSlots = parseSchedule(group.schedule);
              const todaySlot = scheduleSlots.find(slot => slot.day === dayName);

              if (!todaySlot) {
                console.warn('[PaymentReminderManager] No class scheduled for', dayName, 'in group:', groupName);
                return null;
              }

              // Parse time (e.g., "8:00 PM" -> 20:00)
              const timeParts = todaySlot.time.match(/(\d+):(\d+)\s*(AM|PM)/i);
              if (!timeParts) {
                console.warn('[PaymentReminderManager] Invalid time format:', todaySlot.time);
                return null;
              }

              let hours = parseInt(timeParts[1]);
              const minutes = parseInt(timeParts[2]);
              const period = timeParts[3].toUpperCase();

              // Convert to 24-hour format
              if (period === 'PM' && hours !== 12) hours += 12;
              if (period === 'AM' && hours === 12) hours = 0;

              // CRITICAL: Create start time in LA timezone
              // Parse the dateStr as LA date and set the hours/minutes
              const [year, month, day] = dateStr.split('-').map(Number);

              // Create date string in ISO format for LA timezone
              const laDateTimeStr = `${dateStr}T${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`;

              // Create Date object and force interpretation as LA time
              const startTime = new Date(laDateTimeStr);

              // Convert to LA timezone explicitly using Intl API
              const laStartTime = new Date(
                startTime.toLocaleString('en-US', {
                  timeZone: 'America/Los_Angeles',
                })
              );

              // Add 2 hours for end time
              const endTime = new Date(laStartTime.getTime() + 2 * 60 * 60 * 1000);

              console.log(
                `[PaymentReminderManager] üïê Class end time for ${groupName} on ${dateStr}: ${endTime.toLocaleString('en-US', { timeZone: 'America/Los_Angeles', hour: '2-digit', minute: '2-digit', hour12: true })}`
              );

              return endTime;
            } catch (error) {
              console.error('[PaymentReminderManager] Error calculating class end time:', error);
              return null;
            }
          }

          // Check if reminder was already sent today - FORCED LA TIMEZONE
          function wasReminderSentToday(studentId, dateStr) {
            if (!sentReminders[studentId]) return false;
            if (!sentReminders[studentId][dateStr]) return false;

            const sentTime = sentReminders[studentId][dateStr];

            // CRITICAL: Use LA timezone for current time
            const nowLA = getLADate();
            const nowMs = nowLA.getTime();
            const oneDayMs = 24 * 60 * 60 * 1000;

            // Check if less than 24 hours have passed
            return nowMs - sentTime < oneDayMs;
          }

          // Mark reminder as sent - FORCED LA TIMEZONE
          function markReminderSent(studentId, dateStr) {
            if (!sentReminders[studentId]) {
              sentReminders[studentId] = {};
            }

            // CRITICAL: Use LA timezone for timestamp
            const nowLA = getLADate();
            sentReminders[studentId][dateStr] = nowLA.getTime();

            // Save to localStorage for persistence
            try {
              localStorage.setItem('paymentReminders_sent', JSON.stringify(sentReminders));
            } catch (error) {
              console.error('[PaymentReminderManager] Error saving sent reminders:', error);
            }
          }

          // Load sent reminders from localStorage
          function loadSentReminders() {
            try {
              const stored = localStorage.getItem('paymentReminders_sent');
              if (stored) {
                sentReminders = JSON.parse(stored);
              }
            } catch (error) {
              console.error('[PaymentReminderManager] Error loading sent reminders:', error);
              sentReminders = {};
            }
          }

          // Send payment reminder via email system
          async function sendPaymentReminder(student, dateStr, amount, unpaidClassesList = []) {
            try {
              // Call the email system iframe to send payment reminder
              const emailFrame = document.querySelector('iframe[src*="email-system-complete.html"]');
              if (!emailFrame) {
                console.error('[PaymentReminderManager] Email system iframe not found');
                return false;
              }

              // Send message to email system with full unpaid classes list
              emailFrame.contentWindow.postMessage(
                {
                  action: 'sendAutoReminder',
                  student: {
                    name: student.name,
                    email: student.email,
                    balance: amount, // Keep for backwards compatibility, but email will use unpaidClasses
                    payPerClass: student.payPerClass || amount, // Include student's rate per class
                  },
                  classDate: dateStr,
                  unpaidClasses: unpaidClassesList.map(c => ({
                    date: c.date,
                    pricePerClass: parseFloat(c.balance || student.payPerClass || amount || 0),
                    isClickedDate: c.date === dateStr,
                  })),
                },
                '*'
              );

              console.log(
                'üìß [PaymentReminderManager] Sent auto-reminder for:',
                student.name,
                'Date:',
                dateStr,
                'Amount:',
                amount
              );

              // Notification will be created when we receive the email content back from iframe

              return true;
            } catch (error) {
              console.error('[PaymentReminderManager] Error sending reminder:', error);
              return false;
            }
          }

          // Main function: Check and send reminders
          async function checkAndSendReminders() {
            try {
              // Check if automation is paused
              if (localStorage.getItem('automation_system_payment_reminder_paused') === 'true') {
                console.log('[PaymentReminderManager] ‚è∏Ô∏è PAUSED - Skipping reminder check');
                return;
              }

              const today = getLADate();
              const todayStr = formatDateYYYYMMDD(today);

              // Update last check time
              localStorage.setItem('payment_reminder_last_check', new Date().toISOString());

              debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              debugLog('[PaymentReminderManager] üîç STARTING DAILY REMINDER CHECK');
              debugLog('[PaymentReminderManager] üìÖ LA Date:', todayStr);
              console.log(
                '[PaymentReminderManager] üïê LA Time:',
                today.toLocaleString('en-US', {
                  timeZone: 'America/Los_Angeles',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: true,
                })
              );

              // Only check once per day (but only if calendar data is available)
              if (lastCheckDate === todayStr) {
                debugLog('[PaymentReminderManager] ‚è≠Ô∏è  Already checked today - skipping');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                return;
              }

              // IMPORTANT: Wait for calendar data to be available
              if (!window.currentCalendarData) {
                debugLog('[PaymentReminderManager] ‚è≥ Calendar not initialized yet');

                // Try to render calendar now if function exists
                if (typeof renderCalendar === 'function') {
                  debugLog('[PaymentReminderManager] ÔøΩ Manually rendering calendar...');
                  renderCalendar();
                  debugLog('[PaymentReminderManager] ‚úÖ Calendar rendered!');
                } else {
                  debugLog('[PaymentReminderManager] ‚ùå renderCalendar function not available');
                  debugLog('[PaymentReminderManager] üîÑ Will retry on next interval');
                  debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                  return;
                }

                // Check again after render
                if (!window.currentCalendarData) {
                  debugLog('[PaymentReminderManager] ‚ùå Calendar still not initialized after render attempt');
                  debugLog('[PaymentReminderManager] üîÑ Will retry on next interval');
                  debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                  return;
                }
              }

              // Mark as checked ONLY after confirming calendar data exists
              lastCheckDate = todayStr;

              const calendarData = window.currentCalendarData;
              if (!calendarData || !calendarData.days) {
                console.warn('[PaymentReminderManager] ‚ùå No calendar data available');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                return;
              }

              // Build student attendance map from calendar days structure
              const studentAttendanceMap = {};

              calendarData.days.forEach(dayData => {
                const dateStr = formatDateYYYYMMDD(dayData.date);

                dayData.studentsWithClass.forEach(classData => {
                  const student = classData.student;
                  const studentId = student.id;

                  if (!studentAttendanceMap[studentId]) {
                    studentAttendanceMap[studentId] = {
                      student: student,
                      attendance: [],
                    };
                  }

                  studentAttendanceMap[studentId].attendance.push({
                    date: dateStr,
                    status: classData.status,
                    balance: classData.balance || classData.pricePerClass || 0,
                  });
                });
              });

              const studentsArray = Object.values(studentAttendanceMap);
              debugLog('[PaymentReminderManager] üìä Checking', studentsArray.length, 'students for unpaid classes');

              let remindersSent = 0;
              let studentsChecked = 0;
              let studentsPaused = 0;
              let studentsNoUnpaid = 0;
              let studentsClassNotEnded = 0;
              let studentsAlreadySent = 0;
              let studentsPaid = 0;
              let classesChecked = 0;

              // CRITICAL FIX: Check ALL past unpaid classes, not just today
              // Check each student
              for (const studentData of studentsArray) {
                const student = studentData.student;
                const studentId = student.id;
                studentsChecked++;

                verboseLog(`\n[Student ${studentsChecked}/${studentsArray.length}] ${student.name}`);

                // ONLY send payment reminders to students with 'paused' status (red dont)
                if (student.status !== 'paused') {
                  debugLog(`  ‚è≠Ô∏è  Student status is '${student.status}' (not paused) - skipping payment reminder`);
                  studentsPaused++;
                  continue;
                }

                // Skip if manually paused via automation controls
                if (isPaused(studentId)) {
                  debugLog('  ‚è∏Ô∏è  Auto-reminders PAUSED for this student - skipping');
                  studentsPaused++;
                  continue;
                }

                // CRITICAL FIX: Find ALL unpaid classes (past and today), not just today
                // But exclude classes before student was added to the system
                const studentCreatedAt = student.created_at ? new Date(student.created_at) : null;
                let studentCreationDateStr = null;
                if (studentCreatedAt) {
                  studentCreatedAt.setHours(0, 0, 0, 0);
                  const year = studentCreatedAt.getFullYear();
                  const month = String(studentCreatedAt.getMonth() + 1).padStart(2, '0');
                  const day = String(studentCreatedAt.getDate()).padStart(2, '0');
                  studentCreationDateStr = `${year}-${month}-${day}`;
                }

                const unpaidClasses = studentData.attendance.filter(a => {
                  // Only unpaid classes
                  if (a.status !== 'unpaid') return false;

                  // Only classes on or before today (no future reminders)
                  if (a.date > todayStr) return false;

                  // CRITICAL: Exclude classes before student was added to system
                  if (studentCreationDateStr && a.date < studentCreationDateStr) {
                    return false;
                  }

                  return true;
                });

                // DEBUG: Log details for specific student (Mariam Gevorgyan)
                if (student.name.toLowerCase().includes('mariam') && student.name.toLowerCase().includes('gevorgyan')) {
                  debugLog('\nüîç DEBUG: Mariam Gevorgyan Details:');
                  debugLog('  Student ID:', studentId);
                  debugLog('  Student Status:', student.status);
                  debugLog('  Student Created At:', studentCreationDateStr);
                  debugLog('  Total Attendance Records:', studentData.attendance.length);
                  debugLog('  Unpaid Classes Found:', unpaidClasses.length);

                  if (unpaidClasses.length > 0) {
                    debugLog('  Unpaid Classes:');
                    unpaidClasses.forEach(c => {
                      debugLog(`    - Date: ${c.date}, Balance: $${c.balance}, Status: ${c.status}`);
                    });

                    debugLog('\n  All Attendance Records (for verification):');
                    studentData.attendance.forEach(a => {
                      debugLog(`    - Date: ${a.date}, Status: ${a.status}, Balance: $${a.balance || 0}`);
                    });
                  }
                }

                if (unpaidClasses.length === 0) {
                  debugLog('  ‚úÖ No unpaid classes (past or present) - skipping');
                  studentsNoUnpaid++;
                  continue;
                }

                debugLog(`  ÔøΩ Found ${unpaidClasses.length} unpaid class(es) - checking each...`);

                // Check each unpaid class
                for (const unpaidClass of unpaidClasses) {
                  classesChecked++;
                  const dateStr = unpaidClass.date;

                  console.log(
                    `\n  üìÖ Class Date: ${dateStr} | Status: ${unpaidClass.status} | Balance: $${unpaidClass.balance}`
                  );

                  // Skip if reminder already sent for this date
                  if (wasReminderSentToday(studentId, dateStr)) {
                    debugLog('    ‚úÖ Reminder already sent for this date - skipping');
                    studentsAlreadySent++;
                    continue;
                  }

                  // Check if we're within 30 minutes before class end (payment reminder window)
                  const classEndTime = getClassEndTime(student.group, dateStr);
                  if (!classEndTime) {
                    console.warn('    ‚ùå Could not determine class end time - skipping');
                    continue;
                  }

                  // CRITICAL: Send reminder when there's 30 minutes left in class
                  const thirtyMinutesBeforeEnd = new Date(classEndTime.getTime() - 30 * 60 * 1000);

                  // CRITICAL: Use LA timezone for current time comparison
                  const nowLA = getLADate();
                  const nowLAStr = nowLA.toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true,
                  });

                  const classEndStr = classEndTime.toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true,
                  });

                  const reminderWindowStr = thirtyMinutesBeforeEnd.toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true,
                  });

                  // Only send if current time is past the 30-minute reminder window
                  if (nowLA < thirtyMinutesBeforeEnd) {
                    console.log(
                      `    ‚è∞ Too early for reminder | Current: ${nowLAStr} | Reminder at: ${reminderWindowStr} (30 min before ${classEndStr}) - skipping`
                    );
                    studentsClassNotEnded++;
                    continue;
                  }

                  debugLog(
                    `    ‚úÖ REMINDER WINDOW ACTIVE | Current: ${nowLAStr} | Window started: ${reminderWindowStr} | Class ends: ${classEndStr}`
                  );

                  // All checks passed - send reminder with full unpaid classes list
                  // FIX: Use student's payPerClass rate, not cumulative balance
                  const amount = student.payPerClass || 50;
                  console.log(`    üìß Sending payment reminder for ${unpaidClasses.length} unpaid class(es)`);

                  const sent = await sendPaymentReminder(student, dateStr, amount, unpaidClasses);

                  if (sent) {
                    markReminderSent(studentId, dateStr);
                    remindersSent++;
                    console.log(`    ‚úÖ Reminder SENT successfully`);
                  } else {
                    console.log(`    ‚ùå Failed to send reminder`);
                  }
                }
              }

              console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              console.log('[PaymentReminderManager] üìä SUMMARY');
              console.log('  Total students checked:', studentsChecked);
              console.log('  Students with paused reminders:', studentsPaused);
              console.log('  Students with no unpaid classes:', studentsNoUnpaid);
              console.log('  Total unpaid classes found:', classesChecked);
              console.log('  Classes not ended yet:', studentsClassNotEnded);
              console.log('  Classes with reminder already sent:', studentsAlreadySent);
              console.log('  Reminders sent:', remindersSent);

              if (remindersSent > 0) {
                debugLog('‚úÖ [PaymentReminderManager] Successfully sent', remindersSent, 'auto-reminder(s)');
              } else {
                debugLog('‚úÖ [PaymentReminderManager] No reminders needed today');
              }
              debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            } catch (error) {
              console.error('[PaymentReminderManager] ‚ùå ERROR in checkAndSendReminders:', error);
              console.error('Stack trace:', error.stack);
            }
          }

          // Initialize
          async function initialize() {
            await loadPausedFromSupabase();
            loadSentReminders();

            debugLog('[PaymentReminderManager] üöÄ Automation engine initialized');
            debugLog('[PaymentReminderManager] üìÖ Using LA Timezone for ALL date/time calculations');

            // Listen for email content messages from iframe
            window.addEventListener('message', async event => {
              debugLog('[PaymentReminderManager] Received message:', event.data);

              if (event.data.action === 'autoReminderSent' && event.data.success) {
                const { student, classDate, emailContent } = event.data;

                debugLog('[PaymentReminderManager] ‚úÖ Auto-reminder sent successfully!');
                debugLog('[PaymentReminderManager] Student:', student.name);
                debugLog('[PaymentReminderManager] Email content received:', !!emailContent);
                debugLog('[PaymentReminderManager] Email subject:', emailContent?.subject);

                // Update the notification with email content
                if (window.NotificationCenter && emailContent) {
                  debugLog('[PaymentReminderManager] Creating notification with email content...');
                  const emailSubject = emailContent.subject || 'Payment Reminder';
                  await window.NotificationCenter.add(
                    window.NotificationCenter.NotificationType.REMINDER,
                    `Auto Email Sent: ${emailSubject}`,
                    `Sent to ${student.name} (${student.email}) - unpaid class on ${classDate}`,
                    {
                      studentName: student.name,
                      metadata: {
                        amount: student.balance,
                        date: classDate,
                        email: student.email,
                        emailSubject: emailSubject,
                        emailBody: emailContent.body,
                      },
                    }
                  );
                  debugLog('[PaymentReminderManager] ‚úÖ Notification created with email content');
                }
              }
            });

            // Listen for calendar initialization event
            window.addEventListener('calendar:initialized', () => {
              debugLog('[PaymentReminderManager] üìä Calendar initialized - scheduling first check in 5 seconds...');
              setTimeout(() => {
                debugLog('[PaymentReminderManager] üîÑ Running first automated reminder check...');
                checkAndSendReminders();
              }, 5000);
            });

            // Fallback: If calendar is already initialized, check after delay
            if (window.currentCalendarData) {
              console.log(
                '[PaymentReminderManager] üìä Calendar already initialized - scheduling check in 5 seconds...'
              );
              setTimeout(() => {
                debugLog('[PaymentReminderManager] üîÑ Running first automated reminder check...');
                checkAndSendReminders();
              }, 5000);
            }

            // Run checks every hour
            debugLog('[PaymentReminderManager] ‚è∞ Scheduling hourly checks (every 60 minutes)');
            setInterval(
              () => {
                debugLog('[PaymentReminderManager] üîÑ Running hourly automated check...');
                checkAndSendReminders();
              },
              60 * 60 * 1000
            );
          }

          // Public API
          return {
            initialize,
            togglePause,
            isPaused,
            checkAndSendReminders,
            reloadFromSupabase: loadPausedFromSupabase,
          };
        })();

        // ============================================================================
        // CLASS REMINDER MANAGER
        // Automatically sends class reminders 12 hours before class time
        // "tomorrow" for morning classes (sent night before)
        // "today" for evening classes (sent morning of same day)
        // ============================================================================
        window.ClassReminderManager = (function () {
          let sentClassReminders = {}; // {studentId: {date: timestamp}}
          let lastCheckDate = null;

          // LA timezone helpers
          function getLADate() {
            return new Date(
              new Date().toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
              })
            );
          }

          function formatDateYYYYMMDD(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }

          // Parse schedule helper (copied from existing code)
          function parseSchedule(scheduleStr) {
            if (!scheduleStr) return [];
            const parts = scheduleStr.split(',').map(p => p.trim());
            const slots = [];
            parts.forEach(part => {
              const match = part.match(/^([A-Za-z]+)\s+(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
              if (match) {
                const [, day, hour, minute, period] = match;
                let hour24 = parseInt(hour);
                if (period.toUpperCase() === 'PM' && hour24 !== 12) hour24 += 12;
                if (period.toUpperCase() === 'AM' && hour24 === 12) hour24 = 0;
                slots.push({ day, hour: hour24, minute: parseInt(minute) });
              }
            });
            return slots;
          }

          // Check if reminder was already sent
          function wasReminderSent(studentId, dateStr) {
            return sentClassReminders[studentId]?.[dateStr] ? true : false;
          }

          // Mark reminder as sent
          function markReminderSent(studentId, dateStr) {
            if (!sentClassReminders[studentId]) {
              sentClassReminders[studentId] = {};
            }
            sentClassReminders[studentId][dateStr] = Date.now();
            localStorage.setItem('class_reminders_sent', JSON.stringify(sentClassReminders));
          }

          // Load sent reminders from localStorage
          function loadSentReminders() {
            try {
              const stored = localStorage.getItem('class_reminders_sent');
              if (stored) {
                sentClassReminders = JSON.parse(stored);
              }
            } catch (e) {
              console.error('[ClassReminderManager] Error loading sent reminders:', e);
            }
          }

          // Send class reminder via email system
          async function sendClassReminder(student, classDate, classTime, groupName, paymentStatus, creditBalance) {
            const iframe = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!iframe || !iframe.contentWindow) {
              console.error('[ClassReminderManager] Email system iframe not found');
              return false;
            }

            // Determine if "today" or "tomorrow"
            const nowLA = getLADate();
            const classDateObj = new Date(classDate + 'T00:00:00-08:00');
            const diffDays = Math.floor((classDateObj - nowLA) / (1000 * 60 * 60 * 24));
            const timeOfDay = diffDays === 0 ? 'today' : 'tomorrow';

            // Generate payment message based on status
            let paymentMessage = '';
            if (paymentStatus === 'paid') {
              paymentMessage =
                '<p style="color: #10b981; font-weight: 600;">‚úÖ Your payment for this class is confirmed!</p>';
            } else if (creditBalance > 0) {
              const studentPrice = student.payPerClass || student.pricePerClass || 50;
              const remainingCredit = creditBalance - studentPrice;
              paymentMessage = `<div class="info-box" style="background-color: #fef3c7; border-left-color: #f59e0b;">
                <p style="margin: 4px 0;"><strong>üí≥ Credit Available:</strong> Your credit balance of $${creditBalance} will be applied to this class.</p>
                <p style="margin: 4px 0;"><strong>Remaining Credit:</strong> $${remainingCredit} after this class</p>
              </div>`;
            } else {
              paymentMessage = `<div class="info-box" style="background-color: #fef2f2; border-left-color: #ef4444;">
                <p style="margin: 4px 0;"><strong>‚ö†Ô∏è Payment Reminder:</strong> Please make your payment before class starts to avoid delays in notes being uploaded to Google Classroom.</p>
              </div>
              <div class="payment-frame">
                <p style="margin: 0 0 8px 0; font-size: 16px; color: #4b5563;">
                  <strong>Send Money with <span style="color: #764ba2;">Zelle¬Æ</span></strong>
                </p>
                <p style="margin: 0 0 12px 0; font-size: 14px; color: #6b7280;">
                  Scan in your banking app to pay.
                </p>
                <div style="margin: 12px 0;">
                  <p style="margin: 0 0 4px 0; font-size: 16px; font-weight: 600; color: #1f2937;">Arnoma</p>
                  <p style="margin: 0 0 12px 0; font-size: 14px; color: #4b5563;">909-300-5155</p>
                </div>
                <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/Arnoma%20Zelle.JPG" alt="Zelle QR Code" style="max-width:180px;height:auto;border:0;display:block;margin:0 auto" />
                <p style="margin: 12px 0 0 0; font-size: 16px; color: #9ca3af;">
                  <strong style="color: #764ba2;">Zelle</strong>
                </p>
              </div>`;
            }

            // Format class date nicely
            const classDateFormatted = classDateObj.toLocaleDateString('en-US', {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            });

            // Send message to email system
            iframe.contentWindow.postMessage(
              {
                action: 'sendClassReminder',
                student: student,
                classDate: classDateFormatted,
                classTime: classTime,
                groupName: groupName,
                timeOfDay: timeOfDay,
                paymentMessage: paymentMessage,
              },
              '*'
            );

            return true;
          }

          // Main check function - runs every hour
          async function checkAndSendReminders() {
            try {
              // Check if automation is paused
              if (localStorage.getItem('automation_system_class_reminder_12h_paused') === 'true') {
                console.log('[ClassReminderManager] ‚è∏Ô∏è PAUSED - Skipping reminder check');
                return;
              }

              const nowLA = getLADate();
              const todayStr = formatDateYYYYMMDD(nowLA);

              // Update last check time
              localStorage.setItem('class_reminder_last_check', new Date().toISOString());

              console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              console.log('[ClassReminderManager] üîç STARTING CLASS REMINDER CHECK');
              console.log('[ClassReminderManager] üìÖ LA Date:', todayStr);
              console.log(
                '[ClassReminderManager] üïê LA Time:',
                nowLA.toLocaleString('en-US', {
                  timeZone: 'America/Los_Angeles',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: true,
                })
              );

              // Wait for calendar data
              if (!window.currentCalendarData) {
                debugLog('[ClassReminderManager] ‚è≥ Calendar not initialized yet');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return;
              }

              const calendarData = window.currentCalendarData;
              if (!calendarData || !calendarData.days) {
                console.warn('[ClassReminderManager] ‚ùå No calendar data available');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return;
              }

              // Check all upcoming classes (today and tomorrow)
              let remindersSent = 0;
              let classesChecked = 0;

              // CRITICAL FIX: Use for...of instead of forEach to properly handle async/await
              for (const dayData of calendarData.days) {
                const dateStr = formatDateYYYYMMDD(dayData.date);
                const classDateObj = new Date(dateStr + 'T00:00:00-08:00');

                // Calculate hours until class
                for (const classData of dayData.studentsWithClass) {
                  classesChecked++;
                  const student = classData.student;
                  const group = groups.find(g => g.name === student.group);

                  if (!group || !group.schedule) continue;

                  // Parse class time
                  const scheduleSlots = parseSchedule(group.schedule);
                  const dayName = classDateObj.toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    weekday: 'long',
                  });
                  const todaySlot = scheduleSlots.find(slot => slot.day === dayName);

                  if (!todaySlot) continue;

                  // Calculate exact class start time in LA
                  const classStartTime = new Date(classDateObj);
                  classStartTime.setHours(todaySlot.hour, todaySlot.minute, 0, 0);

                  // Check if we're 12 hours before class
                  const hoursUntilClass = (classStartTime - nowLA) / (1000 * 60 * 60);

                  // Send if between 11.5 and 12.5 hours before (1-hour window)
                  if (hoursUntilClass >= 11.5 && hoursUntilClass <= 12.5) {
                    // Check if already sent
                    if (wasReminderSent(student.id, dateStr)) {
                      debugLog(`[ClassReminderManager] ‚è≠Ô∏è Already sent reminder to ${student.name} for ${dateStr}`);
                      continue;
                    }

                    // Format class time
                    const classTimeFormatted = classStartTime.toLocaleString('en-US', {
                      hour: 'numeric',
                      minute: '2-digit',
                      hour12: true,
                    });

                    console.log(`[ClassReminderManager] üìß Sending class reminder to ${student.name}`);
                    console.log(
                      `[ClassReminderManager]    Class: ${student.group} on ${dateStr} at ${classTimeFormatted}`
                    );
                    console.log(`[ClassReminderManager]    Hours until class: ${hoursUntilClass.toFixed(1)}`);

                    // Determine payment status
                    const paymentStatus = classData.status;
                    const creditBalance = student.creditBalance || 0;

                    const sent = await sendClassReminder(
                      student,
                      dateStr,
                      classTimeFormatted,
                      student.group,
                      paymentStatus,
                      creditBalance
                    );

                    if (sent) {
                      markReminderSent(student.id, dateStr);
                      remindersSent++;
                      console.log(`[ClassReminderManager] ‚úÖ Reminder sent to ${student.name}`);
                    }
                  }
                }
              }

              console.log('\n[ClassReminderManager] üìä SUMMARY');
              console.log('  Classes checked:', classesChecked);
              console.log('  Reminders sent:', remindersSent);
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            } catch (error) {
              console.error('[ClassReminderManager] ‚ùå Error checking reminders:', error);
            }
          }

          // Initialize
          async function initialize() {
            loadSentReminders();
            console.log('[ClassReminderManager] üöÄ Class reminder system initialized');
            console.log('[ClassReminderManager] üìÖ Will send reminders 12 hours before each class');

            // Listen for email responses from iframe
            window.addEventListener('message', async event => {
              if (event.data.action === 'classReminderSent' && event.data.success) {
                const { student, classDate, emailContent } = event.data;

                console.log('[ClassReminderManager] ‚úÖ Class reminder sent successfully!');
                console.log('[ClassReminderManager] Student:', student.name);

                // Create notification
                if (window.NotificationCenter && emailContent) {
                  const emailSubject = emailContent.subject || 'Class Reminder';
                  await window.NotificationCenter.add(
                    window.NotificationCenter.NotificationType.INFO,
                    `Class Reminder Sent: ${emailSubject}`,
                    `Sent to ${student.name} (${student.email}) for class on ${classDate}`,
                    {
                      studentName: student.name,
                      metadata: {
                        date: classDate,
                        email: student.email,
                        emailSubject: emailSubject,
                        emailBody: emailContent.body,
                      },
                    }
                  );
                }
              }

              if (event.data.action === 'classReminderError') {
                console.error('[ClassReminderManager] ‚ùå Error sending class reminder:', event.data.error);
              }
            });

            // Listen for calendar initialization
            window.addEventListener('calendar:initialized', () => {
              debugLog('[ClassReminderManager] üìä Calendar initialized - scheduling first check in 10 seconds...');
              setTimeout(() => {
                checkAndSendReminders();
              }, 10000);
            });

            // Fallback: If calendar already initialized
            if (window.currentCalendarData) {
              setTimeout(() => {
                checkAndSendReminders();
              }, 10000);
            }

            // Run checks every hour
            setInterval(
              () => {
                checkAndSendReminders();
              },
              60 * 60 * 1000
            );
          }

          // Public API
          return {
            initialize,
            checkAndSendReminders,
          };
        })();

        // ============================================================================
        // CLASS STARTING SOON MANAGER (30-minute reminder)
        // Sends "Class Starting Soon" reminder 30 minutes before class starts
        // ============================================================================
        window.ClassStartingSoonManager = (function () {
          let sentReminders = {}; // {studentId: {date: timestamp}}

          function getLADate() {
            return new Date(
              new Date().toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
              })
            );
          }

          function formatDateYYYYMMDD(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }

          function parseSchedule(scheduleStr) {
            if (!scheduleStr) return [];
            const parts = scheduleStr.split(',').map(p => p.trim());
            const slots = [];
            parts.forEach(part => {
              const match = part.match(/^([A-Za-z]+)\s+(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
              if (match) {
                const [, day, hour, minute, period] = match;
                let hour24 = parseInt(hour);
                if (period.toUpperCase() === 'PM' && hour24 !== 12) hour24 += 12;
                if (period.toUpperCase() === 'AM' && hour24 === 12) hour24 = 0;
                slots.push({ day, hour: hour24, minute: parseInt(minute) });
              }
            });
            return slots;
          }

          function wasReminderSent(studentId, dateStr) {
            return sentReminders[studentId]?.[dateStr] ? true : false;
          }

          function markReminderSent(studentId, dateStr) {
            if (!sentReminders[studentId]) {
              sentReminders[studentId] = {};
            }
            sentReminders[studentId][dateStr] = Date.now();
            localStorage.setItem('class_starting_soon_sent', JSON.stringify(sentReminders));
          }

          function loadSentReminders() {
            try {
              const stored = localStorage.getItem('class_starting_soon_sent');
              if (stored) {
                sentReminders = JSON.parse(stored);
              }
            } catch (e) {
              console.error('[ClassStartingSoonManager] Error loading sent reminders:', e);
            }
          }

          async function sendStartingSoonReminder(student, classTime, groupName, classDate) {
            const iframe = document.querySelector('iframe[src*="email-system-complete.html"]');
            if (!iframe || !iframe.contentWindow) {
              console.error('[ClassStartingSoonManager] Email system iframe not found');
              return false;
            }

            const classDateFormatted = new Date(classDate + 'T00:00:00-08:00').toLocaleDateString('en-US', {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            });

            iframe.contentWindow.postMessage(
              {
                action: 'sendClassStartingSoon',
                student: student,
                classDate: classDateFormatted,
                classTime: classTime,
                groupName: groupName,
              },
              '*'
            );

            return true;
          }

          async function checkAndSendReminders() {
            try {
              // Check if automation is paused
              if (localStorage.getItem('automation_system_class_starting_soon_paused') === 'true') {
                console.log('[ClassStartingSoonManager] ‚è∏Ô∏è PAUSED - Skipping reminder check');
                return;
              }

              const nowLA = getLADate();
              const todayStr = formatDateYYYYMMDD(nowLA);

              // Update last check time
              localStorage.setItem('class_starting_soon_last_check', new Date().toISOString());

              console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              console.log('[ClassStartingSoonManager] üîç CHECKING 30-MIN REMINDERS');
              console.log('[ClassStartingSoonManager] üìÖ LA Date:', todayStr);
              console.log(
                '[ClassStartingSoonManager] üïê LA Time:',
                nowLA.toLocaleString('en-US', {
                  timeZone: 'America/Los_Angeles',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: true,
                })
              );

              if (!window.currentCalendarData) {
                debugLog('[ClassStartingSoonManager] ‚è≥ Calendar not initialized yet');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return;
              }

              const calendarData = window.currentCalendarData;
              if (!calendarData || !calendarData.days) {
                console.warn('[ClassStartingSoonManager] ‚ùå No calendar data available');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return;
              }

              let remindersSent = 0;
              let classesChecked = 0;

              for (const dayData of calendarData.days) {
                const dateStr = formatDateYYYYMMDD(dayData.date);
                const classDateObj = new Date(dateStr + 'T00:00:00-08:00');

                for (const classData of dayData.studentsWithClass) {
                  classesChecked++;
                  const student = classData.student;
                  const group = groups.find(g => g.name === student.group);

                  if (!group || !group.schedule) continue;

                  const scheduleSlots = parseSchedule(group.schedule);
                  const dayName = classDateObj.toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    weekday: 'long',
                  });
                  const todaySlot = scheduleSlots.find(slot => slot.day === dayName);

                  if (!todaySlot) continue;

                  const classStartTime = new Date(classDateObj);
                  classStartTime.setHours(todaySlot.hour, todaySlot.minute, 0, 0);

                  // Calculate minutes until class
                  const minutesUntilClass = (classStartTime - nowLA) / (1000 * 60);

                  // Send if between 25 and 35 minutes before (10-minute window)
                  if (minutesUntilClass >= 25 && minutesUntilClass <= 35) {
                    if (wasReminderSent(student.id, dateStr)) {
                      debugLog(`[ClassStartingSoonManager] ‚è≠Ô∏è Already sent to ${student.name} for ${dateStr}`);
                      continue;
                    }

                    const classTimeFormatted = classStartTime.toLocaleString('en-US', {
                      hour: 'numeric',
                      minute: '2-digit',
                      hour12: true,
                    });

                    console.log(`[ClassStartingSoonManager] üìß Sending to ${student.name}`);
                    console.log(`[ClassStartingSoonManager]    Class: ${student.group} at ${classTimeFormatted}`);
                    console.log(`[ClassStartingSoonManager]    Minutes until class: ${minutesUntilClass.toFixed(1)}`);

                    const sent = await sendStartingSoonReminder(student, classTimeFormatted, student.group, dateStr);

                    if (sent) {
                      markReminderSent(student.id, dateStr);
                      remindersSent++;
                      console.log(`[ClassStartingSoonManager] ‚úÖ Reminder sent to ${student.name}`);
                    }
                  }
                }
              }

              console.log('\n[ClassStartingSoonManager] üìä SUMMARY');
              console.log('  Classes checked:', classesChecked);
              console.log('  Reminders sent:', remindersSent);
              console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            } catch (error) {
              console.error('[ClassStartingSoonManager] ‚ùå Error:', error);
            }
          }

          async function initialize() {
            loadSentReminders();
            console.log('[ClassStartingSoonManager] üöÄ 30-minute reminder system initialized');

            // Listen for email responses
            window.addEventListener('message', async event => {
              if (event.data.action === 'classStartingSoonSent' && event.data.success) {
                const { student, classDate, emailContent } = event.data;
                console.log('[ClassStartingSoonManager] ‚úÖ Email sent to', student.name);

                if (window.NotificationCenter && emailContent) {
                  await window.NotificationCenter.add(
                    window.NotificationCenter.NotificationType.INFO,
                    `Class Starting Soon Email Sent`,
                    `Sent to ${student.name} (${student.email}) - Class in 30 minutes`,
                    {
                      studentName: student.name,
                      metadata: {
                        date: classDate,
                        email: student.email,
                        emailSubject: emailContent.subject,
                        emailBody: emailContent.body,
                      },
                    }
                  );
                }
              }
            });

            // Listen for calendar initialization
            window.addEventListener('calendar:initialized', () => {
              setTimeout(() => {
                checkAndSendReminders();
              }, 15000);
            });

            if (window.currentCalendarData) {
              setTimeout(() => {
                checkAndSendReminders();
              }, 15000);
            }

            // Check every 10 minutes (more frequent than 12h reminder)
            setInterval(
              () => {
                checkAndSendReminders();
              },
              10 * 60 * 1000
            );
          }

          return {
            initialize,
            checkAndSendReminders,
          };
        })();

        // ============================================================================
        // PAYMENT REMINDER EMAIL BODY RECONSTRUCTOR
        // Helper to add email previews to old notifications that were created before
        // the email preview feature was implemented
        // ============================================================================
        window.addEmailPreviewToOldNotifications = async function () {
          verboseLog('[EmailPreview] üîß Reconstructing email previews for old notifications...');

          const paymentNotifications = window.NotificationCenter.getAll().filter(
            n => n.title === 'Payment Reminder Sent' && n.metadata && !n.metadata.emailBody
          );

          console.log(`[EmailPreview] Found ${paymentNotifications.length} notifications without email body`);

          if (paymentNotifications.length === 0) {
            verboseLog('[EmailPreview] ‚úÖ All notifications already have email previews!');
            return;
          }

          // Get payment reminder template from email system
          const iframe = document.querySelector('iframe[src*="email-system-complete.html"]');
          if (!iframe || !iframe.contentWindow) {
            console.error('[EmailPreview] ‚ùå Email system iframe not found');
            console.error('[EmailPreview] Make sure you are on the Students tab where the email system is loaded');
            return;
          }

          // Request template from email system
          iframe.contentWindow.postMessage({ action: 'getPaymentReminderTemplate' }, '*');

          // Wait for template response
          const template = await new Promise(resolve => {
            const handler = event => {
              if (event.data.action === 'paymentReminderTemplate') {
                window.removeEventListener('message', handler);
                resolve(event.data.template);
              }
            };
            window.addEventListener('message', handler);

            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handler);
              resolve(null);
            }, 5000);
          });

          if (!template) {
            console.error('[EmailPreview] ‚ùå Could not get email template');
            return;
          }

          verboseLog('[EmailPreview] ‚úÖ Got email template, reconstructing emails...');

          // Helper function to format date nicely
          const formatClassDate = dateStr => {
            const date = new Date(dateStr + 'T00:00:00');
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
          };

          // Reconstruct email for each notification
          let updated = 0;
          let failed = 0;

          for (const notification of paymentNotifications) {
            const { studentName, metadata, id } = notification;
            const { amount, date } = metadata;

            // Format date nicely: "Wednesday, November 16, 2025"
            const formattedDate = formatClassDate(date);

            // Reconstruct email using template
            const subject = template.subject
              .replace(/\{\{StudentName\}\}/gi, studentName)
              .replace(/\{\{balance\}\}/gi, `$${amount}`);

            const body = template.body
              .replace(/\{\{StudentName\}\}/gi, studentName)
              .replace(/\{\{balance\}\}/gi, `$${amount}`)
              .replace(/\{\{Balance\}\}/gi, `$${amount}`)
              .replace(/\{\{classDate\}\}/gi, formattedDate)
              .replace(/\{\{ClassDate\}\}/gi, formattedDate)
              .replace(/\{\{UnpaidClasses\}\}/gi, `Class on ${formattedDate} - Amount owed: $${amount}`);

            // Update notification metadata in memory
            notification.metadata.emailSubject = subject;
            notification.metadata.emailBody = body;

            // Update in Supabase
            try {
              const { error } = await supabase
                .from('notifications')
                .update({ metadata: notification.metadata })
                .eq('id', id);

              if (error) {
                console.error(`[EmailPreview] ‚ùå Failed to update notification ${id}:`, error);
                failed++;
              } else {
                updated++;
              }
            } catch (err) {
              console.error(`[EmailPreview] ‚ùå Exception updating notification ${id}:`, err);
              failed++;
            }
          }

          console.log(`[EmailPreview] ‚úÖ Updated ${updated} notifications with email previews!`);
          if (failed > 0) {
            console.warn(`[EmailPreview] ‚ö†Ô∏è Failed to update ${failed} notifications`);
          }
          verboseLog('[EmailPreview] üéâ You can now click any payment reminder notification to see the email preview');

          // Reload notifications from Supabase to get fresh data
          if (window.NotificationCenter && window.NotificationCenter.initialize) {
            await window.NotificationCenter.initialize();
          }
        }; // ============================================================================
        // END PAYMENT REMINDER EMAIL BODY RECONSTRUCTOR
        // ============================================================================

        // ============================================================================
        // NOTIFICATION CENTER - Track all emails, changes, and system events
        // ============================================================================
        window.NotificationCenter = (function () {
          let notifications = [];
          let unreadCount = 0;
          const MAX_NOTIFICATIONS = 500; // Keep last 500 notifications

          // Notification types
          const NotificationType = {
            EMAIL: 'email',
            PAYMENT: 'payment',
            UPDATE: 'update',
            REMINDER: 'reminder',
            SYSTEM: 'system',
            STATUS_CHANGE: 'status_change',
            GROUP_CHANGE: 'group_change',
            SCHEDULE_UPDATE: 'schedule_update',
            ABSENCE: 'absence',
          };

          // Load notifications from Supabase
          async function loadFromSupabase() {
            // Skip if not authenticated
            if (!isAuthenticated || !currentUser) {
              debugLog('[NotificationCenter] ‚è≠Ô∏è Skipping load - not authenticated');
              return;
            }

            try {
              const { data, error } = await supabase
                .from('notifications')
                .select('*')
                .order('timestamp', { ascending: false })
                .limit(MAX_NOTIFICATIONS);

              if (error) {
                // Silently fail if authentication/permission error
                if (
                  error.code === 'PGRST301' ||
                  error.message.includes('JWT') ||
                  error.message.includes('Load failed')
                ) {
                  debugLog('[NotificationCenter] ‚è≠Ô∏è Skipping - auth required');
                  return;
                }
                console.error('[NotificationCenter] ‚ùå Error loading notifications:', error);
                return;
              }

              if (data && data.length > 0) {
                // Truncate helper for loading (handles old data that may exceed limits)
                const safeTruncate = (str, maxLen = 50) => {
                  if (!str) return null;
                  return str.length > maxLen ? str.substring(0, maxLen - 3) + '...' : str;
                };

                notifications = data.map(n => ({
                  id: n.id,
                  type: n.type,
                  title: safeTruncate(n.title, 50),
                  description: safeTruncate(n.description, 50),
                  studentName: safeTruncate(n.student_name, 50),
                  groupName: safeTruncate(n.group_name, 50),
                  metadata: n.metadata || {},
                  timestamp: new Date(n.timestamp),
                  read: n.read || false,
                }));

                unreadCount = notifications.filter(n => !n.read).length;
                updateBellIcon();
              }

              debugLog('[NotificationCenter] ‚úÖ Loaded', notifications.length, 'notifications');
            } catch (error) {
              console.error('[NotificationCenter] ‚ùå Exception loading notifications:', error);
            }
          }

          // Save notification to Supabase
          async function saveToSupabase(notification) {
            // Skip if not authenticated
            if (!isAuthenticated || !currentUser) {
              debugLog('[NotificationCenter] ‚è≠Ô∏è Skipping save - not authenticated');
              return null;
            }

            try {
              // CRITICAL: Ensure all text fields respect 50-char Supabase limit
              const truncate = (str, maxLen = 50) => {
                if (!str) return null;
                const text = String(str);
                return text.length > maxLen ? text.substring(0, maxLen - 3) + '...' : text;
              };

              // Log what we're about to save for debugging
              debugLog('[NotificationCenter] üíæ Saving notification:', {
                title: notification.title,
                titleLength: notification.title?.length,
                description: notification.description,
                descLength: notification.description?.length,
                groupName: notification.groupName,
                groupLength: notification.groupName?.length,
              });

              const payload = {
                type: notification.type,
                title: truncate(notification.title, 50),
                description: truncate(notification.description, 50),
                student_name: truncate(notification.studentName, 50),
                group_name: truncate(notification.groupName, 50),
                metadata: notification.metadata || {},
                timestamp: notification.timestamp.toISOString(),
                read: false,
              };

              debugLog('[NotificationCenter] üì¶ Payload after truncation:', {
                title: payload.title,
                titleLen: payload.title?.length,
                description: payload.description,
                descLen: payload.description?.length,
                group_name: payload.group_name,
                groupLen: payload.group_name?.length,
              });

              const { data, error } = await supabase.from('notifications').insert(payload).select().single();

              if (error) {
                // Silently fail if authentication/permission error
                if (
                  error.code === 'PGRST301' ||
                  error.message.includes('JWT') ||
                  error.message.includes('Load failed')
                ) {
                  debugLog('[NotificationCenter] ‚è≠Ô∏è Skipping save - auth required');
                  return null;
                }
                console.error('[NotificationCenter] ‚ùå Error saving notification:', error);
                return null;
              }

              return data;
            } catch (error) {
              // Silently fail on network errors when not authenticated
              if (error.message?.includes('Load failed') || error.message?.includes('NetworkError')) {
                debugLog('[NotificationCenter] ‚è≠Ô∏è Skipping save - network/auth error');
                return null;
              }
              console.error('[NotificationCenter] ‚ùå Exception saving notification:', error);
              return null;
            }
          }

          // Add a notification
          async function add(typeOrObject, title, description, options = {}) {
            // Support both object-based and individual parameter signatures
            let notification;

            if (typeof typeOrObject === 'object' && typeOrObject !== null) {
              // New object-based API (used by email automation iframe)
              notification = {
                type: typeOrObject.type || NotificationType.SYSTEM,
                title: typeOrObject.title,
                description: typeOrObject.description,
                studentName: typeOrObject.student_name || typeOrObject.studentName || null,
                groupName: typeOrObject.group_name || typeOrObject.groupName || null,
                metadata: typeOrObject.metadata || {},
                timestamp: new Date(),
                read: false,
              };
            } else {
              // Legacy individual parameter API
              notification = {
                type: typeOrObject,
                title,
                description,
                studentName: options.studentName || null,
                groupName: options.groupName || null,
                metadata: options.metadata || {},
                timestamp: new Date(),
                read: false,
              };
            }

            // Save to Supabase
            const saved = await saveToSupabase(notification);
            if (saved) {
              notification.id = saved.id;
              notifications.unshift(notification);

              // Trim to max size
              if (notifications.length > MAX_NOTIFICATIONS) {
                notifications = notifications.slice(0, MAX_NOTIFICATIONS);
              }

              unreadCount++;
              updateBellIcon();

              debugLog('[NotificationCenter] üîî New notification:', notification.title);
            }

            return notification;
          }

          // Mark notification as read
          async function markAsRead(notificationId) {
            try {
              const { error } = await supabase.from('notifications').update({ read: true }).eq('id', notificationId);

              if (error) {
                console.error('[NotificationCenter] ‚ùå Error marking as read:', error);
                return false;
              }

              const notification = notifications.find(n => n.id === notificationId);
              if (notification && !notification.read) {
                notification.read = true;
                unreadCount = Math.max(0, unreadCount - 1);
                updateBellIcon();
              }

              return true;
            } catch (error) {
              console.error('[NotificationCenter] ‚ùå Exception marking as read:', error);
              return false;
            }
          }

          // Mark all as read
          async function markAllAsRead() {
            try {
              const unreadIds = notifications.filter(n => !n.read).map(n => n.id);
              if (unreadIds.length === 0) return true;

              const { error } = await supabase.from('notifications').update({ read: true }).in('id', unreadIds);

              if (error) {
                console.error('[NotificationCenter] ‚ùå Error marking all as read:', error);
                return false;
              }

              notifications.forEach(n => (n.read = true));
              unreadCount = 0;
              updateBellIcon();

              return true;
            } catch (error) {
              console.error('[NotificationCenter] ‚ùå Exception marking all as read:', error);
              return false;
            }
          }

          // Get all notifications
          function getAll() {
            return notifications;
          }

          // Get notifications grouped by date
          function getGroupedByDate() {
            const grouped = {};
            const nowLA = getNowLA();
            const todayLA = getTodayLA();

            notifications.forEach(notification => {
              const notifDate = new Date(
                notification.timestamp.toLocaleString('en-US', {
                  timeZone: 'America/Los_Angeles',
                })
              );
              const notifDateStr = notifDate.toISOString().slice(0, 10);

              let dateLabel;
              if (notifDateStr === todayLA) {
                dateLabel = 'Today';
              } else {
                const yesterday = new Date(nowLA);
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().slice(0, 10);

                if (notifDateStr === yesterdayStr) {
                  dateLabel = 'Yesterday';
                } else {
                  dateLabel = notifDate.toLocaleDateString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                  });
                }
              }

              if (!grouped[dateLabel]) {
                grouped[dateLabel] = [];
              }

              grouped[dateLabel].push(notification);
            });

            return grouped;
          }

          // Update bell icon with unread count
          function updateBellIcon() {
            const bellBtn = document.getElementById('navNotificationBtn');
            if (!bellBtn) return;

            // Update title
            bellBtn.title =
              unreadCount > 0 ? `${unreadCount} unread notification${unreadCount !== 1 ? 's' : ''}` : 'Notifications';

            // Update badge
            let badge = bellBtn.querySelector('.notification-badge');
            if (unreadCount > 0) {
              if (!badge) {
                badge = document.createElement('span');
                badge.className = 'notification-badge';
                bellBtn.appendChild(badge);
              }
              badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
              badge.style.display = 'block';
            } else {
              if (badge) {
                badge.style.display = 'none';
              }
            }
          }

          // Initialize
          async function initialize() {
            debugLog('[NotificationCenter] üîÑ Initializing...');
            await loadFromSupabase();
            debugLog('[NotificationCenter] üîî Notification Center initialized');
            debugLog('[NotificationCenter] üìä Loaded', notifications.length, 'notifications');
            debugLog('[NotificationCenter] üì¨ Unread count:', unreadCount);

            // Add a test notification on first load (only if no notifications exist)
            if (notifications.length === 0) {
              debugLog('[NotificationCenter] üß™ Adding test notification (first load)...');
              await add(
                NotificationType.SYSTEM,
                'Welcome to ARNOMA',
                "Notification Center is now active! You'll see updates here for emails, payments, and important changes.",
                { metadata: { test: true } }
              );
            }
          }

          // Public API
          return {
            NotificationType,
            initialize,
            add,
            markAsRead,
            markAllAsRead,
            getAll,
            getGroupedByDate,
            getUnreadCount: () => unreadCount,
          };
        })();

        // CRITICAL FIX: Expose NotificationCenter to window so other functions can access it
        window.NotificationCenter = NotificationCenter;

        // ============================================================================
        // END NOTIFICATION CENTER
        // ============================================================================

        // ============================================================================
        // ‚ö° PERFORMANCE OPTIMIZATION - LAZY LOADING SYSTEM
        // ============================================================================

        // Track which systems have been initialized
        const initializationState = {
          core: false,
          calendar: false,
          notifications: false,
          studentManager: false,
          paymentRecords: false,
          quickView: false,
          emailSystem: false,
          automationSystem: false,
          gmailSystems: false,
          preferenceSync: false,
        };

        // Initialize on page load - MINIMAL WORK ONLY
        document.addEventListener('DOMContentLoaded', async function () {
          console.log('‚úÖ ARNOMA v2.14.0 - Canceled Class Calendar Fix ‚úÖ');

          // Check authentication FIRST
          const authenticated = await checkAuthentication();

          if (!authenticated) {
            return; // Stop initialization until user logs in
          }

          // ‚ö° CRITICAL: Only load CORE data immediately
          await initializeCoreData();
          console.log('‚úÖ Core data loaded');

          // ‚ö° Defer non-critical systems using requestIdleCallback
          deferredInitialization();
        });

        // PHASE 1: Load ONLY critical data (students, groups, payments)
        async function initializeCoreData() {
          if (initializationState.core) return;

          // Initialize the main app (loads students, groups, payments into cache)
          await initialize();

          initializationState.core = true;
        }

        // ‚ö° FIX #1: PHASE 2 - Defer everything else to idle time
        function deferredInitialization() {
          const scheduleWork = window.requestIdleCallback || (cb => setTimeout(cb, 500));

          const runTask = fn => {
            scheduleWork(() => {
              try {
                const result = fn();
                if (result && typeof result.then === 'function') {
                  result.catch(error => console.error('‚ö†Ô∏è Deferred task failed:', error));
                }
              } catch (error) {
                console.error('‚ö†Ô∏è Deferred task failed:', error);
              }
            });
          };

          // ‚ö° FIX #1: Delay heavy systems until after UI is visible
          runTask(() => setTimeout(initializeNotificationCenterLazy, 500));
          runTask(() => setTimeout(initializePaymentRecordsView, 800));
          runTask(() => setTimeout(initializePreferenceSync, 1000));
          runTask(() => setTimeout(initializeGmailSystems, 1200));
          runTask(() => setTimeout(initializeEmailAutomation, 1500));

          // Cleanup expired one-time schedules on startup and daily
          runTask(() =>
            setTimeout(async () => {
              await cleanupExpiredOneTimeSchedules();
              // Run cleanup once per day (24 hours)
              setInterval(cleanupExpiredOneTimeSchedules, 24 * 60 * 60 * 1000);
            }, 2000)
          );
          runTask(() => setTimeout(initializeAutomationManagers, 2000)); // Last priority

          // Calendar and other heavy UI sections lazy load when tabs are opened
        }

        async function initializeNotificationCenterLazy() {
          if (initializationState.notifications || !window.NotificationCenter) return;
          await window.NotificationCenter.initialize();
          initializationState.notifications = true;
        }

        function initializePaymentRecordsView() {
          if (initializationState.paymentRecords) return;

          populateMonthSelector();
          renderPaymentEmailsView();
          initializeDailyAutoBackup();

          const filterDropdown = document.getElementById('paymentFilterDropdown');
          if (filterDropdown && !filterDropdown.dataset.listenerAttached) {
            filterDropdown.addEventListener('change', renderPaymentEmailsView);
            filterDropdown.dataset.listenerAttached = 'true';
          }

          initializationState.paymentRecords = true;
        }

        function initializePreferenceSync() {
          if (initializationState.preferenceSync) return;
          initializeLAOffsetToggles();
          subscribeToPreferenceChanges();
          initializationState.preferenceSync = true;
        }

        function initializeGmailSystems() {
          if (initializationState.gmailSystems) return;

          const connection = getGmailConnection();
          if (connection && connection.access_token) {
            gmailAccessToken = connection.access_token;
            gmailTokenExpiry = connection.expiry_date.toString();
            updateGmailButtonState(true);
            showNotification('üü¢ Gmail connected', 'success');
          } else if (gmailAccessToken) {
            const expiry = parseInt(gmailTokenExpiry || '0');
            if (!(expiry && Date.now() < expiry)) {
              clearGmailConnection();
              gmailAccessToken = null;
              updateGmailButtonState(false);
            }
          }

          const autoRefreshBtn = document.getElementById('autoRefreshToggle');
          if (autoRefreshEnabled && autoRefreshBtn) {
            autoRefreshBtn.classList.add('auto-refresh-active');
            autoRefreshBtn.title = 'Auto-refresh ON (every 30s) - Click to disable';
            startAutoRefresh();
          }

          initializationState.gmailSystems = true;
        }

        async function initializeAutomationManagers() {
          if (initializationState.automationSystem) return;

          if (window.PaymentReminderManager) {
            await window.PaymentReminderManager.initialize();
            debugLog('‚úÖ Payment Reminder Manager initialized');
          }

          if (window.ClassReminderManager) {
            await window.ClassReminderManager.initialize();
            debugLog('‚úÖ Class Reminder Manager initialized');
          }

          if (window.ClassStartingSoonManager) {
            await window.ClassStartingSoonManager.initialize();
            debugLog('‚úÖ Class Starting Soon Manager initialized');
          }

          initializationState.automationSystem = true;
        }

        function initializeEmailAutomation() {
          if (initializationState.emailSystem) return;

          initializeEmailSystemIframe();
          queueEmailDataSend('initial');

          initializationState.emailSystem = true;
        }

        // Lazy load Student Manager when tab is opened
        function lazyLoadStudentManager() {
          if (initializationState.studentManager) return;

          // Student list rendering happens here
          // This is already called by openStudentManager()
          initializationState.studentManager = true;
        }

        // Lazy load Calendar when tab is opened
        function lazyLoadCalendar() {
          if (initializationState.calendar) return;
          initializationState.calendar = true;
        }

        // Lazy load Quick View timers
        function lazyLoadQuickView() {
          if (initializationState.quickView) return;

          // Quick View timer initialization
          // Will be called when Quick View is opened
          initializationState.quickView = true;
        }

        // Separate initialization function that can be called after login
        async function initializeApp() {
          // Re-initialize core data after login
          await initializeCoreData();

          // Start deferred initialization
          deferredInitialization();
        }

        console.log('‚ö° ARNOMA Performance Mode - Lazy loading enabled');
      </script>
    </div>
    <!-- End mainApp -->
  </body>
</html>
